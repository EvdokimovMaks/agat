!
! Общие функции для присоединенных форм Формы 11
!
.var
  Period  : string                 // период формы
  sYearOtch : string
  SARR     : array[1..5] of string;  // хранилище для разобранных строк. Доступ через #NAIM_POK(i,j)
  RowCnt : integer;                // количество строк
  ClmnCnt: array[1..1] of integer; // количество колонок в строке
  N1     : integer;                // счетчик для цикла вывода подстрок в печатную форму
.endvar
! Наименования показателей для текущей строки, разбитые на
! строки (строки разбиваются на колонки)
! Нулевой элемент в строке массива есть полная строка текста не разбитая на колонки
! Количество колонок: 5
#ifndef __FORM11FN_FRM_DEFS__
#define __FORM11FN_FRM_DEFS__
! -----------------------------------------------------------------------------
#define NAIM_POK(i,j) SARR[(#i-1)*5+#j+1]
! -----------------------------------------------------------------------------
! Очистка наименований. Количество колонок: то же.
#declare CLEAR_NAIM_POK
{
  var k : integer;
  for (k := 1; k <= RowCnt*5; k++) SARR[k] := '';
}
#end
#define C_STR_BEG '{'
#define C_STR_END '}'
#define C_COL_SEP '#'
#endif//__FORM11FN_FRM_DEFS__
! -----------------------------------------------------------------------------
.procedure ParseParamName(pS : string);
! Разбираем строку следующего вида:
! {SS..S#..#SS..S}..{SS..S#..#SS..S}
! Получаем набор строк разбитых на колонки.
! Символы '{' и '}' обозначают начало и конец строки
! Символы '#' делят строку на данные по колонкам
begin
  #CLEAR_NAIM_POK

  var p1 : word;
  var p2 : word;
  // разбор наименования на отдельные строки
  RowCnt := 0;
  var S : string; S := pS;
  p1 := Pos(#C_STR_BEG,S);
  if p1 = 0                   // Если нет разделителей строки то все рассматриваем
  {                           // как одну строку.
    RowCnt := 1;
    #NAIM_POK(RowCnt,0) := S;
  }
  else
  {
    do
    {
      p1 := Pos(#C_STR_BEG,S);
      if p1 = 0
        break;
      else
      {
        p2 := Pos(#C_STR_END,S);
        if p2 = 0
          break;
        else
        {
          RowCnt++;
          #NAIM_POK(RowCnt,0) := SubStr(S,p1+1,p2-p1-1);
          S := SubStr(S,p2+1,length(S)-p2);
        }
      }
    }
    while (true)
  }

  // разбор строк на данные по колонкам
  var i : word;
  for (i := 1; i <= RowCnt; i++)
  {
    ClmnCnt[i] := 0;
    S := #NAIM_POK(i,0);
    do
    {
      ClmnCnt[i]++;
      p2 := Pos(#C_COL_SEP,S);
      if p2 = 0
      {
        #NAIM_POK(i,ClmnCnt[i]) := S;
        break;
      }
      else
      {
        #NAIM_POK(i,ClmnCnt[i]) := SubStr(S,1,p2-1);
        S := SubStr(S,p2+1,length(S)-p2);
      }
    }
    while (true)
  }
end.
! -----------------------------------------------------------------------------
! парситстроку вида sss;dddd;ee  возвращает строку но номеру 0,1
.function ParseDopParamNum (pS : string; num: word) : string;
begin
  var p1 : word;
  var n  : word;     n := 0;
  var S  : string;   S := pS;
  do
  {
    result := S;
    p1 := Pos(';',S);
    if p1 = 0
      break;
    else
    {
      result := SubStr(S,1,p1-1);
      if (n = num)
        break;

      s := SubStr(S,p1+1, length(s));
      n++;
     }
  }
  while (true)
end.
! -----------------------------------------------------------------------------
.begin
  if boGetTune ('Rep.isHeader')
    Period := 'Отчет за период с ' + if(Longint(dFormStDate) <> 0, DateToStr(dFormStDate, 'DD/MM/YYYY'), '') + ' по ' + if(Longint(dFormEndDate) <> 0, DateToStr(dFormEndDate, 'DD/MM/YYYY'), '');
  else
    Period := '';
  sYearOtch    := DateToStr(if(Longint(dFormEndDate) > 0, dFormEndDate, Cur_Date ), 'YYYY');
  RowCnt := 0;
!end. // Вынес в вызывающий файл
