//------------------------------------------------------------------------------
//                                                      (c) Корпорация ГАЛАКТИКА
//------------------------------------------------------------------------------
// Галактика 5.8 - Бухгалтерский контур
// Интерфейсы выбора аналитики. Универсальный шаблон
//------------------------------------------------------------------------------

!-------------------------------------------------------------------------------
! Генерация ошибок компиляции при отсутствии необходимых макроопределений
!-------------------------------------------------------------------------------
#ifndef KauTable
#error  Не определено макроопределение KauTable (Имя таблицы КАУ)
#end
!-------------------------------------------------------------------------------
#ifndef KauConst
#error  Не определено макроопределение KauConst (Константа аналитики)
#end
!-------------------------------------------------------------------------------
#ifndef BrowseFields
#error  Не определено макроопределение BrowseFields (Поля для просмотра)
#end
!-------------------------------------------------------------------------------
! Поле для помещения в маркер по умолчанию
!-------------------------------------------------------------------------------
#ifndef MarkField
  #define MarkField #KauTable.NRec
#end
!-------------------------------------------------------------------------------
! Проверка макроопеределений для дерева
!-------------------------------------------------------------------------------
#ifdef  TreeKatalog
  #ifndef TreeField
  #error  Не определено макроопределение TreeField (Ссылка на вышестоящий элемент)
  #end
  #ifndef RuleForLeaf
  #error  Не определено макроопределение RuleForLeaf (Правило определения листа)
  #end
#else
  #ifdef BothOrder
  #error  Определено BothOrder для недеревянного интерфейса
  #end
  #ifdef BothOrderField
  #error  Определено BothOrderField для недеревянного интерфейса
  #end
  #ifdef OnlyBrowseFields
  #error  Определено OnlyBrowseFields для недеревянного интерфейса
  #end
  #ifdef OnlyTreeFields
  #error  Определено OnlyTreeFields для недеревянного интерфейса
  #end
  #ifdef BrowseKauOrdersCase
  #error  Определено BrowseKauOrdersCase для недеревянного интерфейса
  #end
  #ifdef TreeKauOrdersCase
  #error  Определено TreeKauOrdersCase для недеревянного интерфейса
  #end
#end
!-------------------------------------------------------------------------------
! Внутреннее макроопределение для эксклюзивных сортировок
!-------------------------------------------------------------------------------
#ifdef BrowseKauOrdersCase
  #define AreExclusiveOrders
#elifdef TreeKauOrdersCase
  #define AreExclusiveOrders
#end
#end
#ifdef AreExclusiveOrders
  #ifndef BothOrder
  #error  Не определено BothOrder при наличии эксклюзивных сортировок
  #end
  #ifndef BothOrderField
  #error  Не определено BothOrderField при наличии эксклюзивных сортировок
  #end
#end
#ifNdef AreExclusiveOrders
  #ifdef BothOrder
  #error Определено BothOrder при отсутствии эксклюзивных сортировок
  #end
  #ifdef BothOrderField
  #error определено BothOrderField при отсутствии эксклюзивных сортировок
  #end
#end

!-------------------------------------------------------------------------------
! информация о компилируемом интерфейсе
!-------------------------------------------------------------------------------
!#hint   Компилируем #KauConst (#KauTable) -> Interface Gt#KauConst
!-------------------------------------------------------------------------------
! Генерация предупреждений компиляции при отсутствии необходимых макроопределений
!-------------------------------------------------------------------------------
#ifndef EditCommand
!#hint   Нет cmEdit для #KauConst
#end
!-------------------------------------------------------------------------------
#ifndef AddCommand
!#hint   Нет cmAddNewRec для #KauConst
#end
!-------------------------------------------------------------------------------
! Справка по умолчанию
!-------------------------------------------------------------------------------
#ifndef HelpContext
  #define HelpContext hcAllVPick
#end
!-------------------------------------------------------------------------------

#ifndef VipInterfaceDeclareNotNeed
VipInterface Gt#KauConst Licensed (Free);
#end

#doc
Интерфейс выбора аналитики с кодом #KauConst.<br>
Внимание! Интерфейс предназначен только для внутреннего использования.
Для выбора аналитики в своем коде используйте объект ObjGetKau.
#end
Interface Gt#KauConst 'Выбор объекта аналитического учета' (,#HelpContext) DoAccept, EscClose, Cyan;
Show at (,1,90,23);

#ifdef GloInterfaceVars
  #GloInterfaceVars
#end

create view vGt#KauConst
var
  PickZero      : word;        // Признак выбора значения "не определено"

  wIntMode      : word;        // Параметр #1 Режим выбора
  wKatKau       : word;        // Параметр #2 Исходная выбираемая аналитика (Например, Код синонима)
  cKau          : comp;        // Параметр #3 Выбранная запись
  Markers       : TPtr;     // Параметр #4 Рабочий маркер
  SavedCurField : longint;     // для сохранения текущего поля
  OrderFieldNum : longint;     // для сохранения номера поля, по которому установлена сортировка
  SortOrderFld  : longint;     // для сохранения порядка сортировки поля
  NotPickFldKAU : boolean;     // для запрета выбора папок в качестве значения аналитики
  #ifdef AddKauVars
    #AddKauVars
  #end
  #ifdef PseudoTree
  PseudoNode  : comp;
  #end
  #ifdef TreeKatalog
  cNode       : comp;        // Ссылка на вышестоящий элемент
  PickSubord  : word;        // Помечать ли подчиненные записи
  isMainTree  : boolean;     // Текущее представление дерево/броуз
  #end
  oiGetKau : GetKau;
as select
  #ifNdef __RecMarker__
   // Признак выбора
   if (isValid(tn#KauTable),
     if (FoundMarker(Markers,#MarkField),'V',''),'')
       (FieldName = Picked),
  #end
  #ifdef AllowPick
    #AllowPick
  #else
    True
  #end
      (FieldName = isAllowPick),

  #ifdef TreeKatalog
    (NotPickFldKAU
     and isValid(tnSubKau)
     and (wIntMode and cgiMulti) <> cgiMulti)
  #else
    false
  #end
      (FieldName = isNeedColorForFldKAU)

  #ifdef IsNeedColor
    ,#IsNeedColor (FieldName = isNeedColor)
   #end

  #ifdef AddSelectVars
    #AddSelectVars
  #end
  ,KatKau.Name
from
     #KauTable
  #ifndef CanEditKauTable
    (ReadOnly)
  #end

  #ifdef TreeKatalog
    ,#KauTable SubKau // Для отображения наличия подчиненных в Browse

    #ifndef CanEditSubKauTable
     (ReadOnly)
    #end
  #end
  ,KatKau           (ReadOnly)
  #ifdef AddKauTables
    #AddKauTables
  #endif
where
((
      wKatKau         ==  KatKau.KodGroup
  #ifdef TreeKatalogSpecBound
    #TreeKatalogSpecBound
  #end
  #ifdef TreeKatalog
  and #KauTable.NRec  ==  SubKau.#TreeField
  #end
  #ifdef AddLogTableBounds
    #AddLogTableBounds
  #endif
  // Дополнительные ограничения
))
#ifdef TreeKatalog
  #ifdef PrivateForTreeBounds
    #PrivateForTreeBounds
  #else
    bounds ForTree =  cNode  ==  #KauTable.#TreeField ordered by TableOrder
  #end
#end
#ifdef KauOrders
  #KauOrders
#end
#ifdef KauBounds
  #KauBounds
#end
;
Parameters
   wIntMode  // Режим выбора
  ,wKatKau   // Исходная выбираемая аналитика (Например, Код синонима)
  ,cKau      // Выбранная запись
  ,Markers   // Рабочий маркер
  #ifdef AddKauParameters
    #AddKauParameters
  #end
  ;

!-------------------------------------------------------------------------------
function GetSavedName      : string; { GetSavedName      := 'Gt_Saved_cKau_' + #__InterfaceName__; }
function GetPickSubordName : string; { GetPickSubordName := 'Gt_PickSubord_' + #__InterfaceName__; }
function GetMainFormatName : string; { GetMainFormatName := 'Gt_MainFormat_' + #__InterfaceName__; }
function GetSavedFieldName : string; { GetSavedFieldName := 'Gt_SavedField_' + #__InterfaceName__; }
function GetOrderFieldName : string; { GetOrderFieldName := 'Gt_OrderField_' + #__InterfaceName__; }
function GetSortOrdForFld  : string; { GetSortOrdForFld :=  'Gt_SortOrdFld_' + #__InterfaceName__; }

!-------------------------------------------------------------------------------
function isMultiMode : Boolean; { isMultiMode := ((wIntMode and cgiMulti)    = cgiMulti);    }
function isPickExt   : Boolean; { isPickExt   := ((wIntMode and cgiPickExt)  = cgiPickExt);  }
function isPickKau   : Boolean; { isPickKau   := ((wIntMode and cgiPickKau)  = cgiPickKau);  }
function isNotEdit   : Boolean; { isNotEdit   := ((wIntMode and cgiNotEdit)  = cgiNotEdit);  }
function IsPickLeaf  : Boolean; { IsPickLeaf  := ((wIntMode and cgiPickLeaf) = cgiPickLeaf); }
!-------------------------------------------------------------------------------
procedure SetNameWindow;
begin
  SetWindowTitle(wnMainWindow,
                 if (isValid(#KatKau),KatKau.Name,'!? Аналитика номер ' + string(#wKatKau))
                 #ifdef AddKauTitle
                 + ' ' +
                 #AddKauTitle
                 #end
                 #ifNdef __RecMarker__
                 + if (isMultiMode,' (Выбрано: ' + string(GetMarkerCount(Markers)) + ')','')
                 #end
                 + case ( oiGetKau.GetKauMode;
                          wFlKau_Select      : ' - режим "выбрать из каталога"',
                          wFlKau_SelectDb    : ' - режим "выбрать из каталога для дебета"',
                          wFlKau_SelectCr    : ' - режим "выбрать из каталога для кредита"';
                          '')
                 );
end; // SetNameWindow
!-------------------------------------------------------------------------------
procedure NoDataMessage;
begin
  Message('Нет значений для выбора : "' +
          if (isValid(#KatKau),KatKau.Name,
                               '!? Аналитика номер ' + string(#wKatKau)) + '" !',OkButton);
end; // NoDataMessage
!-------------------------------------------------------------------------------

#ifdef __RecMarker__
var
  pMarker : IMarker(MarkerAn) New;
#endif

!-------------------------------------------------------------------------------
panel PanWin table #KauTable;
!-------------------------------------------------------------------------------
#ifdef PseudoTree
!-------------------------------------------------------------------------------
tree
  #ifdef NumColumnForIcons
    #NumColumnForIcons
  #else
    1
  #end
  brGetKau ('Выберите объект(ы) аналитического учета и нажмите Enter');
show at (,,,19);
#ifdef __RecMarker__
RecMarker = pMarker;
#end
Fields
  #ifNdef __RecMarker__
  #ifdef IsNeedColor
  {Font = {Color = if(Picked <> '', ColorMark, if(isNeedColor or isNeedColorForFldKAU, ColorGray, 0))}};
  #else
  {Font = {Color = if(not isAllowPick or isNeedColorForFldKAU, ColorGray, if(Picked = '', 0, ColorMark))}};
  #end
  Picked   'V' : [1], Skip, noAutoSize, Centered;
  #end
  #BrowseFields
  // Надо, ведь это псевдодерево
  #ifdef OnlyBrowseFields
    #OnlyBrowseFields
  #end
  #ifdef BrowseFieldsAtEnd
    #BrowseFieldsAtEnd
  #end
end; // tree
!-------------------------------------------------------------------------------
#else
!-------------------------------------------------------------------------------
#ifdef ParentBrowse
browse brParentKau ('Выберите объект(ы) аналитического учета и нажмите Enter', ,sci1Esc);
show at (,,,9);
#ifdef ParentTable
  Table #ParentTable
#end
Fields
  #ParentBrowseFields
end; // browse
#end
!-------------------------------------------------------------------------------
browse brGetKau ('Выберите объект(ы) аналитического учета и нажмите Enter');

#ifdef ShowAt
 #ShowAt
#else
show at (,,,19);
#end

#ifdef __RecMarker__
RecMarker = pMarker;
#end
Fields
  #ifNdef __RecMarker__
  #ifdef IsNeedColor
  {Font = {Color = if(Picked <> '', ColorMark, if(isNeedColor or isNeedColorForFldKAU, ColorGray, 0))}};
  #else
  {Font = {Color = if(not isAllowPick or isNeedColorForFldKAU, ColorGray, if(Picked = '', 0, ColorMark))}};
  #end
  Picked   'V' : [1], Skip, noAutoSize, Centered;
  #end
  #BrowseFields
  #ifdef OnlyBrowseFields
    #OnlyBrowseFields
  #end
  #ifdef BrowseFieldsAtEnd
    #BrowseFieldsAtEnd
  #end
  #ifdef TreeKatalog
    if (isValid(#SubKau),'+','') ('Наличие подчиненных записей') : [1], Protect, noAutoSize, Centered;
  #end
end; // browse
!-------------------------------------------------------------------------------
#end
!-------------------------------------------------------------------------------
#ifdef TreeKatalog
// "1" в следующей строке - дерево рисовать в поле #1 (фактически второе, так как нумерация с нуля)
tree
  #ifdef NumColumnForIcons
    #NumColumnForIcons
  #else
    1
  #end
  trGetKau ('Выберите объект(ы) аналитического учета и нажмите Enter');
show at (,,,19);
#ifdef __RecMarker__
RecMarker = pMarker;
#end
Fields
  #ifNdef __RecMarker__
  #ifdef IsNeedColor
  {Font = {Color = if(Picked <> '', ColorMark, if(isNeedColor or isNeedColorForFldKAU, ColorGray, 0))}};
  #else
  {Font = {Color = if(not isAllowPick or isNeedColorForFldKAU, ColorGray, if(Picked = '', 0, ColorMark))}};
  #end
  Picked   'V' : [1], Skip, noAutoSize, Centered;
  #end
  #BrowseFields
  #ifdef OnlyTreeFields
    #OnlyTreeFields
  #end
  #ifdef BrowseFieldsAtEnd
    #BrowseFieldsAtEnd
  #end
end; // tree
#end
!-------------------------------------------------------------------------------
Screen scExtended ('Расширенный режим множественного выбора объекта аналитического учета',,sci1EnIns);
show at (,20,,);
fields
  PickZero   : NoProtect;
  #ifdef TreeKatalog
  PickSubord : NoProtect;
  #end
<<
#ifdef TreeKatalog
 [.] объект аналитического учета "Не определен"` [.] Помечать подчиненные записи`
#else
 [.] объект аналитического учета "Не определен"`
#end
 [.] "Прочие" объекты аналитического учета     `
>>
end; // screen scExtended
!-------------------------------------------------------------------------------
Screen scEmpty;
show at (,20,,);
fields
    if( Length(oiGetKau.GetTXOName) > 90, Substr(oiGetKau.GetTXOName, 0, 87) + '...', oiGetKau.GetTXOName) : Skip, {Font = {Bold = TRUE}};
<<
.@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
>>
end; // screen scEmpty
!-------------------------------------------------------------------------------
! Установка сортировок
!-------------------------------------------------------------------------------
! Работает для cmSetCurField и cmColumnClicked
#ifdef KauOrdersCase
Procedure ChangeOrders(FieldNum: longint);
var
  FoundGoodOrder      : boolean;                 // Найден ли подходящий порядок
  SetSortingForFormat : longint;
{
  // cmSetCurField может делать порядок, только если __нет__никакого__
  // Иначе начинаются глюки с отображением
  // (При AltS например cmSetCurField будет кинуть дважды ?!)
  if (CurCommand = cmSetCurField) and
     ((GetColumnSorting(CurFormatInArea(brGetKau), FieldNum)) <> 0)
    Exit;
  FoundGoodOrder := true;
  SetSortingForFormat := -1;                                    // Всем форматам
  case (FieldNum) of
    // В этом case переключится сортировка
    #KauOrdersCase
    else
      FoundGoodOrder := false;
  end; // case
  // А дальше аккуратненько отсматриваем, какие эксклюзивные сортировки
  // можно поставить
  #ifdef BrowseKauOrdersCase
  if (not isMainTree)
    if (not FoundGoodOrder) {
      FoundGoodOrder := true;
      SetSortingForFormat := brGetKau;
      case (FieldNum) of
        #BrowseKauOrdersCase
        else
          FoundGoodOrder := false;
      end; // case
    }
  #end
  #ifdef TreeKauOrdersCase
  if (isMainTree)
    if (not FoundGoodOrder) {
      FoundGoodOrder := true;
      SetSortingForFormat := trGetKau;
      case (FieldNum) of
        #TreeKauOrdersCase
        else
          FoundGoodOrder := false;
      end; // case
    }
  #end
  if (not FoundGoodOrder) Exit;

  // меняем на обратную сортировку(если не было(0) - не поменяется)
  SortOrderFld := -1 * GetColumnSorting(CurFormatInArea(brGetKau), FieldNum);

  if CurCommand = cmInit // при загрузке читаем сохраненную сортировку из dsk
    ReadMyDsk(SortOrderFld,GetSortOrdForFld,false);

  case SortOrderFld of
    1, 0 :
    {
      SetColumnSorting(SetSortingForFormat, FieldNum, 1);
      SetTableBackOrderIn(##KauTable,false);
    }
    -1 :
    {
      SetColumnSorting(SetSortingForFormat, FieldNum, -1);
      SetTableBackOrderIn(##KauTable,true);
    }
  end; // case
  OrderFieldNum := FieldNum;
  ReReadRecord(##KauTable);
} // ChangeOrders
#end
!-------------------------------------------------------------------------------
HandleEvent // Panel

  #ifdef PseudoTree
    cmTreeTop    : PseudoNode := 0;
    cmTreeUp     : PseudoNode := 0;
    cmTreeDown   : PseudoNode := #KauTable.NRec;
    #ifdef MyTreeNodeType
      cmTreeNodeType : #MyTreeNodeType
    #else
      cmTreeNodeType : TreeSetNodeType(brGetKau, ntfText);
    #end
  #end

  #ifdef TreeKatalog
    #ifdef TreeTopNode
      cmTreeTop     : cNode := #TreeTopNode;
      cmTreeUp      : {
        if (#KauTable.NRec <> #TreeTopNode)
          cNode := #KauTable.#TreeField;
        else
          cNode := #TreeTopNode;
      }
      cmTreeNeedOwner : {
        if (#KauTable.#TreeField <> #TreeTopNode)
          TreeJumpToRecord(trGetKau, #KauTable.#TreeField);
        else
          TreeJumpToRecord(trGetKau, 0);
      }
    #else
      cmTreeTop       : cNode := 0;
      cmTreeUp        : cNode := #KauTable.#TreeField;
      cmTreeNeedOwner : TreeJumpToRecord(trGetKau, #KauTable.#TreeField);
    #end
    cmTreeDown      : cNode := #KauTable.NRec;
    #ifdef MyTreeNodeType
    cmTreeNodeType  : #MyTreeNodeType
    #else
    cmTreeNodeType  : if #RuleForLeaf TreeSetNodeType(trGetKau, ntfText);
    #end
  #end

  cmCheckField :
    if (CurField = #PickZero) {
      case (word(OldFieldValue) xor PickZero) of
        #ifdef __RecMarker__
        1 : pMarker.MarkUnMarkRec(cKauNRecNotDefine);
        2 : pMarker.MarkUnMarkRec(cKauNRecForOthers);
        #else
        1 : InvertMarker(Markers, comp(cKauNRecNotDefine));
        2 : InvertMarker(Markers, comp(cKauNRecForOthers));
        #end
      end; // case
      #ifNdef __RecMarker__
      SetNameWindow;
      #end
    }

  #ifdef KauOrdersCase
  cmSetCurField : {
    // Отсюда нужно уметь устанавливать порядок, только если
    // Еще нет никакого. В частности, при загрузке интерфейса он сработает
    if boGetTune('Fin.User.AutoSortKau')
      ChangeOrders(Target);
    if (Target <> -1)
      SavedCurField := Target ;
  }

  cmColumnClicked : {
    // Отсюда можно и обратный порядок установить
    ChangeOrders(Target);
  }
  #end

end; // HandleEvent
end; // Panel
!-------------------------------------------------------------------------------

!-------------------------------------------------------------------------------
#ifdef AddProcedures
  #AddProcedures
#end
!-------------------------------------------------------------------------------
#ifNdef __RecMarker__
procedure ClearChoice;
begin
  ClearMarker(Markers);
  PickZero := 0;
end; // ClearChoice
#end
!-------------------------------------------------------------------------------
procedure FindPickedDoc;
var
  cSavedKau : comp;
begin
  cSavedKau := 0;
  // Если #MarkField <> NRec то и переданный параметром NRec - не то,
  // на что нужно позиционироваться
  // Проверку можно сделать только на этапе исполнения :((
  if ('#MarkField' = '#KauTable.NRec') {
    cSavedKau := cKau;
  }
  #ifdef MrkFldPos
    cSavedKau := cKau;
  #end
  if (cSavedKau = 0)
    ReadMyDsk(cSavedKau,GetSavedName,false);
  #ifdef PrivateFindPickedDoc
    #PrivateFindPickedDoc
  #else
    if (cSavedKau <> 0)
      if (GetFirst #KauTable where ((cSavedKau == #KauTable.NRec)) = tsOk) {
        #ifdef TreeKatalog
          if (isMainTree)
            if (not TreeJumpToRecord(trGetKau,cSavedKau))
              TreeGetFirst(trGetKau);                     // Бесполезный оператор???
        #end
        Exit;
      }
    #ifdef TreeKatalog
      if (isMainTree) {
        if ((not TreeGetFirst(trGetKau)) or
            // Условие специально для случая, когда #KauTable - не корневая таблица
            // Например SpKau - Подцеплена к KatKau (#KauConst = KodGroup)
            (not isValid(##KauTable)))
          NoDataMessage;
      }
      else
        if (GetFirst #KauTable <> tsOk)
    #else
        if (GetFirst #KauTable <> tsOk)
    #end
          NoDataMessage;
  #end
end; // FindPickDoc
!-------------------------------------------------------------------------------
#ifNdef __RecMarker__
! Работает только с cmSelectAll и cmInvertAll
procedure NRecToMarker (MyNRec : comp);
begin
  case (CurCommand) of
    cmSelectAll : {
      // Делаю проверку на наличие, так как если будет использоваться
      // несортированный маркер, не будет поддерживаться уникальность
      // Maxxi: FoundMarker сильно тормозит пометку.
      //        Вместо этого перед пометкой всех элементов просто очистим маркер, тогда дупов не будет
      //if (not FoundMarker(Markers,MyNRec))
      InsertMarker(Markers,MyNRec);
    }
    cmInvertAll : {
      InvertMarker(Markers,MyNRec);
    }
  end; // case
end; // NRecToMarker
#end
!-------------------------------------------------------------------------------
#ifNdef __RecMarker__
! Работает только с cmSelectAll и cmInvertAll
procedure SelectInvertAll;
#ifdef TreeKatalog
  var ForCounter : boolean;
#end
begin
  StartNewVisual(vtNumericVisual, vfTimer + vfBreak + vfScreenBottom,
                 if (CurCommand = cmSelectAll,'Пометка всех записей','Инвертирование пометки'),
                 RecordsInTable(##KauTable));
  #ifdef TreeKatalog
  case (CurFormatInArea(brGetKau)) of
    brGetKau :
  #end
      PushPos(##KauTable);
  #ifdef TreeKatalog
    trGetKau :
      TreePushPos(trGetKau);
  end; // case
  #end
  _try {
    #ifdef TreeKatalog
    case (CurFormatInArea(brGetKau)) of
      brGetKau :
    #end
        _Loop #KauTable {
          NextVisual;
          if isAllowPick
          NRecToMarker(#MarkField);
        }
    #ifdef TreeKatalog
      trGetKau :
        for(ForCounter := TreeGetFirstEx(trGetKau);
            ForCounter;
            ForCounter := TreeGetNextEx(trGetKau)) {
          NextVisual;
          if isAllowPick
          NRecToMarker(#MarkField);
        }
    end; // case
    #end
    if (not isPickKau) {
      // А еще надо PickZero обработать корректно
      if (not isPickExt) {
        PickZero := if (CurCommand = cmSelectAll, 1, PickZero xor 1);
        NRecToMarker(comp(cKauNRecNotDefine));
      }
      else {
        PickZero := if (CurCommand = cmSelectAll, 2, PickZero xor 2);
        NRecToMarker(comp(cKauNRecForOthers));
      }
    }
  }
  _except
    on ExUserBreak : {
      //ClearChoice;
    }
  _finally {
    #ifdef TreeKatalog
    case (CurFormatInArea(brGetKau)) of
      brGetKau :
    #end
        PopPos(##KauTable);
    #ifdef TreeKatalog
      trGetKau :
        TreePopPos(trGetKau);
    end; // case
    #end
    SetNameWindow;
    ReScanPanel(##KauTable);
    StopVisual('',0);
  }
end; // SelectInvertAll
#end
!-------------------------------------------------------------------------------
#ifNdef __RecMarker__
! Для обработчика cmMarkUnMark
#ifdef TreeKatalog
exception ExNeedDrop;
#end
#end
!-------------------------------------------------------------------------------

!-------------------------------------------------------------------------------
! Универсальный QuickChoice
!-------------------------------------------------------------------------------
#ifndef NoQuickChoice
QuickChoice qcKau_Needed
{
  AcceptField = #MarkField;
  #ifdef QuickChoiceFields
    #QuickChoiceFields
  #else
    ViewField = #KauTable.Name;
    ViewField = #KauTable.Kod;
    SearchField = #KauTable.Name;
  #end
  OnOpen : {
    if (Markers = 0) {
      message('Fatal: Передан непроинициализированный маркер',Error);
      Abort; Exit;
    }
    #ifdef AddInitAction
      #AddInitAction
    #end
    #ifdef AddActionForMainBounds
      #AddActionForMainBounds
    #end
    #ifndef NoNameOrder
    SetOrder(tiByName);
    #end
  }
  OnClose : {
    cKau := #MarkField;
    // Множественный выбор умрет :(
    ClearMarker(Markers);
    InsertMarker(Markers,#MarkField);
    SaveMyDsk(#KauTable.NRec,GetSavedName);
    #ifdef AddReturnAction
      #AddReturnAction
    #end
  }
}
#end
!-------------------------------------------------------------------------------

HandleEvent   // Interface

  cmInit : {
    if (Markers = 0) {
      message('Fatal: Передан непроинициализированный маркер',Error);
      Abort; Exit;
    }
    #ifdef PseudoTree
    PseudoNode := 0;
    #end

    #ifdef TreeKatalog
      cNode := 0;
      // Считываем птичку "помечать подчиненные"
      if (not ReadMyDsk(PickSubord,GetPickSubordName,false))
        PickSubord := 1;
      if (not ReadMyDsk(isMainTree,GetMainFormatName,false)) {
        #ifdef PrivateDefaultFormat
          #PrivateDefaultFormat
        #else
          isMainTree := true;         // Для иерархических - по умолчанию дерево
        #end
      }
      if (isMainTree) {
        PushBounds(tbForTree);
        SetFormat(trGetKau);
        SetFieldState(#PickSubord,sfVisible);
      }
      else {
        // В случае, когда #KauTable не корневая (как в случае SpKau например)
        // Во время Init-а получается ???недостроенная??? ЛТ и начинаются глюки
        PopBounds(##KauTable);
        SetFormat(brGetKau);
        ClearFieldState(#PickSubord,sfVisible);
      }
    #end

    if (not ReadMyDsk(SavedCurField,GetSavedFieldName,false))
      SavedCurField := -1;
    if (SavedCurField <> -1) {
      SelectFieldInFormat(brGetKau,SavedCurField);
      #ifdef TreeKatalog
      SelectFieldInFormat(trGetKau,SavedCurField);
      #end
    }

    #ifdef KauOrdersCase
    // если не установлена автосортировка, то считаем прочитаем номер поля,
    // по которому была установлена сортировка
    if not boGetTune('Fin.User.AutoSortKau')
    {
      if (not ReadMyDsk(OrderFieldNum, GetOrderFieldName, false))
        OrderFieldNum := -1;
      if OrderFieldNum <> -1
        ChangeOrders(OrderFieldNum);
    }
    #end

    #ifdef AddInitAction
      #AddInitAction
    #end
    #ifdef AddActionForMainBounds
      #AddActionForMainBounds
    #end
    #ifndef NoNameOrder
      // Чтобы GetFirst в FindPickedDoc находил первую по нужному порядку
      // SetOrder(tiByName);
      // Maxxi 24/03/04: убрал при решении 106.7903
      // после этого SetOrder в FindPickedDoc при позиционировании на запомненном
      // листе ломалось дерево (на sql).
      // По-идее, он здесь и не нужен, т.к. после cmInit срабатывает cmSetCurField,
      // в котором порядок может поменяться.
    #end
    FindPickedDoc;
    // Установим контексты и Уберем колонку с выбором
    // Переключение формата
    if (isMultiMode) {
      SetHelpAndStatusContext(brGetKau,-1,
        #ifdef EditCommand
          #ifdef AddCommand
            sci147EnIns
          #else
            sci14EnIns
          #end
        #else
          #ifdef AddCommand
            sci17EnIns
          #else
            sci1EnIns
          #end
        #end
      , hcKeepCurrent);
      #ifdef TreeKatalog
        SetHelpAndStatusContext(trGetKau,-1,
          #ifdef EditCommand
            #ifdef AddCommand
              sci147EnInsTree
            #else
              sci14EnInsTree
            #end
          #else
            #ifdef AddCommand
              sci17EnInsTree
            #else
              sci1EnInsTree
            #end
          #end
        , hcKeepCurrent);
      #end
      #ifNdef __RecMarker__
      SetFieldState(#Picked, sfVisible);
      #end
      SetFormat(scExtended);
      // 26.11.2001
      // Пока решили, что cgiPickExt будет означать, что нужны только "прочие"
      // Так как и то и другое никто пока не использовал
      if (not isPickExt)
        ClusterDisabledField(#PickZero,2);
      else
        ClusterDisabledField(#PickZero,1);
      // А если так, то вообще недоступно
      if (isPickKau)
        ClusterDisabledField(#PickZero,3);
    }
    else {
      SetHelpAndStatusContext(brGetKau,-1,
        #ifdef EditCommand
          #ifdef AddCommand
            sci147EnEsc
          #else
            sci14EnEsc
          #end
        #else
          #ifdef AddCommand
            sci17EnEsc
          #else
            sci1EnEsc
          #end
        #end
      , hcKeepCurrent);
      #ifdef TreeKatalog
        SetHelpAndStatusContext(trGetKau,-1,
          #ifdef EditCommand
            #ifdef AddCommand
              sci147EnEscTree
            #else
              sci14EnEscTree
            #end
          #else
            #ifdef AddCommand
              sci17EnEscTree
            #else
              sci1EnEscTree
            #end
          #end
        , hcKeepCurrent);
      #end
      #ifNdef __RecMarker__
      ClearFieldState(#Picked, sfVisible);
      #end
      SetFormat(scEmpty);
      #ifdef __RecMarker__
      pMarker.Disable := true;
      #end
    }
    #ifdef _Transp_
    TranspOrgFltr := coGetTune('MyOrg');
    if wGetTune('Transp.GetAllTc') <> 2
    {
      if not BoundActive(tbbyTranspOrg)
        AddBounds(tbbyTranspOrg);
      ClearFieldState(#KatOrg.Name, sfVisible);
    }
    #end
    // Восстановление PickZero
    if (FoundMarker(Markers,comp(cKauNRecNotDefine)))
      PickZero := PickZero or 1;
    if (FoundMarker(Markers,comp(cKauNRecForOthers)))
      PickZero := PickZero or 2;
    // Наименование окна в самом конце
    SetNameWindow;
    if (isNotEdit) {
      DisableCommand(cmEdit);
      DisableCommand(cmAddNewRec);
    }
   NotPickFldKAU := not boGetTune('Fin.Anal.SelectFolderKau');
  }

  cmDone : {
    #ifdef TreeKatalog
      SaveMyDsk(PickSubord, GetPickSubordName);
      SaveMyDsk(isMainTree, GetMainFormatName);
    #end
    SaveMyDsk(SavedCurField, GetSavedFieldName);
    SaveMyDsk(OrderFieldNum, GetOrderFieldName);
    SaveMyDsk(SortOrderFld,  GetSortOrdForFld);
    #ifdef _Transp_
      if BoundActive(tbbyTranspOrg)
        SubBounds(tbbyTranspOrg);
    #end
  }

  cmDefault : {
    #ifdef TreeKatalog
      if (not isMultiMode) and (NotPickFldKAU)
      {
        if isValid(#SubKau)
        {
          message('Настройка '+ GetTuneName('Fin.Anal.SelectFolderKau') +
                  ''#13#3'не позволяет выбрать папку в качестве аналитики.');
          Abort;
          Exit;
        }
      }
    #end

    if (GetMarkerCount(Markers) = 0) {
      if (CurField = #PickZero) {
        if (not isPickExt)
          InsertMarker(Markers,comp(cKauNRecNotDefine));
        else
          InsertMarker(Markers,comp(cKauNRecForOthers));
      }
      else {
        // Может быть при отсутствии данных по подцепке ------------------------
        if (not isValid(##KauTable)) {
          Abort;
          Exit;
        }
        // ---------------------------------------------------------------------
        if isAllowPick
        InsertMarker(Markers,#MarkField);
        else {
          Abort;
          Exit;
        }
      }
    }
    // Теперь точно что то в маркере есть
    // Возьмем последний отмеченный элемент
    // Если он единственный, нас это тоже устраивает
    GetMarker(Markers, GetMarkerCount(Markers) - 1, cKau);
    // Сохраним в деск найденную позицию, если она нас не устраивает - текущую
    if ((cKau <> cKauNRecNotDefine) and (cKau <> cKauNRecForOthers)) {
      SaveMyDsk(cKau,GetSavedName);
      // Надо проверить случай #MarkField <> NRec и в этом случае закинуть
      // в dsk NRec, так как cKau - не NRec, а позицию будем потом
      // восстанавливать по NRec-у
      // Проверку можно сделать только на этапе исполнения :((
      if ('#MarkField' <> '#KauTable.NRec')
        SaveMyDsk(#KauTable.NRec,GetSavedName);
    }
    else
      SaveMyDsk(#KauTable.NRec,GetSavedName);
    #ifdef AddReturnAction
      #AddReturnAction
    #end
  }

  cmCancel : {
  }

  #ifNdef __RecMarker__
  cmMarkUnMark : {
    // Может быть при отсутствии данных по подцепке ----------------------------
    if (not isValid(##KauTable)) Exit;
    // -------------------------------------------------------------------------
    if isAllowPick
    InvertMarker(Markers,#MarkField);
    #ifdef TreeKatalog
    // В случае, если надо помечать подчиненые
    // !!! только в дереве !!!
    if (PickSubord <> 0) and (CurFormatInArea(brGetKau) = trGetKau) {
      TreePushPos(trGetKau);
      StartNewVisual(vtRotateVisual, vfTimer + vfBreak + vfScreenBottom,'Пометка подчиненных',0);
      _try {
        var AreMarked : boolean;
        AreMarked := FoundMarker(Markers,#MarkField);
        var MarkLevel : integer;
        MarkLevel := TreeLevel(trGetKau);
        while (TreeGetNextEx(trGetKau)) {
          NextVisual;
          if (TreeLevel(trGetKau) <= MarkLevel)
            _raise ExNeedDrop;
          if (AreMarked) { // Поставить у всех
            if (not FoundMarker(Markers,#MarkField))
              if isAllowPick
              InsertMarker(Markers,#MarkField);
          }
          else { // Убрать у всех
            DeleteMarker(Markers,#MarkField);
          }
        }
        // ---------------------------------------------------------------------
        // Позицию надо восстановить только в случае, если
        // TreeGetNextEx(tgGetKau) вернул false, то есть достигнут конец дерева
        // И неизвестно, будет ли этот конец на том же уровне, что и начальный узел пометки
        // Если на другом уровне (и элемент в данный момент вевидим),
        // то получим проблемы визуализации (будем стоять на невидимом элементе)
        // RescanPanel отобразит ерунду
        //
        // [-]                                                               (*)
        //  ├───
        //  ├───
        //  └[+] - в нем есть подчиненные                                   (**)
        //
        // И если на (*) нажать Ins - то позиция сместиться на (**)
        // и там отобразятся скрытые записи :)
        // ---------------------------------------------------------------------
        TreePopPos(trGetKau);
        // ---------------------------------------------------------------------
      }
      _except
        on ExUserBreak : {};
        on ExNeedDrop : {
          TreeDropPos(trGetKau);
        }
      _finally {
        ReScanPanel(##KauTable);
        StopVisual('',0);
      }
    }
    else
    #end
    {
      #ifdef Atl51
      RedrawCurrentAndGo(CurFormatInArea(brGetKau),true);
      #else
      ReDrawPanel(##KauTable);
      var OkNextPos : boolean;
      #ifdef TreeKatalog
      case (CurFormatInArea(brGetKau)) of
        brGetKau :
      #end
          // То есть при ifndef TreeKatalog только этот кусок отработает
          OkNextPos := (GetNext #KauTable = tsOk);
      #ifdef TreeKatalog
        trGetKau :
          OkNextPos := (TreeGetNext(trGetKau));
      end; // case
      #end
      if (OkNextPos) {
        CallToNeighBours(cmPosDown,##KauTable);
        PutCommand(cmPositionChanged);
        ReDrawPanel(##KauTable);
      }
      #end
    }
    SetNameWindow;
  }
  #end

  #ifNdef __RecMarker__
  cmSelectAll:
  {
    PickZero := 0;
    ClearChoice;
    SelectInvertAll;
  }
  #end

  cmUnSelectAll :
  {
    #ifdef __RecMarker__
    PickZero := 0;
    #else
    ClearChoice;
    SetNameWindow;
    ReScanPanel(##KauTable);
    #end
  }

  #ifNdef __RecMarker__
  cmInvertAll : {
    SelectInvertAll;
  }
  #end

  #ifdef EditCommand
  cmEdit : {
    #EditCommand
    ReReadRecord(##KauTable);
  }
  #end

  #ifdef AddCommand
  cmAddNewRec : {
    #AddCommand
    #ifdef ReposAfterAdd
    if (cKau <> -1)
      if (GetFirst #KauTable where ((cKau == #KauTable.NRec)) = tsOk) {
        #ifdef TreeKatalog
          if (isMainTree)
            TreeJumpToRecord(trGetKau,cKau);
        #end
      }
    #endif
    ReReadRecord(##KauTable);
  }
  #end

  #ifdef TreeKatalog
    #ifdef HotKeyLines
      #ifdef HotKeyLinesSpKauTree
        #HotKeyLinesSpKauTree
      #else
      cmHotKeys : {
        if (wIntMode and cgiMulti) = cgiMulti
          EnableCommand(cmPickKod);
        else
          DisableCommand(cmPickKod);
        case (CurFormatInArea(brGetKau)) of
          #ifdef ComponentVersion
          brGetKau : PutHotCommand(RunDynMenu('F_GetAn::HotKeys_#KauConst'+';Separator;'+'F_GetAn::HotKeys_AllGtKau_ForTree_Browse'));
          trGetKau : PutHotCommand(RunDynMenu('F_GetAn::HotKeys_#KauConst'+';Separator;'+'F_GetAn::HotKeys_AllGtKau_ForTree_Tree'));
          #else
          brGetKau : PutHotCommand(RunDynMenu('HotKeys_#KauConst'+';Separator;'+'HotKeys_AllGtKau_ForTree_Browse'));
          trGetKau : PutHotCommand(RunDynMenu('HotKeys_#KauConst'+';Separator;'+'HotKeys_AllGtKau_ForTree_Tree'));
          #end
        end; // case
      }
      #end
    #else
      cmHotKeys : {
        case (CurFormatInArea(brGetKau)) of
          brGetKau : PutHotCommand(RunMenu('HotKeys_AllGtKau_ForTree_Browse'));
          trGetKau : PutHotCommand(RunMenu('HotKeys_AllGtKau_ForTree_Tree'));
        end; // case
      }
    #end
  #else
    #ifdef HotKeyLines
      #ifdef HotKeyLinesSpKau
        #HotKeyLinesSpKau
      #else
      cmHotKeys : {
        PutHotCommand(RunMenu('HotKeys_#KauConst'));
      }
    #end
  #end
  #end

  #ifdef _Transp_
    cmHotKeys:
      if wGetTune('Transp.GetAllTc') <> 0
        PutHotCommand(RunMenu('HotKeys_cgKau_Transp'));
  #end

  #ifdef TreeKatalog
  cmShowAll : {
    if (CurFormatInArea(brGetKau) <> trGetKau) Exit;
    var ForCounter : boolean;
    TreePushPos(trGetKau);
    StartNewVisual(vtRotateVisual, vfTimer + vfBreak + vfScreenBottom,'Раскрытие всех папок',0);
    _try {
      for(ForCounter := TreeGetFirstEx(trGetKau);
          ForCounter;
          ForCounter := TreeGetNextEx(trGetKau)) {
        NextVisual;
        if (not TreeNodeIsOpen(trGetKau))
          TreeOpenNode(trGetKau);
      }
    }
    _except
      on ExUserBreak : {};
    _finally {
      TreePopPos(trGetKau);
      RescanPanel(##KauTable);
      StopVisual('',0);
    }
  }
  #end

  #ifdef TreeKatalog
  cmHideAll : {
    if (CurFormatInArea(brGetKau) <> trGetKau) Exit;
    // Поднимемся к ближайшему корню
    while #KauTable.#TreeField <> 0 {
      TreeJumpToRecord(trGetKau,#KauTable.#TreeField);
    }
    TreeCloseAllOpenedNode(trGetKau);
    RereadRecord(##KauTable);
  }
  #end

  #ifdef TreeKatalog
  cmAccording : {

    #ifdef BeforeAccording
      #BeforeAccording
    #endif

    // Перед переключением форматов в случае, если установлена сортировка,
    // применимая только на текущем формате (а соответственно и Bounds-е)
    // То сборосим Order в общий
    #ifdef AreExclusiveOrders
      if ((GetColumnSorting(CurFormatInArea(brGetKau),##BothOrderField)) = 0) {
        SetOrder(ti#BothOrder);
        // И установим сотировку в этом формате, чтобы когда снова в него
        // переключимся, было бы все корректно
        SetColumnSorting(CurFormatInArea(brGetKau),##BothOrderField,1);
        // Чтобы избежать меганий при установке текущего поля после переключения
        // форматов, в случае наличия AreExclusiveOrders перед переключением
        // между форматами установим текущее поле равным BothOrderField
        if (CurField <> ##BothOrderField) {
          SelectFieldInFormat(trGetKau,##BothOrderField);
          SelectFieldInFormat(brGetKau,##BothOrderField);
        }
      }
    #end
    case (CurFormatInArea(brGetKau)) of
      trGetKau : {
        PopBounds(tbForTree);
        // Сделал ради cgKau_VidNorX
        // Там дерево ломается, когда починят, можно будет убрать
        // (если конечно где нить еще не понадобится)
        #ifdef AddActionForMainBounds
          #AddActionForMainBounds
        #end
        // ---------------------------------------------------------------------
        // перед сменой формата установим текущее поле в невидимом формате
        // этим избавимся от мигания при переключении
        SelectFieldInFormat(brGetKau,CurField);
        isMainTree := false;
        SetFormat(brGetKau);
        ClearFieldState(#PickSubord,sfVisible);
      }
      brGetKau : {
        // !!! cNode поставить до PushBound (cNode в нем есть)
        cNode := #KauTable.#TreeField;
        PushBounds(tbForTree);
        // Сделал ради cgKau_VidNorX
        // Там дерево ломается, когда починят, можно будет убрать
        // (если конечно где нить еще не понадобится)
        #ifdef AddActionForMainBounds
          #AddActionForMainBounds
        #end
        // ---------------------------------------------------------------------
        TreeJumpToRecord(trGetKau,#KauTable.NRec);
        // Точно надо, а то все поедет
        RescanPanel(##KauTable);
        SelectFieldInFormat(trGetKau,CurField);
        // А это сделаем в самом конце, чтобы поменьше мультипликации было в деревянной панели
        isMainTree := true;
        SetFormat(trGetKau);
        SetFieldState(#PickSubord,sfVisible);
      }
    end; // case
    // Теперь если на текущем поле нет сортировки, то значит
    // Надо установить корректный обратный порядок на поле BothOrderField
    // (он сохранен в ColumnSorting)
    #ifdef AreExclusiveOrders
      if ((GetColumnSorting(CurFormatInArea(brGetKau),CurField)) = 0)
        if (GetColumnSorting(CurFormatInArea(brGetKau),##BothOrderField) = -1) {
          SetTableBackOrderIn(##KauTable,true);
          ReReadRecord(##KauTable);
        }

    #end
  }
  #end

  #ifdef SpecialKauCommands
    #SpecialKauCommands
  #end

end;          // HandleEvent Interface
End.          // Interface
!-------------------------------------------------------------------------------

!-------------------------------------------------------------------------------
! Грохнем все макроопределения, чтобы не забывали делать новые
!-------------------------------------------------------------------------------
#undef AreExclusiveOrders                         // Внутреннее макроопределение
!-------------------------------------------------------------------------------
#undef TreeKatalog
#undef GloInterfaceVars
#undef PseudoTree
#undef NumColumnForIcons
#undef KauTable
#undef KauConst
#undef TreeField
#undef MarkField
#undef PrivateForTreeBounds
#undef RuleForLeaf
#undef TreeTopNode
#undef MyTreeNodeType
#undef AddKauTitle
#undef AddKauParameters
#undef AddKauVars
#undef AddSelectVars
#undef AddActionForMainBounds
#undef PrivateFindPickedDoc
#undef PrivateDefaultFormat
#undef BrowseFields
#undef OnlyBrowseFields
#undef OnlyTreeFields
#undef BrowseFieldsAtEnd
#undef QuickChoiceFields
#undef NoQuickChoice
#undef KauBounds
#undef KauOrders
#undef BothOrder
#undef BothOrderField
#undef KauOrdersCase
#undef BrowseKauOrdersCase
#undef TreeKauOrdersCase
#undef NoNameOrder
#undef AddKauTables
#undef AddLogTableBounds
#undef AddInitAction
#undef AddReturnAction
#undef EditCommand
#undef AddCommand
#undef ReposAfterAdd
#undef AddProcedures
#undef SpecialKauCommands
#undef HotKeyLines
#undef HelpContext
#undef AllowPick
#undef BeforeAccording
#undef IsNeedColor
#undef TreeKatalogSpecBound
#undef MrkFldPos
#undef _Transp_
!-------------------------------------------------------------------------------
