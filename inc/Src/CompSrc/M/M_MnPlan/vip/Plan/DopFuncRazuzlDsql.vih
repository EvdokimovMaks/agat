#ifdef ComponentVersion
#Component "M_MnPlan"
#endif

#ifndef __Def_oDopFuncRazuzlDSQL__
#define __Def_oDopFuncRazuzlDSQL__

#doc
 Описание интерфейса-объекта "Дополнительные функции для использования в 103 алгоритме"</brief>
#end
ObjInterface oDopFuncRazuzlDSQL;

//------------------------------------------------------------------------------
#doc
 Заполнение таблицы связей</brief> <br>
 Результат: <br>
   True, если успешно<br>
#end
Function DSQL_CreateLinksTmpRsvOperObj(bUseLinkPos: boolean): boolean;
#doc
 Загрузка существующего журнала</brief> <br>
 bUseLinkPos - если этот параметр истина, то учитываются связи м/у позициями документа
 Результат: <br>
   True, если успешно<br>
#end
Function Dsql_LoadRsvOper(bUseLinkPos : boolean):boolean;
#doc
 Сравнение временных таблиц с существующим журналом</brief> <br>
 Результат: <br>
   True, если успешно<br>
#end
Function DSQL_CompareRsvOper:boolean;
#doc
 Обновление ЖР</brief> <br>
 Результат: <br>
   True, если успешно<br>
#end
Function DSQL_UpdateRsvOper:boolean;
#doc
 Поиск первых операций. Результат дописывается в табличку <br>
    tmpRsvFirstOper</brief> <br>
    cRsvOper - Nrec временной таблицы tmpRsvOperObj </brief> <br>
 Результат: <br>
   True, если успешно<br>
#end
Function DSQL_FindFirstOper(cRsvOper : longint):boolean;
#doc
 Поиск первых операций по связям. Результат дописывается в табличку <br>
    tmpRsvFirstOper <br>
    cRsvOper - Nrec временной таблицы tmpRsvOperObj </brief> <br>
    bIsForward - true, если расчет идет вперед
 Результат: <br>
   True, если успешно<br>
#end
Function DSQL_FindFirstOperByLink(cRsvOper:longint; bISForward : boolean):boolean;
#doc
 Поиск всех первых операций. Результат дописывается в табличку <br>
    tmpRsvFirstOper</brief> <br>
    bIsForward - true, если расчет идет вперед
 Результат: <br>
   True, если успешно<br>
#end
Function DSQL_FindFirstOperAll(bISForward : boolean):boolean;

#doc
 Поиск всех следующих операций к данной, у которых все предыдущие завершены.<br>
    Результат дописывается в табличку <br>
    cRsvOper - Nrec временной таблицы tmpRsvOperObj </brief> <br>
    bIsForward - true, если расчет идет вперед
 Результат: <br>
   True, если успешно<br>
#end
Function DSQL_AddNextOper(cRsvOper:longint; bIsForward : boolean):boolean;
#doc
 Получить следующую из найденных операций <br>
    cRsv - Возвращаемый, ссылка на RsvOper, если есть <br>
    ctmpRsv - возвращаемый, Nrec временной таблицы tmpRsvOperObj </brief> <br>
    bIsForward - true, если расчет идет вперед
 Результат: <br>
   True, если успешно<br>
#end
Function GetNextOper(var cRsv : comp; ctmpRsv : longint):boolean;
#doc
 Получить первую из найденных операций <br>
    cRsv - Возвращаемый, ссылка на RsvOper, если есть <br>
    ctmpRsv - возвращаемый, Nrec временной таблицы tmpRsvOperObj </brief> <br>
 Результат: <br>
   True, если успешно<br>
#end
Function GetFirstOper(var cRsv : comp; ctmpRsv : longint):boolean;
#doc
 Пробежать по всему дереву оперций <br>
  cRsvOper - Nrec временной таблицы tmpRsvOperObj  <br>
  bForward - true, если бежать от первых к последним  </brief> <br>
 Результат: <br>
   True, если успешно<br>
#end
Function DSQL_GetAllOperByLink(cRsvOper : longint; bForward : boolean):boolean;

#doc
  Подготовка запросов и создание временных таблиц. Таблицы из объекта <br>
   RazuzlDSQL уже должны быть созданы </brief>
#end
Procedure InitInter(indexType : word);

#doc
  Сохранение изменений в связях: Удаление и добавление.
#end
Function DSQL_SaveLinks:boolean;



#doc
 Установка cObrPl.
#end
Function DSQL_SetObrPl(ctmpRsvOper : longint; cObrPl, cWrkFnd : comp):boolean;
#doc
  Установка дат.
#end
Function DSQL_SetDates(cTmpRsvOper: longint; cStart,cEnd, cObrPl, cwrkFnd : comp):boolean;
#doc
  Поиск максимальной даты окончания из всех предыдущих, если bIsForward = true,
  Поиск максимальной даты начала из всех следующих, если bIsForward = false;
  wFlag - Если первый бит равен единице, то возвращенная дата будет с учетом времени пролеживания
  cdt - возвращаемаея дата-время
#end
Function DSQL_GetLinkDate(cTmpRsvOper: longint; bIsForward : boolean; wFlag : word; var cDt : comp):boolean;

#doc
  Поиск операции с минимальным возможным временем начала для данного ПЦ из очереди, если bIsForward = true,
  Поиск операции с максимальным временем окончания для данного ПЦ из очереди, если bIsForward = false.
  Возвращает Nrec временной таблицы tmpRsvOperObj
#end
Function DSQL_GetTmpRsvByPC(cObrPl: comp; bIsForward : boolean):longint;

#doc
  Поиск ПЦ операции из очереди с минимальным временем начала, если bIsForward = true,
  Поиск ПЦ операции из очереди с максимальным временем окончания, если bIsForward = false,
#end

Function DSQL_GetMinDatePC(bIsForward : boolean):comp;
#doc
  Сокращение времени производства
  ShiftNumber - номер смены
  wFlag and 1 > 0 - будет проводиться с учетом времени пролеживания
#end
function DSQL_RecalcDates(shiftNumber : word; bIsForward : boolean; wFlag : word) : boolean;
#doc
  Загрузка существующего НЗП
#end
Procedure DSQL_LoadExistsNZP;
#doc
  Удаление существующего НЗП, для сохранения оставшихся данных.
#end
Procedure DSQL_deleteExistsNZP;
#doc
  Загрузка существующего журнала по связям и вниз.
  bUseLinkPos - загружать ли связи между позициями
#end
Function DSQL_LoadRsvByLinks(bUseLinkPos : boolean):boolean;
#doc
  поиск критического пути
#end
Function FindCriticalWay:boolean;

#doc
  удаление фантомных записей
#end
Function DSQL_DeletePhantomRsv:boolean;
End; // ObjInterface oDopFuncRazuzlDSQL

Objinterface oDopFuncRazuzlDSQL1(oDopFuncRazuzlDSQL);
#doc
 Загрузка существующего журнала</brief> <br>
 bUseLinkPos - если этот параметр истина, то учитываются связи м/у позициями документа
 Результат: <br>
   True, если успешно<br>
#end
Function Dsql_LoadRsvOperEx(bUseLinkPos : boolean; cVariaPl : comp):boolean;
#doc
 Пересчет загруженного журнала, от введенной даты</brief> <br>
 datetime - дата, от которой рассчитывать<br>
 ShiftNumber - маска смен, используемых<br>
 bIsForward - если true, то направление расчета вперед<br>
 wFlag  and 1 - учитывать время пролеживания<br>
        and 2 - это сокращение времени, иначе просто пересчет<br>
        and 4 - имеет смысл, только если and 2 = 0. Брать даты для первых (с направления расчета), из позиции документа<br>
        and 8 - позволены прерывные интервалы<br>
 Результат: <br>
   True, если успешно<br>
#end
function DSQL_RecalcDatesEx(datetime : _dateTime;shiftNumber : word; bIsForward : boolean; wFlag : word) : boolean;

#doc
 Запись времени цикла во время пролеживания, для учета его в рассчете</brief> <br>
 bUseLinkPos - номер поля, из которого брать длительность<br>
 Результат: <br>
   True, если успешно<br>
#end
Function DSQL_WriteLag(wNumFld : word):boolean;
Function DSQL_UpdateSmPlanDates:boolean;
Function RebuildLinks(wType : word):boolean;
Procedure SetSettings(wNumF : word);
end;
VipInterface DopFuncRazuzlDSQL implements oDopFuncRazuzlDSQL1 #Licensed_Free;
#endif

