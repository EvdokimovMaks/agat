//------------------------------------------------------------------------------
//                                                      (c) корпорация Галактика
// Галактика 8.10
// Функции для работы с архивом
//------------------------------------------------------------------------------

#ifndef _ArchiveFuncs_VIH_INCLUDED_
#define _ArchiveFuncs_VIH_INCLUDED_

#component "C_COMMON"

const
  lNrecDoc      = 'NREC';
  lTidkDoc      = 'DocTitleCode';
  lDocDate      = 'DocDate';
  lDocNum       = 'DocNum';
  lDescrDoc     = 'CuratorDescr';
  lDesGrDoc     = 'CuratorDescrGroup';
  lOrgDoc       = 'AgentName';
  lOrgDocCode   = 'AgentCode';
  lDogovorDocCode = 'DogovorDocCode';
  lDocSumOffNDS = 'DocSumOffNDS';
  lDocSumOnNDS  = 'DocSumOnNDS';
  lCurrencyCode = 'CurrencyCode';
  lDateCreate   = 'CreateDate';
  LOrgDocNSI    = 'AgentCodeNSI'; 
  lPrincipalCode = 'PrincipalCode';
  lPrincipalName = 'PrincipalName';
  lUSStatusName = 'USStatusName';
  lUSOperSendPack = 'USOperSendPack';

  ftNastrComp    = 100;
  ftNastrString  = 101;
  ftNastrCalcSum = 102;
  ftNastrCalcPrincipal = 103;
  ftNastrCalcComplex = 104;

  TypeCheckRightDef = 0; // права по умолчанию
  TypeCheckRightTXO = 1; // права по ТХО

  TypeCheckRightDef_Message = 'Документ заблокирован по статусу из архива';
  TypeCheckRightTXO_Message = 'Проведение и отмена ТХО запрещены по статусу из архива';
end;
#declare AddFieldPrincipalIntegratorToBrowse(TidkGal, cSoprDoc)
  [PrincipalOnIntegrator] oArchiveFuncs.GetNamePrincipal(#TidkGal, #cSoprDoc) 'Принципал' ('Принципал в интеграторе',,) : [12], protect;
#end

#declare CalcPrincipalIntegrator(TiDkGal, cSoprDoc, Table)
  if (oArchiveFuncs.CalcPrincipal(#TiDkGal, #cSoprDoc, false))
    rereadrecord(tn#Table)
#end
// добавление поля архива в browse
#declare AddFieldArchiveToBrowse(TidkGal, cSoprDoc, sBarKod)
  [ImageOnArchive] oArchiveFuncs.GetImageState(#TidkGal, #cSoprDoc, #sBarKod) 'А' ('Состояние документа в архиве',,) : [2], image;
#end
// Поле для дополнительного брауза
#declare AddFieldPrincipalIntegratorToBrowseDop
  PrincipalOnIntegrator 'Принципал' ('Принципал в интеграторе',,) : [12], protect;
#end
// Поле для дополнительного брауза
#declare AddFieldArchiveToBrowseDop
  ImageOnArchive 'А' ('Состояние документа в архиве',,) : [2], image;
#end

// добавление поля архива в первый screen интерфейса
#declare AddFieldArchiveToScreen(TidkGal, cSoprDoc, sBarKod)
  [BarKodAndStateCaption] oArchiveFuncs.GetCaptionEditBox : skip;
  [BarKodAndState       ] oArchiveFuncs.GetBarKodAndState(#TidkGal, #cSoprDoc, #sBarKod) ('Связь документа с архивом и ее состояние', , sci1378Esc) : protect;
#end

// добавление поля архива во второй и последующие screen-ы интерфейса
#declare AddFieldArchiveToScreenMore(TidkGal, cSoprDoc, sBarKod)
  BarKodAndStateCaption : skip;
  BarKodAndState ('Связь документа с архивом и ее состояние', , sci1378Esc) : protect;
#end

// Поля для дополнительного скрина
#declare AddFieldArchiveToScreenDop
  BarKodAndStateCaption : skip;
  BarKodAndState  ('Связь документа с архивом и ее состояние', , sci1378Esc) : protect;
#end

// добавление поля архива в первый screen интерфейса
#declare AddFieldArchiveToScreen_(TidkGal, cSoprDoc, sBarKod, sStatLine)
  [BarKodAndState] oArchiveFuncs.GetBarKodAndState(#TidkGal, #cSoprDoc, #sBarKod) ('Связь документа с архивом и ее состояние', , #sStatLine) : protect;
#end

#declare AddFieldArchiveToScreenEB_(TidkGal, cSoprDoc, sBarKod, sStatLine)
  [BarKodAndState] oArchiveFuncs.GetBarKodAndState(#TidkGal, #cSoprDoc, #sBarKod) ('Связь документа с архивом и ее состояние', , #sStatLine) : protect, EditButton;
#end

// добавление поля архива во второй и последующие screen-ы интерфейса
#declare AddFieldArchiveToScreenMore_(sStatLine)
  BarKodAndState ('Связь документа с архивом и ее состояние', , #sStatLine) : protect;
#end

// добавление поля архива во второй и последующие screen-ы интерфейса
#declare AddFieldArchiveToScreenMoreEB_(sStatLine)
  BarKodAndState ('Связь документа с архивом и ее состояние', , #sStatLine) : protect, EditButton;
#end

// Поля для дополнительного скрина
#declare AddFieldArchiveToScreenDop_(sStatLine)
  BarKodAndState  ('Связь документа с архивом и ее состояние', , #sStatLine) : protect;
#end

// Поля для дополнительного скрина
#declare AddFieldArchiveToScreenDopEB_(sStatLine)
  BarKodAndState  ('Связь документа с архивом и ее состояние', , #sStatLine) : protect, EditButton;
#end

#declare AddFieldArchiveToScreen2
.@@@@@@@@@@@@@@@@@@@@@@@@  .@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#end

#declare HideFieldArchive(TiDkGal)
  // сперва запускаем интерфейс работы с архивом с помощью GetVipInterface чтобы проверить
  // нужно ли создавать новый документ.
  // для этого вызываем метод получения тек.код архива.
  // если он не пустой значит работает действие создания нового документа.
  // иначе обычная работа

  GetVipInterface(oArchiveFuncs);

  oArchiveFuncs.InitFuncData(0, false);

  m_sCurrentBarKod := oArchiveFuncs.GetBarKodForNewDoc;

  FreeVipInterface(oArchiveFuncs);

  // далее запускаем через LoadVipInterface
  LoadVipInterface(oArchiveFuncs);

  oArchiveFuncs.InitFuncData(0, true);

  ToggleFieldVisible(#BarKodAndStateCaption, oArchiveFuncs.IsExistArchive and oArchiveFuncs.GetExistTidkGal(#TiDkGal));
  ToggleFieldVisible(#ImageOnArchive       , oArchiveFuncs.IsExistArchive and oArchiveFuncs.GetExistTidkGal(#TiDkGal));
  SetFieldAndLabelVisible(#BarKodAndState  , oArchiveFuncs.IsExistArchive and oArchiveFuncs.GetExistTidkGal(#TiDkGal));

  m_lBarKodAndState := #BarKodAndState;

  if (m_sCurrentBarKod <> '')
    PutCommand(cmInsert);
#end

#declare HideFieldIntegrator(TiDkGal)
  ToggleFieldVisible(#PrincipalOnIntegrator       , oArchiveFuncs.IsExistIntegrator and oArchiveFuncs.IsShowPrincipalOnAgent(#TiDkGal));
#end

#declare HideFieldArchiveEx(TiDkGal,Cmd)
  // сперва запускаем интерфейс работы с архивом с помощью GetVipInterface чтобы проверить
  // нужно ли создавать новый документ.
  // для этого вызываем метод получения тек.код архива.
  // если он не пустой значит работает действие создания нового документа.
  // иначе обычная работа

  GetVipInterface(oArchiveFuncs);

  oArchiveFuncs.InitFuncData(0, false);

  m_sCurrentBarKod := oArchiveFuncs.GetBarKodForNewDoc;

  FreeVipInterface(oArchiveFuncs);

  // далее запускаем через LoadVipInterface
  LoadVipInterface(oArchiveFuncs);

  oArchiveFuncs.InitFuncData(0, true);

  ToggleFieldVisible(#BarKodAndStateCaption, oArchiveFuncs.IsExistArchive and oArchiveFuncs.GetExistTidkGal(#TiDkGal));
  ToggleFieldVisible(#ImageOnArchive       , oArchiveFuncs.IsExistArchive and oArchiveFuncs.GetExistTidkGal(#TiDkGal));
  SetFieldAndLabelVisible(#BarKodAndState  , oArchiveFuncs.IsExistArchive and oArchiveFuncs.GetExistTidkGal(#TiDkGal));

  m_lBarKodAndState := #BarKodAndState;

  if (m_sCurrentBarKod <> '')
    PutCommand(#Cmd);
#end

#declare HideImageFieldArchive(TiDkGal)
  // сперва запускаем интерфейс работы с архивом с помощью GetVipInterface чтобы проверить
  // нужно ли создавать новый документ.
  // для этого вызываем метод получения тек.код архива.
  // если он не пустой значит работает действие создания нового документа.
  // иначе обычная работа

  GetVipInterface(oArchiveFuncs);

  oArchiveFuncs.InitFuncData(0, false);
  	
  m_sCurrentBarKod := oArchiveFuncs.GetBarKodForNewDoc;

  FreeVipInterface(oArchiveFuncs);

  // далее запускаем через LoadVipInterface

  LoadVipInterface(oArchiveFuncs);

  oArchiveFuncs.InitFuncData(0, true);

  ToggleFieldVisible(#ImageOnArchive, oArchiveFuncs.IsExistArchive and oArchiveFuncs.GetExistTidkGal(#TiDkGal));

  if (m_sCurrentBarKod <> '')
    PutCommand(cmInsert)
#end

#declare HideBarKodFieldArchive(TiDkGal)
  // сперва запускаем интерфейс работы с архивом с помощью GetVipInterface чтобы проверить
  // нужно ли создавать новый документ.
  // для этого вызываем метод получения тек.код архива.
  // если он не пустой значит работает действие создания нового документа.
  // иначе обычная работа

  GetVipInterface(oArchiveFuncs);

  oArchiveFuncs.InitFuncData(0, false);

  m_sCurrentBarKod := oArchiveFuncs.GetBarKodForNewDoc;

  FreeVipInterface(oArchiveFuncs);

  // далее запускаем через LoadVipInterface

  LoadVipInterface(oArchiveFuncs);

  oArchiveFuncs.InitFuncData(0, true);

  ToggleFieldVisible(#BarKodAndStateCaption, oArchiveFuncs.IsExistArchive and oArchiveFuncs.GetExistTidkGal(#TiDkGal));
  SetFieldAndLabelVisible(#BarKodAndState  , oArchiveFuncs.IsExistArchive and oArchiveFuncs.GetExistTidkGal(#TiDkGal));

  m_lBarKodAndState := #BarKodAndState;

  if (m_sCurrentBarKod <> '')
    PutCommand(cmInsert);
#end

#declare ImgDblClickBarKodAndState(TidkGal, cSoprDoc, sBarKod, bOnlyView)
  #ImageOnArchive : // Состояние документа в архиве
    {
      if IsNew
        {
          Message('Документ не оформлен', Warning);
          Exit;
        }

      var i : longint; i := GetLimit(m_arObjArchiveLink) + 1;

      SetLimit(m_arObjArchiveLink, i);

      m_arObjArchiveLink[i] := NullRef;

      if (LoadVipRef(m_arObjArchiveLink[i], 'C_Common::ArchiveFuncs'))
        {
          m_arObjArchiveLink[i].InitFuncData(i, true);

          if (m_arObjArchiveLink[i].IsExistArchive)
            {
              var objArchiveLink : iArchiveFuncsExt2;

              objArchiveLink := m_arObjArchiveLink[i];

              BindEvent(RescanValueBarkod, objArchiveLink.RescanValueBarkod);
              BindEvent(ClearEventBarkod , objArchiveLink.ClearEventBarkod);
            }

          m_arObjArchiveLink[i].EditAchiveForm(#TidkGal, #cSoprDoc, #sBarKod, false, #bOnlyView);
        }
      exit;
    }
#end
// pick, а то мне его 4 раза добавлять бы пришлось (кому не надо не будет использовать)
#declare PickBarKodAndState(TidkGal, cSoprDoc, sBarKod, bOnlyView)
  #BarKodAndState:
    {
      Stop;

      if IsNew
        {
          Message('Документ не оформлен', Warning);
          Exit;
        }

      var i : longint; i := GetLimit(m_arObjArchiveLink) + 1;

      SetLimit(m_arObjArchiveLink, i);

      m_arObjArchiveLink[i] := NullRef;

      if (LoadVipRef(m_arObjArchiveLink[i], 'C_Common::ArchiveFuncs'))
        {
          m_arObjArchiveLink[i].InitFuncData(i, true);

          if (m_arObjArchiveLink[i].IsExistArchive)
            {
              var objArchiveLink : iArchiveFuncsExt2;

              objArchiveLink := m_arObjArchiveLink[i];

              BindEvent(RescanValueBarkod, objArchiveLink.RescanValueBarkod);
              BindEvent(ClearEventBarkod , objArchiveLink.ClearEventBarkod);
            }

          m_arObjArchiveLink[i].EditAchiveForm(#TidkGal, #cSoprDoc, #sBarKod, false, #bOnlyView);
        }
      exit;
    }
#end

#declare ToggleUnvisibleImageOnArchive
ToggleFieldVisible(#ImageOnArchive, FALSE)
#end

// Установить состояние удаления документа для штрихкода из архива документов
#declare SetStateDeleteDocOnArchive(TidkGal, cSoprDoc)
  oArchiveFuncs.InitFuncData(0, false);
  oArchiveFuncs.SetStateDeleteDoc(#TidkGal, #cSoprDoc);
#end

// Очистить локверсию  для штрихкода из архива документов
#declare ClearLockVersionOnArchive(TidkGal, cSoprDoc)
  oArchiveFuncs.InitFuncData(0, false);
  oArchiveFuncs.ClearVersionLock(#TidkGal, #cSoprDoc);
#end

#doc
  Функции для работы с архивом документов
#end
ObjInterface iArchiveFuncs;
  #doc
    Получение кода состояния документа в архиве документов
  #end
  function GetState(TiDkGal : word; cSoprDoc : comp; sBarKod : string = '') : word;
  #doc
    Установить версию блокирования документа
  #end
  procedure SetVersionLock(TiDkGal : word; cSoprDoc : comp);
  #doc
    Установить состояние удаления документа
  #end
  procedure SetStateDeleteDoc(TiDkGal : word; cSoprDoc : comp);
  #doc
    Получение названия bmp картинки состояния документа в архиве документов
  #end
  function GetImageState(TiDkGal : word; cSoprDoc : comp; sBarKod : string = '') : string;
  #doc
    Редактирование информации, связанной с архивом
  #end
  function EditAchiveForm(TiDkGal : word; cSoprDoc : comp; sBarKod : string; bIsModal : boolean; bOnlyView : boolean) : boolean;
  #doc
    Получение кода архива
  #end
  function GetBarKod(TiDkGal : word; cSoprDoc : comp; bCreateIfNotExist : boolean = false) : string;
  function GetBarKodBySoprDoc(cSoprHoz : comp) : string;
  function GetAbstractBarCode : string;
  #doc
    Получение кода архива и его состояние
  #end
  function GetBarKodAndState(TiDkGal : word; cSoprDoc : comp; sBarCode : string = '') : string;
  #doc
    Получение названия для статика для контрола
  #end
  function GetCaptionEditBox : string;
  #doc
    Установка кода архива для создания нового документа
  #end
  procedure SetBarCodeForNewDoc(sBarCode : string);
  #doc
    Получения тек. атрибутов указанного типа для создания атрибутов
  #end
  #doc
    Получение штрихкода, для которого создается документ
  #end
  function GetBarKodForNewDoc : string;
  #doc
    Установка связи штрихкода с документом после создания
  #end
  function  CreateLinkDocWithBarkod(sBarKod : string; cRec : comp; TiDkGal : word) : boolean;

  function  IsExistArttr           (sBarCode : string; sAttrName : string) : boolean;
  function  GetValueStringForNewDoc(sBarCode : string; sField    : string) : string;
  function  GetValueDateForNewDoc  (sBarCode : string; sField    : string) : date;
  function  GetValueDoubleForNewDoc(sBarCode : string; sField    : string) : double;
  function  GetValueCompForNewDoc  (sBarCode : string; sField    : string) : comp;
  procedure SetValueForAttr        (sBarCode : string; sAttr     : string; sValue : string);

  event procedure RescanValueBarkod(TiDkGal : word; cSoprDoc : comp);
  event procedure ClearEventBarkod(nIndex : longint);
end;

ObjInterface iArchiveFuncsExt2(iArchiveFuncs);
  #doc
    Работает ли галактика с архивом
  #end
  function IsExistArchive : boolean;

  procedure AddVipNameObj(sNameInterface : string);

  procedure InitFuncData(nIndex : longint; bLoadVipInterface : boolean);
  #doc
    Проверяет работает ли с архивом указанный тип документа
  #end
  function GetExistTidkGal(TiDkGal : word) : boolean;
end;

ObjInterface iArchiveFuncsExt3;
  #doc
    Очищать версию блокирования документа
  #end
  procedure ClearVersionLock(TiDkGal : word; cSoprDoc : comp);

  #doc
    Можно ли править документ.
  #end
  function CanEditDoc(TiDkGal : word; cSoprDoc : comp; wCheckRight : longint = TypeCheckRightDef) : boolean;
end;

ObjInterface iArchiveFuncsExt5;
  #doc
    Проверяет работает ли с архивом указанный тип документа
  #end
  function GetExistTidkGalEx(TiDkGal : word) : boolean;
end;

ObjInterface iIntegratorFuncs;
  #doc
    Получение названия принципала
  #end
  function GetNamePrincipal(TiDkGal : word; cSoprDoc : comp) : string;

  #doc
    Работает ли галактика с интегратором
  #end
  function IsExistIntegrator : boolean;

  #doc
    Показывать данные по Принципалу на Агенте
  #end
  function IsShowPrincipalOnAgent(TiDkGal : word) : boolean;

  #doc
    Функция расчета Принципала
  #end
  function CalcPrincipal(TiDkGal : word; cSoprDoc : comp; bShowMessage : boolean) : boolean;

  procedure AddVipNameObjForIntegrator(sNameInterface : string);
end;

ObjInterface iIntegratorFuncsEx(iIntegratorFuncs);
  #doc
    Установлен ли Принципал
  #end
  function IsSetPrincipal(TiDkGal : word; cSoprDoc : comp) : boolean;
end;

ObjInterface iIntegratorFuncsEx2(iIntegratorFuncsEx);
  #doc
    Установка состояния интеграции при изменении штрихкода
  #end
  function SetStateForChangeBarCode(wTiDkGal : word; cRec : comp) : longint;
  #doc
    Установка состояния интеграции при изменении статуса у штрихкода
  #end
  function SetStateForChangeStatusBarCode(wTiDkGal : word; cRec : comp) : longint;
end;

ObjInterface iIntegratorFuncsEx3;
  #doc
    Получение принципала, если он есть для документа
  #end
  function GetCodePrincipal(TiDkGal : word; cSoprDoc : comp) : comp;
end;

#doc
  Функции для работы с EDI контуром
#end
ObjInterface iEDIFuncs;
  #doc
    Работает ли галактика с EDI
  #end
  function IsExistEDI : boolean;
  #doc
    Разорвать связь сообщений с документом
  #end
  procedure RemoveEDILinkWithDoc(TiDkGal : word; cSoprDoc : comp);

  procedure AddVipNameObjForEDI(sNameInterface : string);
end;

ObjInterface iUZEDOFuncs;

  #doc
    Работает ли галактика с ЮЗЭДО
  #end                                  
  function IsExistUZEDO: boolean;

  procedure AddVipNameObjForUZEDO(sNameInterface : string);
end;

ObjInterface iUZEDOFuncsForInetgerator;
  function CreateDbfStructPiTask(FileDBF : longint): boolean;
  function InsertPiTaskToDbf(FileDBFPiTask : longint; wTiDK : word; cDoc : comp; hMarkPiTask : longInt) : boolean;
  function InserttmpPiTask(sDbfName : string) :boolean;
  function InsertPiTaskToDB(TiDkGal : word; cRec : comp) : boolean;
  function GetBarKod(TiDkGal : word; cSoprDoc : comp) : string;
  function GetRecordstmpPiTask : longint;
  function CheckPiTask(cSoprDoc : comp; wTidkGal : word; bSverka : boolean; var sError : string) : boolean;
end;

VipInterface ArchiveFuncs implements iArchiveFuncsExt2, iArchiveFuncsExt3, iArchiveFuncsExt5, iIntegratorFuncs, iEDIFuncs, iUZEDOFuncs  Licensed (FREE);
public:
  constructor Init;
end;

#doc
Точка расширения для получения интерфейса работы с архивом.<br>
</brief>
epArchiveGetVipName - вызывается для получения названия vip интерфейса работы с архивом.<br>
Возвращает всегда True.<br>
#end

ExtensionPoint epArchiveGetVipName(objArchiveFunc : iArchiveFuncsExt2);

#doc
Точка расширения для получения интерфейса работы с интегратором.<br>
</brief>
epIntegratorGetVipName - вызывается для получения названия vip интерфейса работы с интегратором.<br>
Возвращает всегда True.<br>
#end

ExtensionPoint epIntegratorGetVipName(objIntegratorFunc : iIntegratorFuncs);

ExtensionPoint epUZEDOGetVipName(objUZEDOFunc : iUZEDOFuncs);

#doc
Точка расширения для получения интерфейса работы с EDI контуром.<br>
</brief>
epEDIGetVipName - вызывается для получения названия vip интерфейса работы с EDI контуром.<br>
Возвращает всегда True.<br>
#end

ExtensionPoint epEDIGetVipName(objEDIFunc : iEDIFuncs);

#end
