//------------------------------------------------------------------------------
//                                                      (c) корпорация Галактика
// Галактика 8х10 - Управление капитальными вложениями и строительством
// Кэширование показателей плана
//------------------------------------------------------------------------------
#ifndef _CacheValues_vih_
#define _CacheValues_vih_

#include TValue.inc // Декларация типа TValue, описывающего значение показателя плана

#component "L_UksPlans"

Const
  // Режимы работы метода CheckAgregat
  cgAgregat_Calc = 0; // агрегат будет рассчитан по имеющимся в базе подчиненным значениям
  cgAgregat_Set  = 1; // значение агрегата передано в arValue.fValue
  cgAgregat_Inc  = 2; // значение агрегата нужно увеличить на заданное в arValue.fValue значение
End;

Table struct mtDetails
(
  TiDk: word,
  cDoc: comp,
  dDoc: date,
  fVal: double
)
With index
(
  mtDetails1 = TiDk + dDoc,
  mtDetails2 = TiDk + cDoc
);

#doc
Базовый объектный интерфейс механизмов хранения, вычисления и кэширования показателей плана.</brief>
Включает методы, реализация которых не зависит от версии хранилища (PlanValue или UksValues),
но необходима для работы конкретного хранилища.
#end
ObjInterface ICacheValuesBase; // Включен именно в этот заголовочный файл сугубо для удобства.

  #doc
  Способ вычисления резерва
  #end
  Property iReserv: integer read write;

  #doc
  Загрузить показатели проекта в память
  #end
  Function LoadProject(acProject: comp): boolean;

  #doc
  Изменилась иерархия плана, необходимо подгрузить её в память
  #end
  Procedure LoadHier(awMode: word; acRec: comp);

  #doc
  Сброс кэша
  #end
  Procedure Reset;

  #doc
  Являются ли значения показателей доступным только для чтения
  #end
  Function isReadOnly(arValue: TValue): boolean;

  #doc
  Причина, по которой значения показателей является доступным только для чтения
  #end
  Function sReadOnly(arValue: TValue): string;

  #doc
  Возвращает кэшированное значение заданного показателя плана
  #end
  Function GetValue(arValue: TValue): double;

  #doc
  Возвращает кэшированное значение заданного показателя плана (другой способ передачи параметров)
  #end
  Function GetValueP(_Per, _Rec: comp; _Mod, _Reg, _Tip, _Prc, _Nal, _Art: integer): double;

  #doc
  Возвращает не кэшированное значение заданного показателя плана
  #end
  Function GetNoCached(_Per, _Rec: comp; _Mod, _Reg, _Tip, _Prc, _Nal, _Art: integer): double;

  #doc
  Сохранить значение показателя плана
  #end
  Procedure SetValue(arValue: TValue);

  #doc
  Увеличить значение показателя плана (с коррекцией агрегатов)
  #end
  Procedure IncValue(arValue: TValue);

  #doc
  Увеличить значение показателя плана с сохранением детализации
  #end
  Procedure IncDetail(arValue: TValue; arDetail: TDetail);

  #doc
  Актуализировать агрегаты на уровне периода плана
  #end
  Procedure CountAgregat(_Project: comp; _Mod: integer);

  #doc
  Поиск документов, на основании которых сформировано значение фактического показателя.
  Возвращает пустую строку в случае успеха или описание причины неуспеха
  #end
  Function CollectDetails(arValue: TValue): string;

  #doc
  Вариант плана для режима сравнения планов
  #end
  Procedure SetCmpVar(acPlanVar: comp);


  #doc
  Значения показателей позиции плана в заданных разрезах<brief>
  Битовые маски определяют разрезы, для которых нужно получить значения. Например:<br>
  _PrcMask может принимать значения cgPrc_Basic (получить значения показателей в базисных ценах), <br>
  cgPrc_Current (получить значения показателей в текущих ценах), cgReg_All (получить значения показателей в базисных и текущих ценах).<br>
  Константы масок описаны в UksValue.inc (cgTip_xxx, cgPrc_xxx, cgNal_xxx).
  #end
  Function GetRecValues(_Per, _Rec: comp; _Mod, _Reg, _TipMask, _PrcMask, _NalMask, _Art: integer;
                        var _Values: TDistr): boolean;

  #doc
  Удаление показателей заданной позиции плана в указанных разрезах<brief>
  Битовые маски определяют разрезы, в которых нужно выполнить удаление. Например:<br>
  _RegMask может принимать значения cgReg_Plan (удалять только в регистре "План"), <br>
  cgReg_Fact (удалять только в регистре "Факт"), cgReg_All (удалять в регистрах "План" и "Факт").<br>
  Константы масок описаны в UksValue.inc (cgReg_xxx, cgTip_xxx, cgPrc_xxx, cgNal_xxx).
  #end
  Procedure ClearRecValues(_Per, _Rec: comp; _Mod, _RegMask, _TipMask, _PrcMask, _NalMask, _Art: integer; _ClearPJ: boolean = false);

  #doc
  Пакетное распределение показателей по подпериодам задачи<brief>
  В структуре передается группа значений и битовые маски, определяющие разрезы, в которых нужно выполнить распределение.<br>
  Например _Distr.iFltReg может принимать значения cgReg_Plan (распределять только в регистре "План"),
  cgReg_Fact (распределять только в регистре "Факт"), cgReg_All (распределять в регистрах "План" и "Факт").<br>
  Константы масок описаны в UksValue.inc (cgReg_xxx, cgTip_xxx, cgPrc_xxx, cgNal_xxx).
  Поскольку в массиве значений _Distr.fSum[] не предусмотрено хранение показателей для двух различных регистров учета, предполагается, 
  что при _Distr.iFltReg = cgReg_All в регистр "План" и регистр "Факт" будут распределены одинаковые значения.
  #end
  Procedure DistrRecValues(_Distr: TDistr);
  // Используется:
  // 1) Перераспределение при редактировании срока работы                All                  cgReg_Plan, cgTip_All,  cgPrc_All,  cgNal_All
  // 2) Формирование плана по заявкам/договорам                          Sum, Nal, NDS        cgReg_Plan, cgTip_Use,  cgPrc_All,  cgNal_All
  // 3) Формирование плана по сметам                                     Kol, Prc, Sum        cgReg_Plan, cgTip_TUNE, cgPrc_TUNE, cgNal_NoNal
  // 4) Добавление сумм заявки в план строительства                      SumB, SumC           cgReg_Plan, cgTip_All,  cgPrc_All,  cgNal_NoNal



  #doc
  Расчет показателей спецификации плана по плану работ
  #end
  Procedure CalcByPlanJob(_SpPlan: comp; _Reg, _Tip, _Prc: integer);

  #doc
  Есть ли сохраненные данные в указанном периоде планирования и регистре учета
  #end
  Function HaveDataInPer(_Per, _Rec: comp; _Mod, _Reg: integer): boolean;

end;



#doc
Свойства и методы, которые можно реализовать в диспетчере ("стрелочнике") CacheValues
и не нужно реализовывать в конкретном хранилище CacheValues_PV или CacheValues_UV
#end
ObjInterface ICacheValuesIndependet;

  #doc
  Используется ли новый способ хранения показателей
  (false - старый способ на базе по PlanValue, true - новый на базе UksValues)
  #end
  Property bNewMetod: boolean read;

  #doc
  Способ распределения по периодам добавляемого в план показателя
  #end
  Property wDistrPer: word read;

  #doc
  Какие типы показателей распределять при добавлении
  #end
  Property wDistrTip: word read;

  #doc
  В какие режимы цен распределять значение добавляемого в план показателя
  #end
  Property wDistrPrc: word read;

  #doc
  Инициализация режима переноса показателей в план работ
  #end
  Function GetDistrMode(awTable: word): boolean;

end;



#doc
Кэширование показателей плана
#end
ObjInterface ICacheValues(ICacheValuesBase); // Методы, реализация которых зависит от структуры хранилища (надо перекрывать в реализациях хранилищ)

  #doc
  Пересчет показателей из одного режима цен в другой
  #end
  Procedure RecalcByPrice(acSpPlan: comp; aiReg: integer; afCoef: double; isPriceBasic: boolean);

  #doc
  Объединение планов
  #end
  Procedure JoinValues(aiMod: integer; cRecFrom, cRecTo: comp);

  #doc
  Проверка наличия записи в хранилище
  #end
  Function IsValidPV(acSpPlan: comp; aiMod, aiReg, aiPrc: integer): boolean;

  #doc
  Перенос показателей с одного периода на другой
  #end
  Procedure Move(_Direct, _Mod: word; _Src, _Dst, _Rec: comp; _Koef: double);


End;

VipInterface CacheValues
  implements ICacheValuesIndependet, ICacheValues
  licensed(free);

#endif // _CacheValues_vih_
