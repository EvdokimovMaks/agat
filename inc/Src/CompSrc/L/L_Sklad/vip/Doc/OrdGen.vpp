//********************************************************************************
//                                                        (c) корпорация Галактика
// Галактика 7.11 - логистика - склад
// Общие процедуры обработки складских ордеров
//********************************************************************************

#include OnePrice.vpp // Установка единой цены для партии при редактировании складского ордера
#include PrecSumm.vpp // установки точности вывода сумм

//******************************************************************************

#include MSview.var
#include SDfuns.var
var oVipMtrCount: VipMtrCount;
var dSrPrice, dvPrice, dKol : double;
var _cVal : comp;
//********************************************************************************
Create view loCheckRashOrd
var
  _cSklOrder
, cNewSopr_
, SpOrder_nRec
, SpOrdercMC
, _cMC
, _cSaldTune
, _cObj
, _cKau1
, _cKau2
, _cKau3
, _cNotes
            : comp;
from
  SklOrder
, SklOrder SklOrderRash
, SklOrder SklOrder3
, SpOrder
, SpOrder  SpOrderRash
, SpOrder  SpOrder2
, KatSopr
, KatSopr  KatSopr1
, KatSopr  KatSoprCheck
, KatMC
, MtrAct
, SpMtrAct
, SpecMtr
, KatMC    KatMC_MA
, KatMC    KatMCAr
, SpBox
, SpBox    SpBox1
, SpBox    SpBoxRash
, SaldoBox
, SaldoBox SaldoBox1
, SoprOrdb
, SaldoObj
, PickRep
, SpSopr
, KatNotes

#ifdef _ZPRIHORD_VIP_
, SpDocSmeta
#else
#ifdef _RASHORD_VIP_
, SpDocSmeta
#end
#end

where
((
       _cSklOrder    ==  SklOrder.nRec
  AND  SklOrder.nRec ==  SpOrder.cSklOrder
  AND  SpOrder.SP    ==  SpOrderRash.SP
  AND  word(1)       ==  SpOrderRash.vidOrder
  AND  SpOrder.cMC   ==  SpOrderRash.cMC
  AND  SpOrder.dOrd  <<= SpOrderRash.dOrd
  AND  (SpOrder.nRec <>  SpOrderRash.nRec)
  AND  SpOrderRash.cMC == KatMC.nRec (noIndex)

  AND  coSpOrder         == SpecMtr.coTable
  AND  SpOrder.nRec      == SpecMtr.cSpec
  AND  word(613)         == MtrAct.VidSopr
  AND  _cSaldTune        == MtrAct.cSaldSrc
  AND  _cObj             == MtrAct.cObjSrc
  AND  _cKau1            == MtrAct.cKauSrc[1]
  AND  _cKau2            == MtrAct.cKauSrc[2]
  AND  _cKau3            == MtrAct.cKauSrc[3]
  AND  SpOrder.dOrd     <<= MtrAct.dSopr
  AND  MtrAct.nRec       == SpMtrAct.cSopr
  AND  SpOrder.cMC       == SpMtrAct.cMC
  AND  SpOrder.ccPodr    == SpMtrAct.cPodr
  AND  SpOrder.ccMOL     == SpMtrAct.cMOL
  AND  SpOrder.cParty    == SpMtrAct.cParty
  AND  SpOrder.cMC       == KatMC_MA.nRec
  AND  SpOrder.nRec      == SpBox.cSpOrder
  AND  SpBox.cSaldoBox   == SaldoBox.nRec
  AND  SpOrder.ccPodr    == SaldoBox1.cPodr
  AND  SpOrder.cMC       == SaldoBox1.cMC
  AND  SpOrder.cParty    == SaldoBox1.cParty
  AND  SaldoBox.cBox     == SaldoBox1.cBox
  AND  SaldoBox1.nRec    == SpBox1.cSaldoBox
  AND  SpOrder.dOrd     <<= SpBox1.dOpr
  AND  SpBox1.cSopr      == KatSopr1.nRec
  AND  word(623)         == KatSopr1.VidSopr (noIndex)
  AND  word(1)           == KatSopr1.Status  (noIndex)
  AND  SpOrderRash.nRec  == SpBoxRash.cSpOrder

))

bounds cPodr   SpOrder.ccPodr == SpOrderRash.ccPodr (noIndex)
bounds cMOL    SpOrder.ccMOL  == SpOrderRash.ccMOL  (noIndex)
bounds cParty  SpOrder.cParty == SpOrderRash.cParty (noIndex)
;

Form frm1wed('errwed.OUT', 'ERRR') with novisual;
//********************************************************************************

Function Check_wasSpis(_cSklOrder: comp; var wModeSpis : word): boolean;
{
  Result := False;

  wModeSpis := 0;

  loCheckRashOrd._cSklOrder := _cSklOrder;

  if ( loCheckRashOrd.GetFirst SklOrder <> tsOk )
    Exit;

  if ( word(0) <> loCheckRashOrd.SklOrder.vidOrder )//проверять приходные ордера
    Exit;

  if ( loCheckRashOrd.GetFirst SpOrder where ((_cSklOrder == SpOrder.cSklOrder)) <> tsOk )
    Exit;

  var wRazrez: word;

  if ( loCheckRashOrd.SpOrder.SP = 0 )
    {
      wRazrez := wGetTune('Oper.Razrez');
      if ( wRazrez = 1 )//старое представление
        {
          wRazrez := 2+4+8;
          SetTune('Oper.Razrez', wRazrez);
        }
    }
  else//производство
    case wGetTune('Manuf.MetodSpis') of
    //---------------------------------
      0: wRazrez := 2;
    //---------------------------------
      1: wRazrez := 2+4;
    //---------------------------------
      2: wRazrez := 2+8;
    //---------------------------------
      3: wRazrez := 2+4+8;
    //---------------------------------
    else wRazrez := 2;
    //---------------------------------
    end; //case

//------------------------------------------------------------------------------
  if ( wRazrez AND 2 ) <> 0
    loCheckRashOrd.AddBounds(loCheckRashOrd.tbcPodr);

  if ( wRazrez AND 4 ) <> 0
    loCheckRashOrd.AddBounds(loCheckRashOrd.tbcMOL);

  if ( wRazrez AND 8 ) <> 0
    loCheckRashOrd.AddBounds(loCheckRashOrd.tbcParty);
//------------------------------------------------------------------------------

  loCheckRashOrd._LOOP SpOrder where ((_cSklOrder == SpOrder.cSklOrder))
  {
    loCheckRashOrd._LOOP SpOrderRash
    {
      // Модификация/создание приходных ордеров при наличии после них расходных - НЕТ
      if (wGetTune('Oper.Sklad.EditPrihOrdWithRash') < 2)
        Result := True
      else
      {
        if (loCheckRashOrd.SpOrderRash.dOrd <> loCheckRashOrd.SpOrder.dOrd)
          Result := True
        else
        {
          if (loCheckRashOrd.SpOrderRash.Atl_LastDate > loCheckRashOrd.SpOrder.Atl_LastDate)
            Result := True;
          else
            if (loCheckRashOrd.SpOrderRash.Atl_LastDate = loCheckRashOrd.SpOrder.Atl_LastDate)
              if (loCheckRashOrd.SpOrderRash.Atl_LastTime > loCheckRashOrd.SpOrder.Atl_LastTime)
                Result := True;
        }

        if (Result) and (wGetTune('Oper.Sklad.EditPrihOrdWithRash') = 3)
        {
          InitMCInfo(loCheckRashOrd.SpOrderRash.dOrd);
          SkladProizv(loCheckRashOrd.SpOrderRash.SP);
          StepMCInfo(loCheckRashOrd.SpOrderRash.cMC
              , loCheckRashOrd.SpOrderRash.cVal
              , if (loCheckRashOrd.SpOrderRash.ccPodr  = 0, comp(-1), loCheckRashOrd.SpOrderRash.ccPodr)
              , if (loCheckRashOrd.SpOrderRash.ccMOL   = 0, comp(-1), loCheckRashOrd.SpOrderRash.ccMOL)
              , if (loCheckRashOrd.SpOrderRash.cParty = 0, comp(-1), loCheckRashOrd.SpOrderRash.cParty) );

          if (CountMC >= loCheckRashOrd.SpOrder.Kol)
            Result := False;

          DoneMcInfo;
        }
      }

      if (Result)
      {
        if ((wModeSpis and 1) = 0)
          wModeSpis += 1;
        Break;
      }
    }

    if ( loCheckRashOrd.GetFirst SpecMTR = tsOk )
    {
      loCheckRashOrd._cSaldTune := loCheckRashOrd.SpecMtr.cSaldTune;
      loCheckRashOrd._cObj      := loCheckRashOrd.SpecMtr.cObj;
      loCheckRashOrd._cKau1     := loCheckRashOrd.SpecMtr.cKau[1];
      loCheckRashOrd._cKau2     := loCheckRashOrd.SpecMtr.cKau[2];
      loCheckRashOrd._cKau3     := loCheckRashOrd.SpecMtr.cKau[3];
    }
    else
    {
      loCheckRashOrd._cSaldTune := 0;
      loCheckRashOrd._cObj      := 0;
      loCheckRashOrd._cKau1     := 0;
      loCheckRashOrd._cKau2     := 0;
      loCheckRashOrd._cKau3     := 0;
    }

    loCheckRashOrd._LOOP MtrAct
    {
      if (loCheckRashOrd.MtrAct.Status = 0)
        Continue;

      if (boGetTune('Oper.CelUch.VidUch'))
        if (((loCheckRashOrd.MtrAct.SoprHoz and 0FF00h) / 00100h) <> loCheckRashOrd.SpOrder.SP)
          Continue;

      loCheckRashOrd._LOOP SpMtrAct
        if ((wModeSpis and 2) = 0)
          wModeSpis += 2;

      if ((wModeSpis and 2) <> 0)
        Break;
    }
  }

  if ((wModeSpis and 2) <> 0)
    Result := True;

  var bIsSpis, bFirst : boolean;

  if Result
    loCheckRashOrd._LOOP SpOrder where ((_cSklOrder == SpOrder.cSklOrder))
    {
      bFirst := True;
      if loCheckRashOrd.GetFirst SpOrderRash = TsOk
        {
          bIsSpis := False;

          loCheckRashOrd._LOOP SpOrderRash
          {
            if (wGetTune('Oper.Sklad.EditPrihOrdWithRash') >= 2)
            {
              if (loCheckRashOrd.SpOrderRash.dOrd = loCheckRashOrd.SpOrder.dOrd)
              {
                if (loCheckRashOrd.SpOrderRash.Atl_LastDate > loCheckRashOrd.SpOrder.Atl_LastDate)
                  bIsSpis := True;
                else
                  if (loCheckRashOrd.SpOrderRash.Atl_LastDate = loCheckRashOrd.SpOrder.Atl_LastDate)
                    and (loCheckRashOrd.SpOrderRash.Atl_LastTime > loCheckRashOrd.SpOrder.Atl_LastTime)
                    bIsSpis := True;
              }
              else
                bIsSpis := True;
            }
            else
              bIsSpis := True;

            if (bIsSpis)
            {
              if (bFirst)
              {
                frm1wed.write('По МЦ: '+ '  Б' + loCheckRashOrd.KatMC.Name + '  Б');
                frm1wed.write('Проводилось списания по следующим расходным ордерам:');
                bFirst := False;
              }

              loCheckRashOrd.GetFirst SklOrderRash where ((SpOrderRash.cSklOrder == SklOrderRash.nRec));
              frm1wed.write(' ИДата: ' + DateToStr(loCheckRashOrd.SKlOrderRash.DOrd, 'DD/MM/YYYY') +
               ' Номер: ' +  loCheckRashOrd.SKlOrderRash.NOrder + ' Количество: ' +
               DoubleToStr(loCheckRashOrd.SpOrderRash.kol, '\3p[|-]36`666`666`666`666.888') + ' Цена в НДЕ: ' +
               DoubleToStr(loCheckRashOrd.SpOrderRash.srprice, '\2p[|-]36`666`666`666`666.88') + '  И')
            }
          }

          frm1wed.write('');
        }

      if ((wModeSpis and 2) <> 0)
      {
        var lKolSpMtrAct: longint;
        lKolSpMtrAct := 0;

        loCheckRashOrd._LOOP MtrAct
        {
          if (loCheckRashOrd.MtrAct.Status = word(0))
            Continue;

          if (boGetTune('Oper.CelUch.VidUch'))
            if (((loCheckRashOrd.MtrAct.SoprHoz and 0FF00h) / 00100h) <> loCheckRashOrd.SpOrder.SP)
              Continue;

          if loCheckRashOrd.GetFirst SpMtrAct = tsOk
          {
            if (++lKolSpMtrAct = 1)
            {
              frm1wed.write('По МЦ: '+ '  Б' + loCheckRashOrd.KatMC_MA.Name + '  Б');
              frm1wed.write('Были сформированы акты изменения целевого назначения:');
            }

            loCheckRashOrd._LOOP SpMtrAct
            {
              frm1wed.write(' ИДата: ' + DateToStr(loCheckRashOrd.MtrAct.DSopr, 'DD/MM/YYYY') +
                            ' Номер: ' +  loCheckRashOrd.MtrAct.NSopr + ' Количество: ' +
                            DoubleToStr(loCheckRashOrd.SpMtrAct.kol, '\3p[|-]36`666`666`666`666.888') + ' Цена в НДЕ: ' +
                            DoubleToStr(loCheckRashOrd.SpMtrAct.Price, '\2p[|-]36`666`666`666`666.88') + '  И')
            }
          }
        }

        frm1wed.write('');
      }
    }

//------------------------------------------------------------------------------
  if loCheckRashOrd.BoundActive(loCheckRashOrd.tbcPodr)
    loCheckRashOrd.SubBounds(loCheckRashOrd.tbcPodr);

  if loCheckRashOrd.BoundActive(loCheckRashOrd.tbcMOL)
    loCheckRashOrd.SubBounds(loCheckRashOrd.tbcMOL);

  if loCheckRashOrd.BoundActive(loCheckRashOrd.tbcParty)
    loCheckRashOrd.SubBounds(loCheckRashOrd.tbcParty);
//------------------------------------------------------------------------------
}

//******************************************************************************
// процедуры events работы с штрихкодом
procedure RescanValueBarkod(TiDkGal : word; cSoprDoc : comp);
{
  if (SklOrder.nRec = cSoprDoc)
    ReReadRecord(#SklOrder);
}

procedure ClearEventBarkod(nIndex : longint);
{
  var i : longint;
  i := GetLimit(m_arObjArchiveLink);
  if (i < nIndex) exit;

  if (m_arObjArchiveLink[nIndex].IsExistArchive)
  {
     if (m_arObjArchiveLink[nIndex] = NullRef) exit;
     var objArchiveLink : iArchiveFuncsExt2;
     objArchiveLink := m_arObjArchiveLink[nIndex];
     UnBindEvent(RescanValueBarkod, objArchiveLink.RescanValueBarkod);
     UnBindEvent(ClearEventBarkod, objArchiveLink.ClearEventBarkod);
     objArchiveLink := NullRef;
  }
}

procedure DeleteRefBarkod;
{
  var i : longint;
  for (i := 1; i <= GetLimit(m_arObjArchiveLink); i++)
    FreeVipInterface(m_arObjArchiveLink[i]);
  SetLimit(m_arObjArchiveLink, 0);
}
//********************************************************************************
Function ExistsAnyOborotSklOrder(cSklOrder: comp): boolean;
{
  Result := False;
  if GetFirst SoprHoz where (( cSklOrder     == SoprHoz.cSoprDoc AND
                               SoprHozTipDoc == SoprHoz.TipDoc )) = tsOk
    Result := oSHmanager.HaveBuhOborot(SoprHoz.nRec, 0, 0) OR
              oSHmanager.HaveFpOborot (SoprHoz.nRec, 0, 0);
}
//********************************************************************************
Function ExistsAnyOborotSklOrderDoc(cKatSopr : comp): boolean;
{
  Result := False;
  if ( GetFirst KatSopr where ((cKatSopr  ==  KatSopr.Nrec))= tsOk )
    if GetFirst SoprHoz1 where (( KatSopr.VidSopr == SoprHoz1.TipDoc AND
                                  KatSopr.NRec    == SoprHoz1.cSoprDoc )) = tsOk
      Result := oSHmanager.HaveBuhOborot(SoprHoz1.nRec, 0, 0) OR
                oSHmanager.HaveFpOborot (SoprHoz1.nRec, 0, 0);
}

//********************************************************************************
Function CanEditOrderWithRash(bShowAskMsg: boolean): boolean;
var
  wModeSpis : word;
  sMode_    : byte;
{
  Result := True;

  if boGetTune('Sklad.BlockModOrd')
  {
    if BS.IsBranchSemaphoreSet(GetCurrentBranch, 'RecalcSp', sMode_)
    {
      Result := False;
      message('В данный момент происходит пересчет цен в расходных ордерах пользователем: '#13 +
                oModifOrds.CurDescrRead(600, GetCurrentBranch, 'RecalcSp'));
      Exit;
    }

    if BS.IsBranchSemaphoreSet(GetCurrentBranch, 'CountSaldo', sMode_)
    {
      var boCountSaldo : boolean;
      boCountSaldo := True;

      if RecordExists PickRep where (('CountSaldo' == PickRep.OwnName and
                                      500          == PickRep.wList)) = tsOK
      {
        boCountSaldo := False;
        PushPos(#SpOrder);
        _LOOP SpOrder
          if GetFirst PickRep where (('CountSaldo' == PickRep.OwnName and
                                      500          == PickRep.wList   and
                                      SpOrder.cMC  == PickRep.cRec)) = tsOk
          {
            boCountSaldo := True;
            Break;
          }

        PopPos(#SpOrder);
      }

      if (boCountSaldo)
      {
        Result := False;
        message('В данный момент происходит пересчет сальдовых/текущих остатков пользователем: '#13 +
                   oModifOrds.CurDescrRead(601, GetCurrentBranch, 'CountSaldo'));
        Exit;
      }
    }

    if BS.IsBranchSemaphoreSet(GetCurrentBranch, 'CalcRes', sMode_)
    {
      Result := False;
      message('В данный момент запущен пересчет резервов пользователем: '#13 +
             oModifOrds.CurDescrRead(603, GetCurrentBranch, 'CalcRes'));
      Exit;
    }
  }

  if (not oModifOrds.CheckBlockPodrInventar(0, SklOrder.cPodr, 0, True, True, True))
  {
    Result := False;
    Exit;
  }

  if (wGetTune('Sklad.ModHaveProvod') = 0)
    if (ExistsAnyOborotSklOrder(SklOrder.nRec))
    {
      Result := False;
      ShowTune('Запрещена модификация ордеров при наличии проводок!', 'Sklad.ModHaveProvod');
      Exit;
    }

  if ((wGetTune('Sklad.ModHaveProvodDoc') = 0) and (ExistsAnyOborotSklOrderDoc(SklOrder.cSopr)))
    {
      Result := False;
      ShowTune('Запрещена модификация ордеров при наличии проводок по документу!', 'Sklad.ModHaveProvodDoc');
      Exit;
    }

  if not Check_wasSpis(SklOrder.nRec, wModeSpis)
  {
    if ( wGetTune('Oper.Box.ModOrdAftPer') <> 0 )
      if ( oCheckSpisBox.Check_wasSpisBox(SklOrder.nRec) )
      {
        Result := False;

        ShowTune( 'Запрещена модификация приходных ордеров при наличии перемещений/списаний из ячеек хранения'
                , 'Oper.Box.ModOrdAftPer');
        Exit;
      }
  }
  else
  {
    Result := False;

    if ((wModeSpis and 1) <> 0)
      if ( wGetTune('Oper.Sklad.EditPrihOrdWithRash') <> 0 )
      {
        ShowTune( 'Запрещена модификация приходных ордеров при наличии после них расходных!'
                , 'Oper.Sklad.EditPrihOrdWithRash');
        frm1wed.ShowFile('Протокол расходных документов по приходному ордеру');
        Exit;
      }

    if ( wGetTune('Oper.Box.ModOrdAftPer') <> 0 )
      if ( oCheckSpisBox.Check_wasSpisBox(SklOrder.nRec) )
      {
        ShowTune( 'Запрещена модификация приходных ордеров при наличии перемещений из ячеек хранения!'
                , 'Oper.Box.ModOrdAftPer');
        Exit;
      }

    if ((wModeSpis and 2) <> 0)
      if (wGetTune('Oper.Sklad.EditPrihOrdWithAktCU') = 1)
      {
        ShowTune( 'Запрещена модификация приходных ордеров при наличии Актов изменения целевого назначения запасов МТР!'
                , 'Oper.Sklad.EditPrihOrdWithAktCU');
        frm1wed.ShowFile('Протокол Актов изменения целевого назначения запасов МТР');

        Exit;
      }

    if ( bShowAskMsg )
      if CurField <> #sumNalUch
      {
        case wModeSpis of
          1: Result :=
                 Message('По разрезу оприходования ордера (' + f_sNumDate(SklOrder.nOrder, SklOrder.dOrd) +
                         ') уже были проведены списания.'#13 +
                         ' При изменении данного ордера возможны неверные цены списания в расходных ордерах.'#13#13 +
                         + 'Продолжить?', YesNo+Confirmation+mfSwapButtons) = cmYes;

          2: Result :=
                 Message('По разрезу оприходования ордера (' + f_sNumDate(SklOrder.nOrder, SklOrder.dOrd) +
                         ') уже были сформированы Акты изменения целевого назначения запасов МТР.'#13 +
                         'При изменении данного ордера возможны некорректные остатки запасов МТР в разрезе целевого учета.'#13#13 +
                         + 'Продолжить?', YesNo+Confirmation+mfSwapButtons) = cmYes;

          3:
          {
            Result :=
                Message('По разрезу оприходования ордера (' + f_sNumDate(SklOrder.nOrder, SklOrder.dOrd) +
                        ') уже были проведены списания.'#13 +
                        ' При изменении данного ордера возможны неверные цены списания в расходных ордерах.'#13#13 +
                        + 'Продолжить?', YesNo+Confirmation+mfSwapButtons) = cmYes;

            if (not Result)
            {
              frm1wed.ShowFile('Протокол списаний по приходному ордеру');
              Exit;
            }
            else
            {
              Result :=
                   Message('По разрезу оприходования ордера (' + f_sNumDate(SklOrder.nOrder, SklOrder.dOrd) +
                           ') уже были сформированы Акты изменения целевого назначения запасов МТР.'#13 +
                           'При изменении данного ордера возможны некорректные остатки запасов МТР в разрезе целевого учета.'#13#13 +
                         + 'Продолжить?', YesNo+Confirmation+mfSwapButtons) = cmYes;
            }
          }
        end;
      }

    if (not Result)
      frm1wed.ShowFile('Протокол списаний по приходному ордеру')
    else
      frm1wed.AbortForm;
  }
}

//********************************************************************************

Function GetClosedPeriodDate: Date;
{
  if ( wGetTune('MCUsl.ModOrder') <> 2 )
    Result := dGetTune('TekMonth');
  else
    Result := Add_Day(dGetTune('Oper.DateClosePeriod'), 1);
}

//********************************************************************************
// Процедура поиска рассчитанных остатков "задним числом" по МЦ-ям SklOrder

Function IsOstPrPer(In_Date: Date; In_Msg: string): boolean;
{
  Result := False;

  if ( NOT oModifOrds.IsOstOnMSPrPer(True, SkPr, 0, SklOrder.cPodr, In_Date) )
    Exit;

  Result := True;

  if ( In_Msg <> '' )
    Message(In_Msg, Information);
}

//********************************************************************************
//Текущий склад
//
Function getCurPodr: comp;
{
  Result := coGetTune('User.cCurSklad');
}

//********************************************************************************
// Автоматический выбор МОЛ в документах
//
Function isAvtoMol: boolean;
{
  Result := boGetTune('Pick.AvtoMol');
}

//********************************************************************************
// True если методика списания LIFO или FIFO
Function IsLifoFifo: boolean;
{
  Result := ( oMSview.GetMethodSpisPodr(SklOrder.cPodr)<>0 );
}

//********************************************************************************
// True если методика списания LIFO или FIFO по НУ
Function IsLifoFifoNU: boolean;
{
  Result := ((wGetTune('OPER.NALUCH.MSRP') <> 2) OR (wGetTune('OPER.NALUCH.MSSN') <> 2));
}

//********************************************************************************
// True если методика списания средние цены или ордер производственный
Function prAvePrice: boolean;
{
  Result := ((oMSview.GetMethodSpisPodr(SklOrder.cPodr) = 0)
    AND ((boGetTune('Oper.NalUch')) and (wGetTune('Oper.NalUch.MSRP') = 2) and (wGetTune('Oper.NalUch.MSSN') = 2))
    OR  (not boGetTune('Oper.NalUch'))
    ) OR (SklOrder.SP = 1);
}

//********************************************************************************
//Базовая валюта
Function coBaseCurrency: comp;
{
  Result := coGetTune('BaseCurrency');
}

//********************************************************************************
// Дескриптор
Function getUserDescr: string;
{
  Result := sGetTune('User.Descr');
}

//********************************************************************************
// Группа дескрипторов
Function getUserDesGr: string;
{
  Result := sGetTune('User.DesGr');
}

//********************************************************************************
// Разрешенная группа подразделений
Function getGrPodr: comp;
{
  Result := coGetTune('Pick.cGrPodr');
}

//********************************************************************************
// Допустимость редактирования складских ордеров "задним числом"
Function canEditBackDate: boolean;
{
  if (SklOrder.Sp = cgVidUchO_UKS)
    if (wGetTune('UKS.Doc.ModOrder') = 0)
    {
      Result := True;
      Exit;
    }

  Result := (wGetTune('McUsl.ModOrder') = 0 );
}

//********************************************************************************

Function Check_NoEditOrders: boolean;
{
  Result := NOT boGetTune('Doc.ModOrder');
}

//********************************************************************************

Function Check_NoEditDescr: boolean;
{// сделано т.к. при не валидной таблице для всего выражения было бы False
  if ( NOT IsValid(#SklOrder) )
    {
      Result := False;
      Exit;
    }

  Result :=
       (
         (
           ( SklOrder.Descr <> DscName )
           AND
           ( (DscVisible = dcOwnOnly) OR (DscVisible = dcGrpRead) OR (DscVisible = dcOwnModifAllRead) )
         )
         or
         (
           ( SklOrder.DesGr <> DscGroup)
           AND
           ( ( DscVisible = dcGrpModif ) OR ( DscVisible = dcGrpModifAllRead ) )
         )
       )
}

//******************************************************************************

Function fCloseBuhPer(cSklOrder: comp; VidOrderSkl: word ; SpSkl: word; NeedMsg : boolean): boolean;
var tipDoc_ : word;
{
  Result := False;

  tipDoc_ := GetSoprHozTipDoc(SPSkl, vidOrderSkl);

  if GetFirst SoprHoz where (( tipDoc_   == SoprHoz.TipDoc
                          AND  cSklOrder == SoprHoz.cSoprDoc )) = tsOk
    if NOT iCheckPer.CheckCloseBuhPeriodForSoprHoz(SoprHoz.DatOb, SoprHoz.nRec, cCanModiSoprHoz, SoprHoz.DatOb)
      // Модификации данных после закрытия периода
      case wGetTune('Fin.User.ModAfterClose') of
        2: // запрещать
          {
            if (NeedMsg)
              Message(''#3'По хозяйственной операции имеются обороты попадающие в закрытый'#10#13 +
                      ''#3'отчетный период. Корректировка невозможна!');
            EXIT;
          }
        1: // с подтверждением
          {
            if (not NeedMsg)
              EXIT
            else
              if (message('Хозяйственная операция находится в закрытом периоде.'#10#13 +
                          'Продолжить редактирование?', YesNo + Confirmation + mfSwapButtons) <> cmYes)
                EXIT
              else
              {
                Result := True;
                EXIT;
              }
          }
        end;

  Result := True;
}

//********************************************************************************

Function F_ProtRec: boolean;
{
  Result := (Check_NoEditOrders OR Check_NoEditDescr);
}

//********************************************************************************
//"Запрет редактирования складских ордеров задним числом"
Function Check_BackDate: boolean;
{
  Result := False;

  if ( canEditBackDate ) //не установлен
    Exit;

  Result := True;

  if ( CurTable = #SklOrder )
    if ( IsOstPrPer(SklOrder.dOrd, ''))
      Exit;

  if ( CurTable = #SpOrder )
    if ( oModifOrds.IsOstOnMSPrPer(True, SkPr, 0, SklOrder.cPodr, SklOrder.dOrd) )
      Exit;

  Result := False;
}

//********************************************************************************
// нельзя редактировать сформированные по сторнирующей накладной складские ордера

Function Check_NoEditStorno: boolean;
{
  Result := (KatSopr.wAdoc = adSoprDocSN)
}

//********************************************************************************

Function F_ProtRec_PositionChanged: boolean;
{
  Result := False;

  case CurTable of
  //-------------------------------------------------
    #SklOrder : ProtectRecord(#SklOrder, F_ProtRec);
  //-------------------------------------------------
    #SpOrder  : ProtectRecord(#SpOrder,  F_ProtRec);
  //-------------------------------------------------
  end;

  // "Запрет редактирования складских ордеров задним числом"
  case CurTable of
  //-----------------------------------------------------
    #SklOrder:
      if ( NOT canEditBackDate )
        if ( IsOstPrPer(SklOrder.dOrd, '') )
          ProtectRecord(#SklOrder, True);
  //-----------------------------------------------------
    #SpOrder:
      if ( NOT canEditBackDate )
        if ( oModifOrds.IsOstOnMSPrPer(True, SkPr, 0, SklOrder.cPodr, SklOrder.dOrd) )
          ProtectRecord(#SpOrder, True);
  //-----------------------------------------------------
  end;

  // "Запрет редактирования складских ордеров при наличии проводок"
  case CurTable of
  //-----------------------------------------------------
    #SklOrder:
      if (NOT fCloseBuhPer(SklOrder.nRec, SklOrder.VidOrder, SklOrder.SP, False))
        ProtectRecord(#SklOrder, True);
  //-----------------------------------------------------
    #SpOrder:
      if (NOT fCloseBuhPer(SklOrder.nRec, SklOrder.VidOrder, SklOrder.SP, False))
        ProtectRecord(#SpOrder, True);
  //-----------------------------------------------------
  end;

  if ( KatSopr.wAdoc = adSoprDocSN )  // складские ордера сформированные по сторнирующей накладной - редактировать нельзя
    {
      ProtectRecord(#SklOrder, True);
      ProtectRecord(#SpOrder , True);
    }

  //------------------------------------------------------------------------------
  // не первичные приходы или расходный или приход с дооценками
  if (CurTable = #SpOrder)
    {
      var pSpOrder: comp; pSpOrder := SpOrder.nRec;

      if (SklOrder.SP = 0)
        if (SpOrder.vidOrder = 0) AND (SpOrder.method <> 0)
          if (
                (
                  (NOT f_KolEqual(SpOrder.kol, SpOrder.ostatok)) AND
                   (loCheckRashOrd.GetFirst SpOrder2 where ((pSpOrder == SpOrder2.cSpOrder)) = tsOk)
                )
              OR
                (
                  loCheckRashOrd.GetFirst SpOrder2 where ((pSpOrder == SpOrder2.cSpOrder AND
                                                           word(0)  == SpOrder2.vidOrder AND
                                                           word(4) <<= SpOrder2.tipOrd (NoIndex) AND
                                                           word(7) >>= SpOrder2.tipOrd (NoIndex) )) = tsOk
                )
             )
            {
              ProtectRecord(#SklOrder, True);
              ProtectRecord(#SpOrder , True);
            }

#ifdef _LINKMTR2SPEC_
      oLinkMTR2Spec.SetObjParam(coSpOrder, SpOrder.nRec, if(IsValid(#SmetaStroy), 2, 0));
#end
    }

  //------------------------------------------------------------------------------
#ifndef __ListSkl_vip__
  ProtectRecord(#AttrValP, IsProtected(#SklOrder));
  ToggleFieldSelectable(#AttrValP.vString, not IsProtected(#SklOrder));
#end

  Result := True;
}

//********************************************************************************
// для cmProtectedInput
Procedure ProtectedInput;
{
  if ( CurField = #BarKodAndState )
  {
    ProtectRecord(#SklOrder, False);
    ProcessCommand(cmPick);
    Exit;
  }

  if (KatSopr.wAdoc = adSoprDocSN)
  {
    Message('Этот сторнирующий складской ордер сформирован для корректирующей накладной - редактировать нельзя');
    Exit;
  }

  if NOT boGetTune('Doc.ModOrder')
    ShowTune('В настройке установлен запрет редактирования ордеров!', 'Doc.ModOrder')
  else
    if (F_ProtRec)
      Message('В настройке установлен запрет редактирования ордеров другой группы')
    else
      if Check_BackDate
         ShowTune('В настройке установлен запрет модификации ордеров в закрытом периоде - '
                      + 'дата начала нового периода: '+DateToStr(GetClosedPeriodDate, 'DD/MM/YYYY'),
                      if (SkPr <> cgVidUchO_UKS, 'McUsl.ModOrder', 'UKS.Doc.ModOrder'));
      else
      {
         if (fCloseBuhPer(SklOrder.nRec, SklOrder.VidOrder, SklOrder.SP, True))
         {
           ProtectRecord(#SklOrder, False);
           ProtectRecord(#SpOrder , False);
         }
      }

  if (SpOrder.method <> 0)
    if (SklOrder.vidOrder = 0)
      {
        var pSpOrder: comp; pSpOrder := SpOrder.nRec;

        if (NOT f_KolEqual(SpOrder.kol, SpOrder.ostatok) AND
            loCheckRashOrd.GetFirst SpOrder2 where ((pSpOrder == SpOrder2.cSpOrder)) = tsOk)
          Message('По данному ордеру были произведены списания')
        else
          if loCheckRashOrd.GetFirst SpOrder2 where ((pSpOrder == SpOrder2.cSpOrder AND
                                                      word(0)  == SpOrder2.vidOrder AND
                                                      word(4) <<= SpOrder2.tipOrd (NoIndex) AND
                                                      word(7) >>= SpOrder2.tipOrd (NoIndex) )) = tsOk
            Message('Для данного прихода была произведена дооценка');
      }
}

//********************************************************************************
// ????

Function GetVidOrdName(awMode: word): string;
{
  case SkPr of
    0: result := if(awMode = 0, 'складские ордера', 'складского ордера');
    1: result := 'ордера УПЛ';
    2: result := 'ордера ТОРО';
    3: result := 'ордера УКС';
  end;
}

//********************************************************************************

Procedure Set_MainTitle(_FilterRekvizParam : word; _sPodr, _sMOL, _sDescr, _sDesGR : string; _dPer : date);
var varStr: string;
var CountPick : longint;
{
  varStr := if(VOrd = 0, 'Приходные ', 'Расходные ') + GetVidOrdName(0);
  CountPick := 0;

#ifndef _KartStor_VIP_
#ifndef __ListSkl_vip__
  _Loop PickSklOrder1 where ((constPickSklOrder == PickSklOrder1.wList))
    CountPick ++;
#end
#end

  if ( fltMask = 0 )
  {
    #ifndef _KartStor_VIP_
    #ifndef __ListSkl_vip__
    if (CountPick > 0)
      varStr := varStr + ' Отмечено ' + String(CountPick) +' записей';
    #end
    #end

    SetWindowTitle(wnMainWindow, varStr);
  }
  else
  {
    varStr := varStr +' с '+string(BegDate)+' по '+string(EndDate);
    if  (_FilterRekvizParam  > 0 )
      varStr := varStr + ' - Фильтр: ';
    if ( (_FilterRekvizParam and 1) > 0 )
      varStr := varStr + ' Подразделение "' + _sPodr + '"';
    if ( (_FilterRekvizParam and 2) > 0 )
      varStr := varStr + ' МОЛ "' + _sMOL + '"';
    if ( (_FilterRekvizParam and 4) > 0 )
      varStr := varStr + ' Дескриптор "' + _sDescr + '"';
    if ( (_FilterRekvizParam and 8) > 0 )
      varStr := varStr + ' Группа дескрипторов "' + _sDesGR + '"';
    if ( (_FilterRekvizParam and 16) > 0 )
      varStr := varStr + ' Дата перемещения "' + DateToStr(_dPer, 'DD/MM/YYYY') +'"';

    #ifndef _KartStor_VIP_
    #ifndef __ListSkl_vip__
    if (CountPick > 0)
      varStr := varStr + ' Отмечено ' + String(CountPick) +' записей';
    #end
    #end

    SetWindowTitle(wnMainWindow, varStr);
  }
}

//********************************************************************************

Function Get_EditTitle: string;
{
  result := 'Редактирование ' + if(VOrd = 0, 'приходного ', 'расходного ') + GetVidOrdName(1);
  if (VOrd = 0)
    if (isDoocen)
      result := 'Редактирование ордера переоценки';

  case wGetTune('Doc.Visible') of
    dcAllModif        // все права
   ,dcOwnModifAllRead // свои - изменение, по всем - чтение
   ,dcGrpModifAllRead:// все права в рамках группы, по всем - чтение
      {
        ToggleFieldSelectable(#SklOrder.Descr, True);
        ToggleFieldSelectable(#SklOrder.DesGr, True);
      }
    dcOwnOnly:        // только со своим дескриптором
      {
        ToggleFieldSelectable(#SklOrder.Descr, False);
        ToggleFieldSelectable(#SklOrder.DesGr, False);
      }
    dcGrpRead         // свои-изменение, по группе - чтение
   ,dcGrpModif:       // все права в рамках группы
      {
        ToggleFieldSelectable(#SklOrder.Descr, True);
        ToggleFieldSelectable(#SklOrder.DesGr, False);
      }
  end;
}

//********************************************************************************
// Выбор склада

Function GetSklad: boolean;
{
  Result := False;

  if ( ( getCurPodr <> 0 ) AND ( SkPr = 0 ) )
    {
      ShowTune('Установлено текущее подразделение.'#13
             + 'Для выбора другого уберите текущее в "Настройке"'
             , 'User.cCurSklad');
      SklOrder.cPodr := getCurPodr;
    }
  else
    {
      var last: comp;
      last := SklOrder.cPodr;
      var PrSk: word;
      PrSk := Case(SkPr; 0: 1, 3: 0; 4);

      if ( wGetTune('Country') = ccUzb ) //Узбекистан
        PrSk := 3;

      if ( RunInterface('GetAnyPodr', SklOrder.cPodr, (08000h OR PrSk)) <> cmDefault )
        Exit;

      if ( last = SklOrder.cPodr )
        Exit;

      if ( SklOrder.VidOrder = 1 ) // расход
      {
        if (
             (oMSview.GetTuneMSForPodr(SklOrder.cPodr) = 1)
           or
             (IsLifoFifoNU)
           or
             (IsLifoFifo AND (SklOrder.TipOrd <> 3))
           )
          {
            ShowTune('Выбор данного подразделения при данной методике списания запрещен'#13'См. также методику списания по подразделению', 'Oper.L_F');
            SklOrder.cPodr := last;
            Exit;
          }
      }

      var now: comp; now := SklOrder.cPodr;

      if (not oModifOrds.CheckBlockPodrInventar(0, SklOrder.cPodr, 0, True, True, True))
      {
        SklOrder.cPodr := last;
        Exit;
      }

      SklOrder.cPodr := last;
      SklOrder.cPodr := now;

      if ( boGetTune('Pick.SkladWithMol') )
        {
          if ( SklOrder.cMOL <> 0 )
            if ( KatMol.cSkl <> SklOrder.cPodr )
              SklOrder.cMOL := 0;   // обнулить МОЛ, если не из того склада

          ResetBounds(#KatMol);
          if ( GetFirst KatMol
                  where ((SklOrder.cPodr == KatMol.cSkl)) = tsOk )
            {
              last := KatMol.nRec;
              if ( isAvtoMol ) //автовыбор МОЛ
                if ( GetNext KatMol where
                              ((SklOrder.cPodr == KatMOL.cSkl)) <> tsOk )
                  set SklOrder.cMOL := Last
                else
                  {
                    SelectField(#KatMOL.Name);
                    PutCommand(cmPick);
                  }
            }

          SetBounds(#KatMol);
        }
    }

  if ( GetFirst KatPodr where ((SklOrder.cPodr == KatPodr.nRec)) = tsOk )
    set SklOrder.cGrPodr := KatPodr.cGrPodr;

  Result := (SklOrder.cPodr <> 0 );
}

//********************************************************************************
// Проверка возможности удаления позиции складского ордера по возврату
// True - можно удалить, False - нельзя удалить
Function CheckVzv: boolean;
var pSpOrder: comp;
{
  pSpOrder  := SpOrder.nRec;

  Result := (loCheckRashOrd.RecordExists SpOrder2 where (( pSpOrder == SpOrder2.cSpOrdV)) <> tsOk );
}

//********************************************************************************
// Выбор МОЛ
Procedure GetMol;
var last, now: comp;
{
  #ifndef __ListSkl_vip__
  #ifndef _KartStor_VIP_
  if ( (FilterRekvizParam and 2) > 0 )
    Exit;
  #end
  #end

  ResetBounds(#KatMol);
  While True Do
    {
      last := SklOrder.cMOL;
      if ( RunInterface(GetMOL, SklOrder.cMOL, SklOrder.cPodr) <> cmCancel )
        if ( last <> SklOrder.cMOL )
          {
            now := SklOrder.cMOL;
            SklOrder.cMOL := last;
            set SklOrder.cMOL := now;
          }

      if (SklOrder.cMOL = 0) AND (SklOrder.vidOrder = 0) AND (boGetTune('Oper.NeedMOL'))
        ShowTune('Необходимо выбрать МОЛ', 'Oper.NeedMOL');
      else
        Break;
    }

  SelectField(#KatPodr.Name);
  SetBounds(#KatMol);
  RedrawPanel(CurTable);
}

//********************************************************************************
// Функция проверки складского ордера

Function CheckOrder: boolean;
{
  var Res: boolean = (SklOrder.cPodr <> 0);

  CheckOrder := Res;
  if ( NOT Res )
    {
      if SklOrder.nRec <> 0
        Message('Нет наименования подразделения...', Information);
      Exit;
    }

  SklOrder.YearOrd := Year(SklOrder.dOrd);

  if ( NOT oOrdHoz.UpdateSoprHoz (SklOrder.nRec, SklOrder.cSopr, cValOrd, sumOrd, vSumOrd, SklOrder.dOrd))
    Message('Невозможно зафиксировать операцию в книге разноски хозопераций...', OkButton);

  if ( GetFirst KatSopr = tsOk )
    if ( KatSopr.dOpr <> SklOrder.dOrd )
      {
        var changeDate: boolean;  changeDate := True;

        // в расходном ордере нужно подтверждение - для ОАУК
        if ( SklOrder.VidOrder = 1 ) // расходный ордер
          if ( Message('Дата оприходования накладной не совпадает с датой ордера.'#13 +
                       'Произвести корректировку?', Confirmation + YesNo) <> cmYes )
            changeDate := False;

        iKB.SaveInfoforBal(KatSopr.VidSopr, KatSopr.nRec);

        if ( changeDate )
          {
            KatSopr.dOpr := SklOrder.dOrd;

            if ( Update current KatSopr = tsOk )
              Update SpSopr where ((KatSopr.nRec == SpSopr.cSopr))
                set SpSopr.dOprTTN := SklOrder.dOrd;
          }

        iKB.ModiKontrBal(KatSopr.VidSopr, KatSopr.nRec);
      }
}

//********************************************************************************

#include lf_dooc.vpp

//******************************************************************************
// Процедура удаления складского ордера
var piOsReal: iOsReal;
var nrecKatSoprNakl : comp;

Function DeleteOrder(DoDelOrd: boolean): boolean;
{
  DeleteOrder := False;

  if ( DoDelOrd )
  {
    if ( NOT oSDfuns.CanDeleteDocument(SklOrder.DOrd) )
      Exit;

    if ( NOT oSDfuns.CanDeleteDocumentOborot(SklOrder.nRec, GetSoprHozTipDoc(SkPr, SklOrder.VidOrder)) )
      Exit;
  }

  var tr: comp = SpOrder.nRec;

  StartNewVisual(vtNumericVisual, vfTimer, 'Проверка наличия возвратов', 1);

  _LOOP SpOrder
    {
      NextVisual;
      if ( NOT CheckVzv )
        {
          Message('Данный ордер удалять нельзя т.к. по нему уже были проведены возвраты МЦ', Information);
          StopVisual('', 0);
          Exit;
        }

      if (SpOrder.vidOrder = 0) AND
         (SpOrder.method <> 0) AND
         (NOT f_KolIsZero(SpOrder.kol)) AND
         (NOT f_KolEqual(SpOrder.kol, SpOrder.ostatok))
        {
          Message('По ордеру были проведены списания - удалять нельзя', Information);
          StopVisual('', 0);
          Exit;
        }
    }

  nrecKatSoprNakl := 0;
  if (SklOrder.cSopr <> 0)
    if GetFirst KatSopr where ((SklOrder.cSopr == KatSopr.nRec))= tsOk
      if (KatSopr.VidSopr = 101)
       {
         nrecKatSoprNakl := KatSopr.nRec;
         if ( coGetTune('Oper.Buy.Nakl.BeforeDelOrder') <> 0 )
           if ( RunInterface( SimpleWayToRunAlgorithm
                            , coGetTune('Oper.Buy.Nakl.BeforeDelOrder')
                            , word(2101)
                            , KatSopr.nRec
                            , comp(0)
                            ) <> cmCancel )
            ReReadRecord(#KatSopr);
       }


  oSDfuns.DeleteSoprHoz(SklOrder.nRec, GetSoprHozTipDoc(SkPr, SklOrder.VidOrder));

  SetVisualHeader('Удаление проводок');

  iSaldoActuality.DropActualityForPlansSch(0); // сброс актуальности для всех планов счетов

  // !!! заменить на метод финиковского объекта, удаляющий обороты!!!
  if ( delete safe NoVisual Oborot <> tsOk )
    {}

  var SumFOrd : double = 0;
  var VSumFOrd: double = 0;

  if ( GetFirst SpOrder = tsOk )
    {
      SetVisualHeader('Подготовка к удалению спецификации...');
      var marks: TPtr = InitMarker('', 8, 100, 100);
      var markj, markm: longint;
      var markc: comp = 0;

      _LOOP SpOrder
        {
          NextVisual;

          if (IsLifoFifo AND SklOrder.VidOrder = 1) OR
             ((oMSview.GetTuneMSForPodr(SklOrder.cPodr) = 1) AND (SklOrder.VidOrder = 1) AND(SklOrder.TipOrd < 4))
            oOrdLIFO.RestoreOnePrihOrd(True, SpOrder.nRec);

          if IsLifoFifoNU
            oSetPriceNU.RestoreOstatokN(True, SpOrder.nRec);

          if SklOrder.vidOrder = 0 AND SpOrder.method = 3 AND (SpOrder.tipOrd >= 4 AND SpOrder.tipOrd <= 7)
            UpdateDooc_toRash_SpOrders(False);

          SumFOrd  += SpOrder.srPrice * SpOrder.kol;
          VSumFOrd += SpOrder.VPrice  * SpOrder.kol;

          InsertMarker(marks, SpOrder.nRec);
        }

      markm := GetMarkerCount(marks);
      SetVisualHeader('Удаление спецификации ордера');

      For ( markj := 0; markj < markm; markj++ )
        if ( GetMarker(marks, markj, markc) )
          {
            NextVisual;
            if ( GetFirst SpOrder where((markc == SpOrder.nRec)) = tsOk )
              {
#ifdef _USE_SERIAL_
                oSerialMove.RemoveHistory(SpOrder.nRec);
#end

#ifdef _ZPRIHORD_VIP_
                loCheckRashOrd.SpOrder_nRec := SpOrder.nRec;
                loCheckRashOrd.delete SpDocSmeta where (( coSpOrder == SpDocSmeta.coTable and SpOrder_nRec == SpDocSmeta.cSpec ));
#end

#ifdef _RASHORD_VIP_
                loCheckRashOrd.SpOrder_nRec := SpOrder.nRec;
                loCheckRashOrd.delete SpDocSmeta where (( coSpOrder == SpDocSmeta.coTable and SpOrder_nRec == SpDocSmeta.cSpec ));
#end

                oModifOrds.AnySpOrder_Delete(TypeSpOrder(SpOrder.buffer));
              }
          }

      DoneMarker(marks, '');
    }

  SetVisualHeader('Удаление хозопераций'#13);

  // !!! заменить на метод финиковского объекта, удаляющий soprhoz-ы!!!
  if ( delete safe NoVisual SoprHoz <> tsOk )
    {}

  if ( GetFirst KatSopr where ((SklOrder.cSopr == KatSopr.nRec)) = tsOk )
    {
      SetVisualHeader('Модификация сопроводительного документа');

      iKB.SaveInfoforBal(KatSopr.VidSopr, KatSopr.nRec);

      var iSklOrd : integer; iSklOrd := 0;
      var cSklOrd : comp; cSklOrd := KatSopr.nRec;

      pushpos(#SklOrder);

      _loop SklOrder where (( cSklOrd == SklOrder.cSopr ))
        iSklOrd++;

      poppos(#SklOrder);

      if ( iSklOrd = 1 )
        {
          KatSopr.dOpr := ZeroDate;

          update SpSopr where ((KatSopr.nRec == SpSopr.cSopr))
            set SpSopr.dOprTTN := ZeroDate;

          _try
            {
              // доработка для ЧТН
              var oCHTN: CHTNObj;

              if LoadVipRef(oCHTN, 'L_SKLAD::iCHTN')
                {
                  oCHTN.SetSoprAn(KatSopr.nRec, ZeroDate);
                  FreeVipInterface(oCHTN);
                }
            }
          _except on ExObjIfcBadVar: {}
          _except on ExObjIfcNoLoad: {}
          _except on ExObjIfcNoImpl: {}
        }

      ResetBounds(#SoprHoz);

      if ( GetFirst SoprHoz where ((KatSopr.VidSopr == SoprHoz.TipDoc AND
                                    KatSopr.nRec    == SoprHoz.cSoprDoc)) = tsOk )
        {
          SoprHoz.SummaSp  -= SumFOrd;
          SoprHoz.SumValSp -= VSumFOrd;

          iSHoz.UpdByHan(SoprHoz.BufferP);
        }

      SetBounds(#SoprHoz);

      if ( Update Current KatSopr <> tsOk )
        Message('Не удалось убрать дату проведения в накладной, связанной с данным ордером.'#13 +
                'Сделайте это вручную либо проведите проверку корректности!',  Warning+OkButton);

      iKB.ModiKontrBal(KatSopr.VidSopr, KatSopr.nRec);
    }

// определяем новый defain для приходных и расходных ордеров
#ifdef _ZPRIHORD_VIP_
#define _PRIH_RASH_
#end

#ifdef _RASHORD_VIP_
#define _PRIH_RASH_
#end

// удаление внешних атрибутов
#ifdef _PRIH_RASH_
  if not (DeleteAllAttr(coSklOrder, SklOrder.nRec))
    {}
#else
  #ifndef __ListSkl_vip__
  // примечание для всех кроме приходных/расходных ордерах
  if IsValid(#AttrValP)
    delete current AttrValP;
  #endif
#endif

  if ( DoDelOrd )
    {
      SetVisualHeader('Удаление ордера');

      case SklOrder.vidOrder of
      //----------------------------------------------------------
        0: insTbl.DeleteEnviroment(toReceiptOrder, SklOrder.nRec);
      //----------------------------------------------------------
        1: insTbl.DeleteEnviroment(toDebitOrder, SklOrder.nRec);
      //----------------------------------------------------------
      end; //c

      oModifOrds.AbortOrdNom(SklOrder.nRec);

      var cUKS  : comp = SklOrder.nRec;
      var VidUKS: word = SklOrder.VidOrder;

      if ( delete current SklOrder = tsOk )
        {
          #SetStateDeleteDocOnArchive(GetSoprHozTipDoc(SkPr, VidUKS), cUKS)
          oChkSchem.RemoveDocFromSpSchem(cUKS, GetSoprHozTipDoc(SkPr, VidUKS));

          if ( VidUKS = 0 )
            piOsReal.OnDeleteDoc(cgOsReal_Order, cUKS);
        }
    }

  // удаление внешних атрибутов
#ifdef _ZPRIHORD_VIP_
  DeleteAllAttr(coSklOrder, SklOrder.nRec);
#endif

  if (nrecKatSoprNakl <> 0)
    if GetFirst KatSopr where ((nrecKatSoprNakl == KatSopr.nRec))= tsOk
      if (KatSopr.VidSopr = 101)
      {
        if ( coGetTune('Oper.Buy.Nakl.AfterDelOrder') <> 0 )
          if ( RunInterface( SimpleWayToRunAlgorithm
                           , coGetTune('Oper.Buy.Nakl.AfterDelOrder')
                           , word(2101)
                           , KatSopr.nRec
                           , comp(0)
                            ) <> cmCancel )
            ReReadRecord(#KatSopr);
      }

  StopVisual('', 0);

  DeleteOrder := True;
} //Function DeleteOrder

//********************************************************************************
// public-функция удаления ордера

Function Delete_Order(cSklOrder_: comp): boolean;
{
  Delete_Order := False;

  if GetFirst SklOrder where ((cSklOrder_ == SklOrder.nRec)) <> tsOk
    {
      Message('не найден ордер с NRec ' + string(cSklOrder_));
      Exit;
    }

  Delete_Order := DeleteOrder(True);
}

//********************************************************************************
// Расчет наличия для расходных ордеров по настройке
Function CheckNalNastr(_OrdDate : Date; _cMC, _cPodr, _cMol, _cParty : comp; FlagInit : Boolean) : double;
{
  if ( FlagInit )
    InitMCInfo(_OrdDate);

  CheckNalNastr := 0;

  if (wGetTune('Sklad.ContrSpisRashOrd') = 1)
  {
    CheckNalNastr := NalT( _OrdDate
                         , _cMC
                         , if (_cPodr  = 0, comp(-1), _cPodr)
                         , if (_cMOL   = 0, comp(-1), _cMOL)
                         , if (_cParty = 0, comp(-1), _cParty)
                         );
  }
  else
    CheckNalNastr := NalT( Cur_Date
                         , _cMC
                         , if (_cPodr  = 0, comp(-1), _cPodr)
                         , if (_cMOL   = 0, comp(-1), _cMOL)
                         , if (_cParty = 0, comp(-1), _cParty)
                         );

  if ( FlagInit )
    DoneMcInfo;
}

//********************************************************************************
// Установка значений полей по умолчанию для спецификации ордера
Procedure SpOrderDefault;
{
  ClearBuffer(#SpOrder);

  SpOrder.SP        := SklOrder.SP;
  SpOrder.cSklOrder := SklOrder.nRec;
  SpOrder.VidOrder  := SklOrder.vidOrder;
  SpOrder.TipOrd    := SklOrder.tipOrd;
  SpOrder.dOrd      := SklOrder.dOrd;
  SpOrder.ccMOL     := SklOrder.cMOL;
  SpOrder.ccPodr    := SklOrder.cPodr;
  SpOrder.cVal      := coBaseCurrency;
  SpOrder.Descr     := GetUserDescr;
  SpOrder.DesGr     := GetUserDesGr;
  SpOrder.nRec      := GetNextNRec(#SpOrder, 0);
}

//********************************************************************************

Procedure RunHotKeys;
{
  if ( NOT UpdateTable )
    Exit;

  #ifdef USE_ORDERS_INHERIT
  if ( isDoocen )
    case CurTable of
    //-------------------------------------------------------------
      #SklOrder  : PutHotCommand(RunMenu('SklOrder_HotKeys_Dooc'));
    //-------------------------------------------------------------
      #SpOrder   : PutHotCommand(RunMenu('SpOrder_HotKeys_Dooc'));
    //-------------------------------------------------------------
    end
  else
  #end
    case CurTable of
    //---------------------------------------------------------------------------
      #SklOrder:
      {
        var MenuStr1: string;
        MenuStr1 := 'L_SKLAD::';

        if (Word(0) = SklOrder.VidOrder)
          PutHotCommand(RunDynMenu('L_Sklad::SklOrder_HotKeys'+
                        if(GetMethodSpis<>0, ';SEPARATOR;' + 'L_Sklad::LF_HotKeys', '')));
        else
          PutHotCommand(RunMenu('SklOrder_HotKeys_Ras'));
      }
    //---------------------------------------------------------------------------
      #SpOrder  :
        {
          EnableCommand(cmNal);

          if ( SklOrder.VidOrder = 0 )
            PutHotCommand(RunMenu('SpOrder_HotKeys'));
          else
            PutHotCommand(RunMenu('SpOrder_HotKeys_Ras'));
        }
    //---------------------------------------------------------------------------
    end;
}

//********************************************************************************
// Установка ограничений видимости складских ордеров
Procedure SetFilters;
{
  if ( fltMask = 0 )  // Без даты
    PushBounds(tbAllSkl)
  else // с датами
    PushBounds(tbAllSklD);

  case DscVisible of
  //  dcAllModif, dcOwnModifAllRead, dcGrpModifAllRead:   PushBounds(tbAllSkl);
  //-------------------
    dcOwnOnly:
      if NOT BoundActive(tbDescrUsr)
        AddBounds(tbDescrUsr) // Фильтры по дескриптору пользователя
  //-------------------
    dcGrpRead
  , dcGrpModif:
      if NOT BoundActive(tbDescrGrp)
        AddBounds(tbDescrGrp) // Фильтры по группе дескрипторов
  //-------------------
  end;

  if GetCurPodr <> 0
    if NOT BoundActive(tbCurSkl)
      AddBounds(tbCurSkl);

  #ifdef Prih_ord_VIP
    SetMainFilters;
  #end
}

//********************************************************************************
// Снятие ограничений видимости складских ордеров
Procedure ResetFilters;
{

  case DscVisible of
  //  dcAllModif , dcOwnModifAllRead  , dcGrpModifAllRead:  PushBounds(tbAllSkl);
  //--------------------
    dcOwnOnly:
      if BoundActive(tbDescrUsr)
        SubBounds(tbDescrUsr) // Фильтры по дескриптору пользователя
  //-------------------
    dcGrpRead
  , dcGrpModif:
      if BoundActive(tbDescrGrp)
        SubBounds(tbDescrGrp) // Фильтры по группе дескрипторов
  //-------------------
  end;

  if BoundActive(tbCurSkl) //GetCurPodr <> 0
    SubBounds(tbCurSkl);

  if ( fltMask = 0 )  // Без даты
    PopBounds(tbAllSkl)
  else // с датами
    PopBounds(tbAllSklD);

  #ifdef Prih_ord_VIP
    SetMainFilters;
  #end
}

//********************************************************************************
// Изменение/сброс фильтра по датам
Procedure SetOrdFlt;
{
  if ( NOT UpdateTable )
    Exit;

  if ( IsNew  AND ( NOT IsModified ) )
    Exit;

  var aBegDate: date; aBegDate := BegDate;
  var aEndDate: date; aEndDate := EndDate;

  if ( aBegDate = ZeroDate )
    if ( (SklOrder.dOrd <> ZeroDate ) AND (SklOrder.dOrd <= Cur_Date) )
      aBegDate := SklOrder.dOrd
    else
      aBegDate := Sub_Day(Cur_Date, 5);

  if ( (aEndDate = Date(31, 12, 2199)) OR (aEndDate = ZeroDate ) )
    aEndDate := Cur_Date;

  if ( RunDialog(GetInterval, aBegDate, aEndDate) <> cmCancel )
    {
      if ( aBegDate > aEndDate )
        {
          Message('Начальная дата диапазона больше конечной.'#13+
                  'Фильтр не изменен...', Information);
          Exit;
        }
      if ( (aBegDate <> BegDate) OR (aEndDate <> EndDate) OR (fltMask = 0 ) )
        {
          BegDate := aBegDate;
          EndDate := aEndDate;

          if ( fltMask = 0 )
            {
              ResetFilters;
              fltMask := 1;
              SetFilters;

              if ( not IsValid(#SklOrder) )
                {
                  Message('Нет записей. Фильтр снят.');
                  ResetFilters;
                  fltMask := 0;
                  SetFilters;
                  RescanPanel(#SklOrder);
                  Stop;
                }
            }

          RereadRecord(#SklOrder);
          RereadRecord(#Soprhoz);
          RereadRecord(#Oborot);
          Stop;
        }
    }
  else
    if ( fltMask <> 0 )
      if ( Message('Снять фильтр по датам?', YesNo+Confirmation) = cmYes )
        {
          ResetFilters;
          fltMask := 0;
          SetFilters;

          RescanPanel(#SklOrder);
          Stop;
        }

  Set_MainTitle(0, '', '', '', '', ZeroDate);
}

//********************************************************************************

Procedure SetDescriptor;
{
  if ( IsNew AND ( NOT IsModified) )
    Exit;

  if ( NOT UpdateTable )
    Exit;

  var TempVisible: word; TempVisible := DscVisible;

  if ( RunInterface('GetDescrEx', DscName, DscGroup, TempVisible, word(1)) = cmCancel )
    Exit;

  if ( TempVisible <> DscVisible )
    {
      ResetFilters;
      DscVisible := TempVisible;
      SetFilters;
    }

  RereadRecord;
}

//********************************************************************************
// Выполняет просмотр соответствующего сопроводительного документа
// привязанного к складскому ордеру
Procedure RunSoprDocView;
{
  if ( SklOrder.TipOrd = 10 )
    {
      Message('Для ордеров по розничной торговле не предусмотрен вызов сопроводительных документов...', Information);
      Exit;
    }

  if ( SklOrder.cSopr = 0 )
    Message('По данному ордеру нет сопроводительных документов', Information);
  else
    {
      if ( NOT UpdateTable )
        Exit;

      if ( GetFirst KatSopr where ((SklOrder.cSopr == KatSopr.nRec)) = tsOk )
        {
          if ((KatSopr.VidSopr = 101) OR (KatSopr.VidSopr = 201))
            RunInterface('ViewSoprDoc', SklOrder.cSopr);
          else
            iEditDoc.RunEditHozDoc(coKatSopr, KatSopr.VidSopr, KatSopr.VidSopr, KatSopr.nRec);
        }
      else
        Message('Не найден сопроводительный документ по данному ордеру...', Information);
    }
}

//********************************************************************************

Procedure UpdateSpOrderDes;
{
  PushPos(#SpOrder);
  StartNewVisual(vtRotateVisual, vfTimer, 'Обновление дескриптора/группы по позициям спецификации ордера', 1);

  _LOOP SpOrder
    {
      NextVisual;

      SpOrder.Descr := SklOrder.Descr;
      SpOrder.DesGr := SklOrder.DesGr;

      oModifOrds.AnySpOrder_Update(TypeSpOrder(SpOrder.buffer));

      SoprHoz.Descr := SklOrder.Descr;
      SoprHoz.DesGr := SklOrder.DesGr;

      iSHoz.UpdByHan(SoprHoz.BufferP);
    }

  PopPos(#SpOrder);

  RereadRecord(#SpOrder);
  StopVisual('', 0);
}

//********************************************************************************

Function SumCorrect: boolean;
{
  SumCorrect := True;

  if ( prAvePrice OR ( (SklOrder.TipOrd >= 3) AND (SklOrder.TipOrd <= 7) ) )
    Exit;

  PushPos(#SpOrder);

  _LOOP SpOrder
    if ( NOT CheckSpKol )
      {
        SumCorrect := False;
        Break;
      }

  PopPos(#SpOrder);
}

//********************************************************************************
Function GetPriceRazrezOrder(_cMC, _cPodr, _cMOL, _cParty : comp; FlagInit : boolean) : boolean;
{
  if ((SklOrder.VidOrder = 1) and (  ((boGetTune('Oper.RazrezCU')) and (SpOrder.SP <> cgVidUchO_UPL))
                                  or ((boGetTune('Manuf.RazrezCU')) and (SpOrder.SP = cgVidUchO_UPL))
                                  ))
  {
    if (GetFirst SpecMTR = tsOk)
      oSald.CountPriceCU(SklOrder.dOrd, SkPr, SpecMTR.cSaldTune, SpecMTR.cObj, SpecMTR.cKau[1],
                         SpecMTR.cKau[2], SpecMTR.cKau[3], SpecMTR.cKau[4], SpecMTR.cKau[5],
                         SpecMTR.cKau[6], SpecMTR.cKau[7], SpecMTR.cKau[8], SpecMTR.cKau[9],
                         SpOrder.cMC, SklOrder.cPodr, SklOrder.cMol, SpOrder.cParty,
                         dSrPrice, dvPrice, dKol, _cVal );
    else
      oSald.CountPriceCU(SklOrder.dOrd, SkPr, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                         SpOrder.cMC, SklOrder.cPodr, SklOrder.cMol, SpOrder.cParty,
                         dSrPrice, dvPrice, dKol, _cVal );

    SpOrder.srPrice := SpOrder.rsrPrice := dSrPrice;
    SpOrder.VPrice  := SpOrder.rVPrice := dvPrice;
    SpOrder.cVal    := _cVal;
  }
  else
  {
    if (FlagInit)
    {
      InitMCInfo(SklOrder.dOrd);
      LockValOt(True);
      SkladProizv(SKlOrder.SP);
    }

    SpOrder.cVal := StepMCInfo(_cMC, SpOrder.cVal,
                    if (_cPodr    = 0, comp(-1), _cPodr),
                    if (_cMOL     = 0, comp(-1), _cMOL),
                    if (_cParty   = 0, comp(-1), _cParty));

    SpOrder.srPrice := SpOrder.rsrPrice := AveragePrice;
    SpOrder.VPrice  := SpOrder.rVPrice := AverageVPrice;
    if (FlagInit)
      DoneMCinfo;
  }

  result := True;
}

//********************************************************************************
Procedure RecalcSrPricePosCU;
{
  if (not (  (boGetTune('Oper.RazrezCU') and (SpOrder.SP <> cgVidUchO_UPL))
          or (boGetTune('Manuf.RazrezCU') and (SpOrder.SP = cgVidUchO_UPL))
          ))
    Exit;

  if ( CurTable <> #SpOrder )
    Exit;

  SumOrd  := SumOrd  - SpOrder.srPrice * SpOrder.kol;
  VSumOrd := VSumOrd - SpOrder.VPrice  * SpOrder.kol;

  if ( oMSview.GetPrices_MSPrih2(SpOrder.rSrPrice, SpOrder.rVPrice, SpOrder.cVal, SpOrder.cSpOrder) )
  {
    set SpOrder.cVal     := SpOrder.cVal;
    set SpOrder.rSrPrice := SpOrder.rSrPrice;
    set SpOrder.rVPrice  := SpOrder.rVPrice;
  }
  else
  {
    if (GetFirst SpecMTR = tsOk)
      oSald.CountPriceCU(SklOrder.dOrd, SkPr, SpecMTR.cSaldTune,
            SpecMTR.cObj, SpecMTR.cKau[1], SpecMTR.cKau[2], SpecMTR.cKau[3], SpecMTR.cKau[4], SpecMTR.cKau[5],
            SpecMTR.cKau[6], SpecMTR.cKau[7], SpecMTR.cKau[8], SpecMTR.cKau[9], SpOrder.cMC, SklOrder.cPodr, SklOrder.cMol, SpOrder.cParty,
            dSrPrice, dvPrice, dKol, _cVal );
    else
      oSald.CountPriceCU(SklOrder.dOrd, SkPr, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, SpOrder.cMC, SklOrder.cPodr, SklOrder.cMol, SpOrder.cParty,
                              dSrPrice, dvPrice, dKol, _cVal );

    set SpOrder.rsrPrice := dSrPrice;
    set SpOrder.rVPrice  := dvPrice;
    set SpOrder.cVal    := _cVal;
  }

  SimValutOrd := KlVal.SimvolV;
  set SpOrder.srPrice := oSaldo_K.RoundRubOrd(SpOrder.rSrPrice, SpOrder.kol);
  set SpOrder.vPrice  := oSaldo_K.RoundValOrd(SpOrder.rVPrice, SpOrder.kol);

  SumOrd  := SumOrd  + SpOrder.srPrice * SpOrder.kol;
  VSumOrd := VSumOrd + SpOrder.VPrice  * SpOrder.kol;

  RedrawPanel(#SklOrder);
}

//********************************************************************************

Procedure RecalcSrPricePos(mess_: boolean);
{
  if ( CurTable <> #SpOrder )
    Exit;

  SumOrd  := SumOrd  - SpOrder.srPrice * SpOrder.kol;
  VSumOrd := VSumOrd - SpOrder.VPrice  * SpOrder.kol;

  if ( NOT IsNew )
    {
      var SavMC: comp;  SavMC := SpOrder.cMC;
      SpOrder.cMC := 0;
      oModifOrds.AnySpOrder_Update(TypeSpOrder(SpOrder.buffer));
      set SpOrder.cMC := SavMC;
    }

  if ( oMSview.GetPrices_MSPrih2(SpOrder.rSrPrice, SpOrder.rVPrice, SpOrder.cVal, SpOrder.cSpOrder) )
  {
    set SpOrder.cVal     := SpOrder.cVal;
    set SpOrder.rSrPrice := SpOrder.rSrPrice;
    set SpOrder.rVPrice  := SpOrder.rVPrice;
  }
  else
  {
    GetPriceRazrezOrder(SpOrder.cMC, SklOrder.cPodr, SklOrder.cMOL, SpOrder.cParty, True);
  }

  SimValutOrd := KlVal.SimvolV;
  set SpOrder.srPrice := oSaldo_K.RoundRubOrd(SpOrder.rSrPrice, SpOrder.kol);
  set SpOrder.vPrice  := oSaldo_K.RoundValOrd(SpOrder.rVPrice, SpOrder.kol);

  SumOrd  := SumOrd  + SpOrder.srPrice * SpOrder.kol;
  VSumOrd := VSumOrd + SpOrder.VPrice  * SpOrder.kol;

  RedrawPanel(#SklOrder);
}

//********************************************************************************

Function GetMCinfo: boolean;
{
  GetMCInfo := False;
  var cMC_     : comp;   cMC_     := if ( SpOrder.cMC    = 0, -1, SpOrder.cMC   );
  var cPodr_   : comp;   cPodr_   := if ( SpOrder.ccPodr = 0, -1, SpOrder.ccPodr);
  var cMOL_    : comp;   cMOL_    := if ( SpOrder.ccMOL  = 0, -1, SpOrder.ccMOL );
  var cParty_  : comp;   cParty_  := if ( SpOrder.cParty = 0, -1, SpOrder.cParty);

  if ( NOT InitMCinfo( if(wGetTune('Sklad.PereocToday')=0, sub_day(SklOrder.dOrd, 1), SklOrder.dOrd)) )
  {
    Message('Ошибка инициализации расчета остатков', Warning);
    Exit;
  }

  SkladProizv(SkPr);

  if ((SklOrder.VidOrder = 1) and (  ((boGetTune('Oper.RazrezCU')) and (SpOrder.SP <> cgVidUchO_UPL))
                                  or ((boGetTune('Manuf.RazrezCU')) and (SpOrder.SP = cgVidUchO_UPL))
                                  ))
  {
     if (GetFirst SpecMTR = tsOk)
       oSald.CountPriceCU(if(wGetTune('Sklad.PereocToday')=0, sub_day(SklOrder.dOrd, 1), SklOrder.dOrd), SkPr, SpecMTR.cSaldTune,
                                                  SpecMTR.cObj, SpecMTR.cKau[1], SpecMTR.cKau[2], SpecMTR.cKau[3], SpecMTR.cKau[4], SpecMTR.cKau[5],
                                                  SpecMTR.cKau[6], SpecMTR.cKau[7], SpecMTR.cKau[8], SpecMTR.cKau[9],
                                                  cMC_, cPodr_, cMol_, cParty_,
                                                  dSrPrice, dvPrice, dKol, _cVal );
     else
      oSald.CountPriceCU(SklOrder.dOrd, SkPr, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                         cMC_, cPodr_, cMol_, cParty_,
                         dSrPrice, dvPrice, dKol, _cVal );

    set OldSrPrice := dSrPrice - if(wGetTune('Sklad.PereocToday') = 0, 0, SpOrder.srPrice / dKol);
    set OldVPrice  := dvPrice  - if(wGetTune('Sklad.PereocToday') = 0, 0, SpOrder.vPrice  / dKol);

    set kolMC := dKol;
  }
  else
  {
    StepMCinfo( cMC_, SpOrder.cVal, cPodr_, cMOL_, cParty_ );

    set OldSrPrice := AveragePrice  - if(wGetTune('Sklad.PereocToday') = 0, 0, SpOrder.srPrice / CountMC);
    set OldVPrice  := AverageVPrice - if(wGetTune('Sklad.PereocToday') = 0, 0, SpOrder.vPrice  / CountMC);

    set kolMC := CountMC;
  }

  if ( wasStoppedMCInfo )
    {
      DoneMCinfo;
      Exit;
    }

  //для НУ
  StepMCinfo(cMC_, 0, 0, 0, 0);

  set oldPriceN := AveragePriceN - if(wGetTune('Sklad.PereocToday') = 0, 0, SpOrder.priceN / CountMC);
  set kolMCN    := CountMC;

  DoneMCinfo;

  set NewSrPrice := (SpOrder.SrPrice / if(f_KolIsZero(kolMC) , 1.0, kolMC ) ) + OldSrPrice;
  set newPriceN  := (SpOrder.priceN  / if(f_KolIsZero(kolMCN), 1.0, kolMCN) ) + oldPriceN;

  if ( SpOrder.cVal = 0 )
    if ( GetFirst KlVal where ((coBaseCurrency == KlVal.nRec )) = tsOk )
      SpOrder.cVal := KlVal.nRec;

  set NewSimvolV := KlVal.SimvolV;
  set NewVprice  := (SpOrder.vPrice / if(f_KolIsZero(KolMC), 1.0, KolMC) ) + OldVPrice;

  GetMCinfo := True;
}

//********************************************************************************
// при смене партии надо запомнить партию до замены(нужно для изменения текущих остатков)
//
Function F_Change_Party(OldParty: comp): boolean;
{
  var Nal : double;
  F_Change_Party := False;

  if ( CurTable <> #SpOrder )
    Exit;

  if ( IsProtected(#SklOrder) )
    Exit;

  if ( IsProtected(#SpOrder) )
    Exit;

  if ( SpOrder.cMC = 0 )
    Exit;

  if ( SpOrder.cParty = OldParty )
    Exit;

  var NewParty: comp;  NewParty := SpOrder.cParty;

  SpOrder.cParty := OldParty;
  if ( SklOrder.VidOrder = 1 ) and (wGetTune('Sklad.ContrSpisRashOrd') <> 0)
  {
    Nal := CheckNalNastr(SklOrder.dOrd, SpOrder.cMC, SklOrder.cPodr, SklOrder.cMol, NewParty, True);
    if (Nal < SpOrder.Kol)
    {
      message('По выбранной партии количество меньше, чем количество по позиции!'#13+
              'количество по позиции МЦ ' + DoubleToStr(SpOrder.Kol, '\3p[|-]36`666`666`666`666.888')+''#13 +
              'количество по выбранной партии ' + DoubleToStr(Nal, '\3p[|-]36`666`666`666`666.888'));
      SetModified(False);
      RereadRecord(#SpOrder);
      Exit;
    }
  }

  set SpOrder.cParty := NewParty;

  if ( SklOrder.VidOrder = 1 ) // расход Пересчет средних цен
    {
      if ( KatParty.cValPar <> 0 ) AND ( KatParty.cValPar <> SpOrder.cVal )
        set SpOrder.cVal := KatParty.cValPar;

      RecalcSrPricePos(True);
    }
  else //приход.
    if ( (SpOrder.cParty <> 0 ) AND (KatParty.cValPar <> 0 ) AND (KatParty.cValPar <> SpOrder.cVal) )
      {
        var Curse: TSumma;

        set SpOrder.cVal := KatParty.cValPar;

        if ( (SpOrder.SrPrice <> 0 ) OR (SpOrder.VPrice <> 0 ) )
#ifdef _ZPRIHORD_VIP_
          if ( oValFunc.GetCurse(SpOrder.cVal, ordDPrice, Curse) )
#else
          if ( oValFunc.GetCurse(SpOrder.cVal, SklOrder.dOrd, Curse) )
#endif
            if ( Message('Пересчитать валютную цену исходя из цены в НДЕ?', YesNo+Confirmation) = cmYes )
              {
                set SpOrder.rVPrice := SpOrder.rSrPrice / Curse;
                set SpOrder.VPrice  := oSaldo_K.RoundValOrd(SpOrder.rVPrice, SpOrder.kol);
              }
            else
              if ( Message('Пересчитать цену в НДЕ исходя из валютной цены?', YesNo+Confirmation) = cmYes )
                {
                  set SpOrder.rSrPrice := SpOrder.rVPrice * Curse;
                  set SpOrder.SrPrice  := oSaldo_K.RoundRubOrd(SpOrder.rSrPrice, SpOrder.kol);
                }
      }

  oModifOrds.AnySpOrder_Update(TypeSpOrder(SpOrder.buffer));

  RescanPanel(#SpOrder);
  RescanPanel(#SklOrder);

  F_Change_Party := True;
}

//********************************************************************************

Procedure GetSaveDoc;
{
  var SavPar: comp = SpOrder.cParty;

  if ( SkPr = 1 ) //производство
    {
      if ( RunInterface( 'ViewOstMnf'
                       , SklOrder.cPodr
                       , SklOrder.cMOL
                       , SpOrder.cParty
                       , SpOrder.cMC
                       , SpOrder.dOrd
                       ) <> cmCancel )
        {}
    }
  else
    {
      var SavPar: comp = SpOrder.cParty;

      if ( RunInterface('GTekOstSkPr'
                       , SpOrder.cMC
                       , Comp(0)
                       , SklOrder.cPodr
                       , Comp(0)
                       , Comp(0)
                       , SpOrder.cParty
                       , IGetTekOstParBase(Self)
                       , (SkPr+1)
                       , 0
                       , SklOrder.cMOL
                       ) = cmCancel )
           exit;

      F_Change_Party(SavPar);

      if (  (boGetTune('Oper.RazrezCU')  and (SpOrder.SP <> cgVidUchO_UPL))
         or (boGetTune('Manuf.RazrezCU') and (SpOrder.SP  = cgVidUchO_UPL))
         )
        oVipMtrCount.MtrCheckDocs (coSpOrder, SpOrder.nRec, 0, true);

      oMtrFun.AdjustSpecMtrByKit(coSpOrder, SpOrder.nRec, pKitKau);

      if (  (boGetTune('Oper.RazrezCU')  and (SpOrder.SP <> cgVidUchO_UPL))
         or (boGetTune('Manuf.RazrezCU') and (SpOrder.SP  = cgVidUchO_UPL))
         )
      {
        if ( SklOrder.VidOrder = 1 )
          RecalcSrPricePosCU;

        oVipMtrCount.MtrCheckDocs (coSpOrder, SpOrder.nRec, 0, false);
      }

      ReReadRecord(#SpOrder);
    }
}

//********************************************************************************
Function CheckAllowMinusKol(_kolOrd : double) : boolean;
{
  CheckAllowMinusKol := True;
//сторно wadoc разрешать
  if (wGetTune('Sklad.AllowMinusKol') = 0) and (_kolOrd < 0)
  {
    ShowTune('Запрещено вводить отрицательное количество!','Sklad.AllowMinusKol');
    CheckAllowMinusKol := False;
  }
}

//********************************************************************************

Function CheckKatSoprOrders(_Sopr: Comp): boolean;
{
  Result := True;

  if (wGetTune('Sklad.NeedContrPrih') = 0)
  {
    if ( loCheckRashOrd.GetFirst SklOrder3 where ((_Sopr == SklOrder3.cSopr )) = tsOk )
      if ( Message('МЦ по данной накладной уже оприходованы.'#13 +
                   'Произвести оприходование заново?', YesNo+Confirmation+mfSwapButtons) = cmNo )
        Result := False;
  }
  else
    if ( RunInterface('GetSpSoprTo', loCheckRashOrd.cNewSopr_, SklOrder.cPodr, SklOrder.cMOL) = cmCancel )
      Result := False;
}

//********************************************************************************

Function F_SDocNumber: boolean;
{
  Result := False;

  case KatSopr.VidSopr of
  //------------------------------------------------------------------------------

    600 .. 607:  //накладные на внутреннее перемещение
         { RunInterface(SopInMov, KatSopr.VidSopr, KatSopr.nRec); Exit; }
  //------------------------------------------------------------------------------
  //------------------------------------------------------------------------------
    621         //(акт комплектации)
  , 622:        //(акт разукомплектации)
         { RunInterface(ActCompl, KatSopr.VidSopr, KatSopr.nRec); Exit; }
  //------------------------------------------------------------------------------
  end;

  if ( NOT UpdateTable )
    Exit;

  // переоценка - привязка акта на получение услуг
  if ( (SklOrder.vidOrder = 0 ) AND isDoocen )
    {
      loCheckRashOrd.cNewSopr_ := SklOrder.cSopr;

      if ( RunInterface('GetNakl', word(111), loCheckRashOrd.cNewSopr_) = cmCancel )
        Exit;

      set SklOrder.cSopr := loCheckRashOrd.cNewSopr_;
      Exit;
    }

  //для остальных
  var wt: word;  wt := SklOrder.tipOrd;

  if ( SklOrder.VidOrder = 0 ) // приход
    if ( SklOrder.TipOrd <> 1 )
      {
        Message('Данная версия позволяет формирование ордеров по накладным только по операциям с контрагентами.'#13
              + 'В остальных случаях необходимо воспользоваться соответствующим режимом...', Information);
        Exit;
      }

  loCheckRashOrd.cNewSopr_ := SklOrder.cSopr;

  if ( GetFirst SpOrder = tsOk )
  {
    if (SklOrder.cSopr <> 0) AND ( wGetTune('Oper.ModifyInClosePeriod') = 2 )
      if loCheckRashOrd.GetFirst KatSoprCheck where (( cNewSopr_ == KatSoprCheck.nRec )) = tsOk
        if (loCheckRashOrd.KatSoprCheck.dSopr <= dGetTune('Oper.DateClosePeriod'))
        {
          if ( Message('Данному ордеру соответствует документ закрытого периода.'#13 +
                       'Модификация документа запрещена настройкой.'#13 +
                       'В случае модификации ордера возникнет некорректная ситуация!!!'#13 +
                       'Продолжить?', YesNo+Confirmation+mfSwapButtons) <> cmYes )
            Exit;
        }

    if ( SklOrder.vidOrder = 0 ) // приход
      {
        if ( Message('В случае выбора накладной данный ордер будет удален.'#13 +
                     'Продолжить?', YesNo+Confirmation+mfSwapButtons) <> cmYes )
          Exit;
      }
    else
      {
        if ( Message('В случае выбора накладной спецификация ордера будет удалена.'#13+
                     'Продолжить?', YesNo+Confirmation+mfSwapButtons) <> cmYes )
          Exit;
      }
  }

  oChkSchem.RemoveDocFromSpSchem(SklOrder.nRec, GetSoprHozTipDoc(SkPr, SklOrder.VidOrder));

  if ( SklOrder.VidOrder = 0 ) // приход
    {
      if ( SklOrder.cPodr = 0 )
        if ( NOT GetSklad )
          Exit;

      if ( SklOrder.cMOL = 0 )
        if ( isAvtoMol )
          GetMol;

      loCheckRashOrd.cNewSopr_ := SklOrder.cSopr;

      external _LOOP SpOrder where ((SklOrder.nRec == SpOrder.cSklOrder))
      {
#ifdef _ZPRIHORD_VIP_
        loCheckRashOrd.SpOrder_nRec := SpOrder.nRec;
        loCheckRashOrd.delete SpDocSmeta where (( coSpOrder == SpDocSmeta.coTable and SpOrder_nRec == SpDocSmeta.cSpec ));
#end

#ifdef _RASHORD_VIP_
        loCheckRashOrd.SpOrder_nRec := SpOrder.nRec;
        loCheckRashOrd.delete SpDocSmeta where (( coSpOrder == SpDocSmeta.coTable and SpOrder_nRec == SpDocSmeta.cSpec ));
#end

        oModifOrds.AnySpOrder_Delete(TypeSpOrder(SpOrder.buffer));
      }

      if ( RunInterface('GetSoprTo', loCheckRashOrd.cNewSopr_, SklOrder.cPodr, SklOrder.cMOL) <> cmCancel )
        if ( CheckKatSoprOrders(loCheckRashOrd.cNewSopr_) )
          {
            StartNewVisual(vtRotateVisual, vfTimer, 'Формирование спецификации ордера', 1);

            NextVisual;

            var dCountKol : double;
            var pPodr     : comp;
            var pMOL      : comp;

            pPodr := SklOrder.cPodr;
            pMOL  := SklOrder.cMOL;

            if (oSoprOrdB.CheckSoprOrdB(loCheckRashOrd.cNewSopr_, 0, 0, True, False, False, False, 1, 0))
            {
              if (wGetTune('Sklad.NeedContrPrih') = 0)
              {
                loCheckRashOrd._LOOP SoprOrdb where (( cNewSopr_ == SoprOrdb.cSoprDoc AND
                                                       pPodr     == SoprOrdb.cPodr    AND
                                                       pMOL      == SoprOrdb.cMOL ))
                  {
                    if (not boGettune('Sklad.ArchivMC'))
                      if loCheckRashOrd.GetFirst KatMCAr where ((SoprOrdb.cMC == KatMCAr.nRec)) = tsOk
                        if (loCheckRashOrd.KatMCAr.IsArch = 1)
                        {
                          ShowTune('МЦ "' + loCheckRashOrd.KatMCAr.Name + '" находится в архиве!', 'Sklad.ArchivMC');
                          Continue;
                        }

                    ClearBuffer(#SpOrder);

                    SpOrderDefault;

                    SpOrder.cMC      := loCheckRashOrd.SoprOrdb.cMC;
                    SpOrder.cParty   := loCheckRashOrd.SoprOrdb.cParty;
                    SpOrder.cSpSopr  := loCheckRashOrd.SoprOrdb.cSpSopr;
                    SpOrder.kol      := loCheckRashOrd.SoprOrdb.kol;
                    SpOrder.rSrPrice := loCheckRashOrd.SoprOrdb.Price;
                    SpOrder.rVPrice  := loCheckRashOrd.SoprOrdb.vPrice;
                    SpOrder.cVal     := loCheckRashOrd.SoprOrdb.cVal;

                    if (loCheckRashOrd.SoprOrdB.cOtpEd <> 0)
                      {
                        SpOrder.kol      *= fEdIzm.GetKoefOtpEd(loCheckRashOrd.SoprOrdB.cOtpEd);
                        SpOrder.rSrPrice /= fEdIzm.GetKoefOtpEd(loCheckRashOrd.SoprOrdB.cOtpEd);
                        SpOrder.rVPrice  /= fEdIzm.GetKoefOtpEd(loCheckRashOrd.SoprOrdB.cOtpEd);
                      }


                    SpOrder.srPrice := oSaldo_K.RoundRubOrd(SpOrder.rSrPrice, SpOrder.kol);
                    SpOrder.vPrice  := oSaldo_K.RoundValOrd(SpOrder.rVPrice , SpOrder.kol);
                    SpOrder.Ostatok := SpOrder.kol;
                    SpOrder.OstatokN:= SpOrder.kol;

                    if (boGetTune('Oper.NalUch'))
                    {
                      if loCheckRashOrd.GetFirst SpSopr where ((SoprOrdb.cSpSopr == SpSopr.nRec)) = TsOk
                      {
                        SpOrder.priceN := loCheckRashOrd.SpSopr.priceN / fEdIzm.GetKoefOtpEd(loCheckRashOrd.SoprOrdB.cOtpEd);
                        SpOrder.SummN  := SpOrder.PriceN*if(f_KolIsZero(SpOrder.Kol), 1.0, SpOrder.Kol);
                        SpOrder.SummN  := oSaldo_K.RoundRubOrd(SpOrder.PriceN, if(f_KolIsZero(SpOrder.Kol), 1.0, SpOrder.Kol))*if(f_KolIsZero(SpOrder.Kol), 1.0, SpOrder.Kol);
                      }
                    }

                    if (not oModifOrds.Check_wasSpisOrder(SpOrder.cMC, SpOrder.cParty, SklOrder.cPodr, SklOrder.cMol, 0, SkPr, SklOrder.dOrd, 1+ SklOrder.VidOrder))
                      and (CheckAllowMinusKol(SpOrder.kol))
                    {
                      oModifOrds.AnySpOrder_Insert(TypeSpOrder(SpOrder.buffer));
                      oMTRFun.CopySpecMTR(coSpSopr, loCheckRashOrd.SpSopr.nRec, coSpOrder, SpOrder.NRec);
                      oSerialMove.MoveSerial(SpOrder.nRec, True, False);
                    }
                    else
                      ReReadRecord(#SpOrder);
                  }
              }
              else
              {
                var pRec: comp;

                _Loop Pick where ((word(51) == Pick.wList))
                  {
                    pRec := Pick.cRec;

                    if loCheckRashOrd.GetFirst SoprOrdb where (( pRec == SoprOrdB.nRec )) <> tsOk
                      Continue;

                    dCountKol := 0;

                    loCheckRashOrd._Loop SklOrder3 where ((cNewSopr_ == SklOrder3.cSopr ))
                    {
                      if (loCheckRashOrd.SklOrder3.cPodr <> loCheckRashOrd.SoprOrdB.cPodr) OR (loCheckRashOrd.SklOrder3.cMOL <> loCheckRashOrd.SoprOrdB.cMOL)
                        Continue;

                      loCheckRashOrd._Loop SpOrder2 where (( SklOrder3.nRec == SpOrder2.cSklOrder))
                        if (loCheckRashOrd.SpOrder2.cSpSopr = loCheckRashOrd.SoprOrdb.cSpSopr)
                          dCountKol += loCheckRashOrd.SpOrder2.Kol;
                    }

                    if ((loCheckRashOrd.SoprOrdB.kol * fEdIzm.GetKoefOtpEd(loCheckRashOrd.SoprOrdB.cOtpEd) - dCountKol) <= 0)
                      Continue;

                    if (not boGettune('Sklad.ArchivMC'))
                      if loCheckRashOrd.GetFirst KatMCAr where ((SoprOrdb.cMC == KatMCAr.nRec)) = tsOk
                        if (loCheckRashOrd.KatMCAr.IsArch = 1)
                        {
                          ShowTune('МЦ "' + loCheckRashOrd.KatMCAr.Name + '" находится в архиве!', 'Sklad.ArchivMC');
                          Continue;
                        }

                    ClearBuffer(#SpOrder);

                    SpOrderDefault;

                    SpOrder.cMC      := loCheckRashOrd.SoprOrdb.cMC;
                    SpOrder.cParty   := loCheckRashOrd.SoprOrdb.cParty;
                    SpOrder.cSpSopr  := loCheckRashOrd.SoprOrdb.cSpSopr;
                    SpOrder.kol      := loCheckRashOrd.SoprOrdb.kol;
                    SpOrder.rSrPrice := loCheckRashOrd.SoprOrdb.Price;
                    SpOrder.rVPrice  := loCheckRashOrd.SoprOrdb.vPrice;
                    SpOrder.cVal     := loCheckRashOrd.SoprOrdb.cVal;

                    if (SoprOrdB.cOtpEd <> 0)
                      {
                        SpOrder.kol      *= fEdIzm.GetKoefOtpEd(loCheckRashOrd.SoprOrdB.cOtpEd);
                        SpOrder.rSrPrice /= fEdIzm.GetKoefOtpEd(loCheckRashOrd.SoprOrdB.cOtpEd);
                        SpOrder.rVPrice  /= fEdIzm.GetKoefOtpEd(loCheckRashOrd.SoprOrdB.cOtpEd);
                      }

                    SpOrder.kol      -= dCountKol;
                    SpOrder.srPrice  := oSaldo_K.RoundRubOrd(SpOrder.rSrPrice, SpOrder.kol);
                    SpOrder.vPrice   := oSaldo_K.RoundValOrd(SpOrder.rVPrice , SpOrder.kol);
                    SpOrder.Ostatok  := SpOrder.kol;
                    SpOrder.OstatokN := SpOrder.kol;

                    if (boGetTune('Oper.NalUch'))
                    {
                      if loCheckRashOrd.GetFirst SpSopr where ((SoprOrdb.cSpSopr == SpSopr.nRec)) = TsOk
                      {
                        SpOrder.priceN := loCheckRashOrd.SpSopr.priceN / fEdIzm.GetKoefOtpEd(loCheckRashOrd.SoprOrdB.cOtpEd);
                        SpOrder.SummN  := SpOrder.PriceN*if(f_KolIsZero(SpOrder.Kol), 1.0, SpOrder.Kol);
                        SpOrder.SummN  := oSaldo_K.RoundRubOrd(SpOrder.PriceN, if(f_KolIsZero(SpOrder.Kol), 1.0, SpOrder.Kol))*if(f_KolIsZero(SpOrder.Kol), 1.0, SpOrder.Kol);
                      }
                    }

                    if (not oModifOrds.Check_wasSpisOrder(SpOrder.cMC, SpOrder.cParty, SklOrder.cPodr, SklOrder.cMol, 0, SkPr, SklOrder.dOrd, 1 + SklOrder.VidOrder))
                      and (CheckAllowMinusKol(SpOrder.kol))
                    {
                      oModifOrds.AnySpOrder_Insert(TypeSpOrder(SpOrder.buffer));
                      oMTRFun.CopySpecMTR(coSpSopr, loCheckRashOrd.SpSopr.nRec, coSpOrder, SpOrder.NRec);
                      oSerialMove.MoveSerial(SpOrder.nRec, True, False);
                    }
                    else
                      ReReadRecord(#SpOrder);
                  }
              }

              if GetFirst SpOrder where ((SklOrder.nRec == SpOrder.cSklOrder)) <> tsOk
                {
                  set SklOrder.cSopr := 0;
                  Message('Выбранная накладная распределена на другие разрезы хранения.'#13'Ордер не сформирован');
                }
              else
                set SklOrder.cSopr := loCheckRashOrd.cNewSopr_;

              Update current SklOrder;
            }

            StopVisual('', 0);
          }
    }
  else // расход
    {
      var cOldSopr: comp;  cOldSopr := SklOrder.cSopr;
      if ( RunInterface('GetSoprFrom', SklOrder.cSopr, wt, SklOrder.cPodr) <> cmCancel )
        {
          Update current SklOrder; //сохраняем SklOrder.cSopr

          if ( GetCurPodr <> 0 )
            {
              Message('Установлено текущее подразделение.'#13'Для выбора другого уберите в Настройке текущее', confirmation);
              SklOrder.cPodr := GetCurPodr;
            }
          else
            if ( SklOrder.cPodr = 0 )
              {
                var prSk: word;  prSk := if(SkPr = 0, 1, 4);

                if ( RunInterface(GetAnyPodr, SklOrder.cPodr, (08000h OR prSk)) = cmCancel )
                  Exit;
              }

          DeleteOrder(False);

          var n1: SoprDocObj;
          GetVipRef(n1, 'SoprDoc');

          n1.MakeOrder2(SklOrder.cSopr, SklOrder.nRec);

          if ( cOldSopr <> SklOrder.cSopr )
            if ( GetFirst KatSopr where ((cOldSopr == KatSopr.nRec)) = tsOk )
              {
                KatSopr.dOpr := ZeroDate;

                if ( Update current KatSopr = tsOk )
                  Update SpSopr where ((KatSopr.nRec == SpSopr.cSopr))
                    set SpSopr.dOprTTN := ZeroDate;
             }
        }
    }

  OrdScan;

  if ( GetFirst KatSopr where ((SklOrder.cSopr == KatSopr.nRec)) = tsOk )
    {
      iKB.SaveInfoforBal(KatSopr.VidSopr, KatSopr.nRec);

      KatSopr.dOpr := SklOrder.dOrd;
      Update current KatSopr;

      Update SpSopr where ((KatSopr.nRec == SpSopr.cSopr))
           set SpSopr.dOprTTN := KatSopr.dOpr;

      oChkSchem.CheckSchem(KatSopr.nRec
                         , KatSopr.VidSopr
                         , SklOrder.nRec
                         , GetSoprHozTipDoc(SkPr, SklOrder.VidOrder)
                         , True
                         );

      iKB.ModiKontrBal(KatSopr.VidSopr, KatSopr.nRec);
    }

  RereadRecord(#SklOrder);
  RescanPanel(#SpOrder);
  RedrawPanel(#SpOrder);

  SetModified(True);

  Result := True;
}

// Просмотр штрих-кода при запрете редактирования документа
Procedure ViewBarKodAndState;
{
  case CurField of
  #ifdef _ZPRIHORD_VIP_
    #PickBarKodAndState(GetSoprHozTipDoc(SkPr, SklOrder.VidOrder), SklOrder.nRec, m_sCurrentBarKod, True)
  #end
  #ifdef _RASHORD_VIP_
    #PickBarKodAndState(GetSoprHozTipDoc(SkPr, SklOrder.VidOrder), SklOrder.nRec, m_sCurrentBarKod, True)
  #end
  end; // case CurField of
}

//********************************************************************************
//---------------------------Обработка событий----------------------------
//

Function F_SklOrder_Pick: boolean;
{
  Result := False;

  if ( IsProtected(#SklOrder) )
    {
      ViewBarKodAndState;
      Exit;
    }

#ifdef _USE_SERIAL_
  if ( (CurField = #KatPodr.Name) or (CurField = #KatMOL.Name) )
    if ( not oSerialMove.CanChangeRzOrder(SklOrder.nRec) )
      {
        Message('В ордере введены серийные номера. Изменить разрез невозможно.');
        Exit;
      }
#end

  if ( NOT CanEditOrderWithRash(True) )
    {
      ViewBarKodAndState;
      Exit;
    }

  if ( SklOrder.VidOrder = 1 ) // расход
  {
    if (
         (oMSview.GetTuneMSForPodr(SklOrder.cPodr) = 1)
       or
         (IsLifoFifoNU)
       or
         (IsLifoFifo AND (SklOrder.TipOrd <> 3))
       )
      {
        ShowTune('Изменение ордера при данной методике списания запрещено'#13'См. также методику списания по подразделению', 'Oper.L_F');
        ViewBarKodAndState;
        Exit;
      }

    if (IsValid(#SpOrder))
      if (wGetTune('Sklad.ContrSpisRashOrd') <> 0)
      {
        if (CurField = #SklOrder.dOrd)
        {
          ShowTune('Нельзя изменить дату ордера при наличии спецификации!', 'Sklad.ContrSpisRashOrd');
          ViewBarKodAndState;
          Exit;
        }

        if (CurField = #KatPodr.Name) OR (CurField = #KatMOL.Name)
        {
          ShowTune('Нельзя изменить разрез списания при наличии спецификации!', 'Sklad.ContrSpisRashOrd');
          ViewBarKodAndState;
          Exit;
        }
      }
  }

  var OldDes: string;

  case CurField of
  //------------------------------------------------------------------------------
    #SklOrder.dOrd:
      set SklOrder.dOrd := Cur_Date;
  //------------------------------------------------------------------------------
    #SklOrder.Descr:
      {
        OldDes := SklOrder.Descr;
        if ( RunInterface('GetDescrEx', SklOrder.Descr, SklOrder.DesGr, word(0), word(2)) <> cmCancel )
          if ( OldDes <> SklOrder.Descr )
            UpdateSpOrderDes;
      }
  //------------------------------------------------------------------------------
    #SklOrder.DesGr:
      {
        OldDes := SklOrder.DesGr;
        if ( RunInterface('GetGrDescr', SklOrder.DesGr, False, False, comp(0)) <> cmCancel )
          if ( OldDes <> SklOrder.DesGr )
            UpdateSpOrderDes;
      }
  //------------------------------------------------------------------------------
    #SDocNumber:
      F_SDocNumber;
  //------------------------------------------------------------------------------
    #KatPodr.Name:
      {
        if GetSklad
          if SklOrder.cMOL = 0 AND SklOrder.vidOrder = 0 AND boGetTune('Oper.NeedMOL')
            GetMol;
      }
  //------------------------------------------------------------------------------
    #KatMOL.Name:
      GetMol;
  //------------------------------------------------------------------------------
  #ifndef __ListSkl_vip__
  #ifndef _KartStor_VIP_
    #HozOperViewName :
      {
        if ( UpDateTable )
        {
          var tmpVidOrd: word;
          tmpVidOrd := GetSoprHozTipDoc(SklOrder.SP, SklOrder.vidOrder);

          if NOT oCCOIO.CanChangeOborot(tmpVidOrd, SklOrder.nRec)
            Exit;

          iTxoBind.ResetServer;
          iShoz.CheckMagOper(#TSoprHozX(SoprHoz.BufferP), integer(1));

          if ( iTxoBind.BuildTree(SoprHoz.BufferP) )
           if ( iTxoBind.Bind(SoprHoz.BufferP, 0) )
            if ( iTxoBind.RealizeOperationsTree(SoprHoz.BufferP) )
                iTxoBind.Apply(SoprHoz.BufferP);

          iTxoBind.ProcessProtokol;
          ReReadRecord;
        }
      }
   #end
   #end
  //------------------------------------------------------------------------------
  #ifdef _ZPRIHORD_VIP_
    #PickBarKodAndState(GetSoprHozTipDoc(SkPr, SklOrder.VidOrder), SklOrder.nRec, m_sCurrentBarKod, False)
  #end
  #ifdef _RASHORD_VIP_
    #PickBarKodAndState(GetSoprHozTipDoc(SkPr, SklOrder.VidOrder), SklOrder.nRec, m_sCurrentBarKod, False)
  #end
  end; // case CurField of

  Result := True;
} // Function F_SklOrder_Pick

//********************************************************************************

#include ModSaldoMtr.vpp // Пересчет сальдовых остатков в разрезе объектов целевого назначения запасов МТР

//********************************************************************************
// Целевой учет для позиции спецификации

#ifdef _LINKMTR2SPEC_

#include lm2sAutoPick.vpp // Номер текущей аналитики (GetLinkMTRAutoPick)

Procedure DoLinkMtrSpec(awAction: word);
{
  if ( CurTable = #SpOrder )
    if ( UpdateTable )
      if( IsValid(#SpOrder) )
      {
        if ((not IsValid(#SpecMTR)) and (  ((boGetTune('Oper.RazrezCU')) and (SpOrder.SP <> cgVidUchO_UPL))
                                        or ((boGetTune('Manuf.RazrezCU')) and (SpOrder.SP = cgVidUchO_UPL))
                                        ))
          oVipMtrCount.MtrCheckDocs (coSpOrder, SpOrder.nRec, 0, true);

        var wPrView_Edit : word;
        wPrView_Edit := cgPr_Auto;

       if (Check_BackDate) or (NOT boGetTune('Doc.ModOrder')) or
         (NOT fCloseBuhPer(SklOrder.nRec, SklOrder.VidOrder, SklOrder.SP, False)) or
         ((wGetTune('Sklad.ModHaveProvod') = 0) and (ExistsAnyOborotSklOrder(SklOrder.Nrec))) or
         ((wGetTune('Sklad.ModHaveProvodDoc') = 0) and (ExistsAnyOborotSklOrderDoc(SklOrder.cSopr)))
         wPrView_Edit := cgPr_View;

        RunInterface('EditMtr2Spec_2', coSpOrder, SpOrder.nRec, wPrView_Edit, awAction, GetLinkMTRAutoPick(CurField));

        RereadRecord(#SpOrder);

        if (  ((boGetTune('Oper.RazrezCU')) and (SpOrder.SP <> cgVidUchO_UPL))
           or ((boGetTune('Manuf.RazrezCU')) and (SpOrder.SP = cgVidUchO_UPL))
           )
        {
          if ( SklOrder.VidOrder = 1 )
          {
            RecalcSrPricePosCU;
            oVipMtrCount.MtrCheckDocs (coSpOrder, SpOrder.nRec, 0, false);
          }
          else
           if (not IsValid(#SpecMTR))
             oVipMtrCount.MtrCheckDocs (coSpOrder, SpOrder.nRec, 0, false);
        }
      }
}

#end

//********************************************************************************
Function F_SpOrder_Pick_New(FlagCtrlF3 : boolean): boolean;
var
  Nal : double;
  wTunePick : word;
  dSrPrice, dvPrice : double;
  _cVal : comp;
{
  dSrPrice := dvPrice := 0;
  _cVal := 0;

  Result := False;

  if ( IsProtected(#SklOrder) )
    Exit;

  if ( IsProtected(#SpOrder) )
    Exit;

  if ( NOT CanEditOrderWithRash(True) )
    Exit;

  if (not FlagCtrlF3)
  {
    if ( SklOrder.vidOrder = 1 )
      wTunePick := wGetTune('Sklad.PickF3SpisOrd');
    else
      wTunePick := 0;
  }
  else
    wTunePick := wGetTune('Sklad.PickCtrlF3SpisOrd');

  case CurField of
  //------------------------------------------------------------------------------
    #KatMC.Name,
    #KatMC.BarKod:
      {
        if ( IsNew ) // создана новая запись
          {
            case wTunePick of
              0:
              {
                if ( SklOrder.vidOrder = 0 )
                  StartNewVisual(vtNumericVisual, vfTimer+vfBreak+vfConfirm, 'Добавляются выбранные МЦ...', 1);

                PushPos(#SpOrder);

                if ( RunInterface('GetSomeMC', if( NOT isDoocen, comp(0), comp(-12345)), 1 ) <> cmCancel )
                  if ( GetFirst Pick where ((Word(7) == Pick.wList)) ordered by index Pick02 = tsOk )
                    {
                      _LOOP Pick where ((Word(7) == Pick.wList)) ordered by index Pick02
                        {
                          if ( GetFirst KatMC where (( Pick.cRec == KatMC.nRec )) = tsOk )
                            {}

                          if ( NOT canEditBackDate) AND
                             ( oModifOrds.IsOstOnMSPrPer(True, SkPr, 0, SklOrder.cPodr, SklOrder.dOrd))
                            {
                              ShowTune('В настройке установлен запрет модификации ордеров в закрытом периоде!',
                                        if (SkPr = cgVidUchO_UKS, 'UKS.Doc.ModOrder',
                                        if (SkPr = cgVidUchO_UPL, 'Manuf.ModOrder',
                                                                  'McUsl.ModOrder'
                                      )));
                              SklOrder.dOrd := Cur_Date;
                            }
                          else
                            {
                              if (not boGettune('Sklad.ArchivMC'))
                                if (KatMC.IsArch = 1)
                                {
                                  ShowTune('МЦ "' + KatMC.Name + '" находится в архиве!', 'Sklad.ArchivMC');
                                  Continue;
                                }

                              fEdIzm.CheckKolDiskretAll( Pick.PickKol, fEdIzm.GetUchOtpEdNRec(KatMC.nRec, 1), KatMC.cEd, True, True );

                              var kol_    : double = SpOrder.kol;
                              var price_  : double = SpOrder.srPrice;
                              var vprice_ : double = SpOrder.vPrice;
                              var cval_   : comp   = SpOrder.cVal;

                              SpOrderDefault;

                              SpOrder.cMC     := Pick.cRec;

                              if (isDoocen)
                                SpOrder.Kol   := 0;
                              else
                                SpOrder.kol   := if(Pick.pickKol<> 0, Pick.pickKol, kol_);

                              SpOrder.srPrice := price_;
                              SpOrder.vPrice  := vprice_;
                              SpOrder.cVal    := cval_;

                              if (IsLifoFifoNU)
                                SpOrder.OstatokN := SpOrder.Kol;

                              if ( IsLifoFifo OR (oMSview.GetTuneMSForPodr(SpOrder.ccPodr) <> 0) ) //для LIFO/FIFO
                                {
                                  if (not isDoocen)
                                    if ( SpOrder.Kol = 0 )
                                      SpOrder.Kol := 1.0;

                                  SpOrder.Ostatok := SpOrder.Kol;
                                  SpOrder.Empty   := oSaldo_K.LoSetSpOrder_Empty( SpOrder.TipOrd
                                                                                , SpOrder.VidOrder
                                                                                , SpOrder.Ostatok
                                                                                , SpOrder.cSpSopr
                                                                                , SpOrder.ccPodr
                                                                                );
                                }

                              Counts++;

                              if ( SklOrder.VidOrder = 1 )
                                RecalcSrPricePos(False);

                              if (not oModifOrds.Check_wasSpisOrder(SpOrder.cMC, SpOrder.cParty, SklOrder.cPodr, SklOrder.cMol, 0, SkPr, SklOrder.dOrd, 1+ SklOrder.VidOrder))
                                and (CheckAllowMinusKol(SpOrder.kol))
                                oModifOrds.AnySpOrder_Insert(TypeSpOrder(SpOrder.buffer));
                              else
                                ReReadRecord(#SpOrder);
                            }
#ifdef _LINKMTR2SPEC_
                          oLinkMTR2Spec.SelFormat(True);
#end
                        }
                    }
              }
              1:
              {
                PushPos(#SpOrder);

                if (RunInterface('GetTekSaldoParty',
                         True,     //- групповой выбор
                         True,     //- давать вводить кол-во
                         False,    //- давать возможность выбирать МЦ без тек. ост.
                         word(0),  //- только для ед. выбора
                         SklOrder.cPodr,    //- по подразделению
                         SklOrder.cMol,     //- по МОЛ
                         comp(0),           //- по МЦ
                         comp(0),           //- по Партии
                         comp(0),           //- по Объекту стр.
                         DOUBLE(0),         //- кол-во для одиночного выбора
                         word(2),           //- разрез менять можно только по МЦ
                         1,                 //- Используемый разрез (0-TekSaldo; 1-SaldoObj; 100-любой)
                         0,                 //- доп. режимы для работы с разрезом по Объектам
                         SklOrder.dOrd,     //- дата для расчета наличия
                         SklOrder.SP,       //- вид учета (cgVidUchO_Sklad - склад, cgVidUchO_UPL - производство, ...)
                         comp(0),           //- объект строительства в шапке АВР
                         comp(0)            //- целевой учет
                         ) = cmDefault )
                {
                  //-------идентификаторы Маркеров--------------------------------------------
                  var  MarkerTekSaldo_Gtsp_       : TPtr;     // Маркеры для хранения выбора по Партиям
                  var  MarkerKolTekSaldo_Gtsp_    : TPtr;     //
                  var  MarkerCount_Gtsp_          : longint;
                  var  MarkerTekSaldo_Gtsp_MC_    : TPtr;     // Маркеры для хранения выбранных МЦ без тек. ост.
                  var  MarkerKolTekSaldo_Gtsp_MC_ : TPtr;     //
                  var  MarkerCount_Gtsp_MC_       : longint;
                  var  Marker_Gtsp_Obj            : TPtr;     // Маркеры для хранения выбора по Объектам стр.
                  var  MarkerKol_Gtsp_Obj         : TPtr;     //
                  var  MarkerCount_Gtsp_Obj       : longint;
                  var  MarkerSerialN_Gtsp_        : TPtr;     // Маркеры для хранения выбора по серийным номерам
                  var  MarkerCount_SerialN        : longint;
                  //-------------------------------
                  var  i_Gtsp_, i_Gtsp_1, ii      : longint;
                  var  PickRec_Gtsp_              : comp;
                  var  PickSerialN                : comp;
                  var  PickKol_Gtsp_              : double;

                  //---Инициализация Маркеров
                  Marker_Gtsp_Obj            := InitMarker ('GTSPC_MarkerTekSaldoObj'         ,8,100,10,False);
                  MarkerKol_Gtsp_Obj         := InitMarker ('GTSPC_MarkerKolTekSaldoObj'      ,8,100,10,False);
                  MarkerCount_Gtsp_Obj       := GetMarkerCount(Marker_Gtsp_Obj);
                  MarkerTekSaldo_Gtsp_       := InitMarker ('GTSPC_MarkerTekSaldoObj_Non'     ,8,100,10,False);
                  MarkerKolTekSaldo_Gtsp_    := InitMarker ('GTSPC_MarkerKolTekSaldoObj_Non'  ,8,100,10,False);
                  MarkerCount_Gtsp_          := GetMarkerCount(MarkerTekSaldo_Gtsp_);

                  MarkerTekSaldo_Gtsp_MC_    := InitMarker ('GTSPC_MarkerTekSaldo_MCNonOst'   ,8,100,10,False);
                  MarkerKolTekSaldo_Gtsp_MC_ := InitMarker ('GTSPC_MarkerKolTekSaldo_MCNonOst',8,100,10,False);
                  MarkerCount_Gtsp_MC_       := GetMarkerCount(MarkerTekSaldo_Gtsp_MC_);

                  MarkerSerialN_Gtsp_        := InitMarker ('GTSPC_MarkerSerialN'             ,8,100,10,False);
                  MarkerCount_SerialN        := GetMarkerCount(MarkerSerialN_Gtsp_);

                  for (i_Gtsp_:=0; i_Gtsp_<=MarkerCount_Gtsp_Obj; i_Gtsp_++)
                  {
                    if (GetMarker(Marker_Gtsp_Obj   ,i_Gtsp_,PickRec_Gtsp_) and
                        GetMarker(MarkerKol_Gtsp_Obj,i_Gtsp_,PickKol_Gtsp_))
                    {
                      if ( loCheckRashOrd.GetFirst SaldoObj Where (( PickRec_Gtsp_ == SaldoObj.nRec )) = tsOK )
                      {
                        if (not boGettune('Sklad.ArchivMC'))
                          if loCheckRashOrd.GetFirst KatMCAr where ((SaldoObj.cMC == KatMCAr.nRec)) = tsOk
                            if (loCheckRashOrd.KatMCAr.IsArch = 1)
                            {
                              ShowTune('МЦ "' + loCheckRashOrd.KatMCAr.Name + '" находится в архиве!', 'Sklad.ArchivMC');
                              Continue;
                            }

                        var dkol_ : double = if(PickKol_Gtsp_ <> 0, PickKol_Gtsp_, SpOrder.kol);

                        Nal := 0;

                        if (Abs(dKol_) >= GetPresision_forKol) // нулевое количество
                          Nal := CheckNalNastr(SklOrder.dOrd, loCheckRashOrd.SaldoObj.cMC, SklOrder.cPodr, SklOrder.cMol, loCheckRashOrd.SaldoObj.cParty, True);

                        if (Nal < dkol_) AND ( SklOrder.VidOrder = 1 )
                        {
                          if (wGetTune('Sklad.ContrSpisRashOrd') = 0)
                          {
                            SpOrderDefault;
                            SpOrder.kol := PickKol_Gtsp_;
                          }
                          else
                          {
                            if (Abs(Nal) >= GetPresision_forKol)
                            {
                              SpOrderDefault;
                              SpOrder.kol := Nal;
                            }
                            else
                              Continue;
                          }
                        }
                        else
                        {
                          SpOrderDefault;

                          if (isDoocen)
                            SpOrder.kol := 0;
                          else
                            SpOrder.kol := dKol_;
                        }

                        if (wGetTune('Sklad.ContrSpisRashOrd') = 0) OR ( SklOrder.VidOrder = 0 )
                        {
                          SpOrderDefault;

                          if (isDoocen)
                            SpOrder.Kol := 0;
                          else
                            SpOrder.kol := PickKol_Gtsp_;
                        }

                        SpOrder.cMC    := loCheckRashOrd.SaldoObj.cMC;
                        SpOrder.cParty := loCheckRashOrd.SaldoObj.cParty;

                        if (  (SklOrder.VidOrder = 0)
                           or ((not boGetTune('Oper.RazrezCU' )) and (SpOrder.SP <> cgVidUchO_UPL))
                           or ((not boGetTune('Manuf.RazrezCU')) and (SpOrder.SP  = cgVidUchO_UPL))
                           )
                        {
                          InitMCInfo(SklOrder.dOrd);
                          LockValOt(True);
                          SkladProizv(SKlOrder.SP);
                          SpOrder.cVal   := StepMCInfo(loCheckRashOrd.SaldoObj.cMC, SpOrder.cVal,
                                                       if (SklOrder.cPodr = 0, comp(-1), SklOrder.cPodr),
                                                       if (SklOrder.cMOL  = 0, comp(-1), SklOrder.cMOL),
                                                       if (SpOrder.cParty = 0, comp(-1), SpOrder.cParty));

                          SpOrder.srPrice := AveragePrice;
                          SpOrder.VPrice  := AverageVPrice;
                          DoneMCInfo;
                        }

                        if (IsLifoFifoNU)
                          SpOrder.OstatokN := SpOrder.Kol;

                        if ( IsLifoFifo OR (oMSview.GetTuneMSForPodr(SpOrder.ccPodr) <> 0) ) //для LIFO/FIFO
                        {
                          if (not isDoocen)
                            if ( SpOrder.Kol = 0 )
                              SpOrder.Kol := 1.0;

                          SpOrder.Ostatok := SpOrder.Kol;
                          SpOrder.Empty   := oSaldo_K.LoSetSpOrder_Empty( SpOrder.TipOrd
                                                                        , SpOrder.VidOrder
                                                                        , SpOrder.Ostatok
                                                                        , SpOrder.cSpSopr
                                                                        , SpOrder.ccPodr
                                                                        );
                        }

                        if (not oModifOrds.Check_wasSpisOrder(SpOrder.cMC, SpOrder.cParty, SklOrder.cPodr, SklOrder.cMol, 0, SkPr, SklOrder.dOrd, 1+ SklOrder.VidOrder))
                          and (CheckAllowMinusKol(SpOrder.kol))
                        {
                          Counts++;
                          if (  (SklOrder.VidOrder = 0)
                             or ((not boGetTune('Oper.RazrezCU')) and (SpOrder.SP <> cgVidUchO_UPL))
                             or ((not boGetTune('Manuf.RazrezCU')) and (SpOrder.SP = cgVidUchO_UPL))
                             )
                            oModifOrds.AnySpOrder_Insert(TypeSpOrder(SpOrder.buffer));

                         oMTRFun.InsSpecMTR_Kit(coSpOrder, SpOrder.nRec, loCheckRashOrd.SaldoObj.cKitKau);

                          if ((SklOrder.VidOrder = 1) and (  ((boGetTune('Oper.RazrezCU')) and (SpOrder.SP <> cgVidUchO_UPL))
                                                          or ((boGetTune('Manuf.RazrezCU')) and (SpOrder.SP = cgVidUchO_UPL))
                                                          ))
                          {
                            if (GetFirst SpecMTR = tsOk)
                               oSald.CountPriceCU(SklOrder.dOrd, SkPr, SpecMTR.cSaldTune,
                                                SpecMTR.cObj, SpecMTR.cKau[1], SpecMTR.cKau[2], SpecMTR.cKau[3], SpecMTR.cKau[4], SpecMTR.cKau[5],
                                                SpecMTR.cKau[6], SpecMTR.cKau[7], SpecMTR.cKau[8], SpecMTR.cKau[9], SpOrder.cMC, SklOrder.cPodr, SklOrder.cMol, SpOrder.cParty,
                                                dSrPrice, dvPrice, dKol, _cVal );
                            else
                              oSald.CountPriceCU(SklOrder.dOrd, SkPr, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, SpOrder.cMC, SklOrder.cPodr, SklOrder.cMol, SpOrder.cParty,
                                                dSrPrice, dvPrice, dKol, _cVal );

                            SpOrder.srPrice := dSrPrice;
                            SpOrder.VPrice  := dvPrice;
                            SpOrder.cVal    := _cVal;
                            oModifOrds.AnySpOrder_Insert(TypeSpOrder(SpOrder.buffer));
                          }
                        }
                        else
                          ReReadRecord(#SpOrder);

                         if ( SklOrder.VidOrder = 1 )
                         {
                           loCheckRashOrd.SpOrdercMC := SpOrder.cMC;
                           if loCheckRashOrd.GetFirst KatMC where (( SpOrdercMC == KatMC.nRec)) = tsOk
                             if (loCheckRashOrd.KatMC.wSerialReg <> 0)
                               for (i_Gtsp_1 := 0; i_Gtsp_1 <= MarkerCount_SerialN; i_Gtsp_1++)
                                 if (GetMarker(MarkerSerialN_Gtsp_, i_Gtsp_1, PickSerialN))
                                   if (GetFirst CardSN where ((PickSerialN == CardSN.nRec)) = tsOk)
                                     if (CardSN.cMC   = SpOrder.cMC   ) and (CardSN.cParty = SpOrder.cParty) and
                                        (CardSN.cPodr = SklOrder.cPodr) and (CardSN.cMOL   = SklOrder.cMOL)
                                     {
                                       ii := 0;
                                       _LOOP SpCardSN where ((SpOrder.nRec == SpCardSN.cSpOrd))
                                         ii++;

                                       if (ii >= SpOrder.Kol)
                                         Break;

                                       if (CardSN.Status <> 7) and (CardSN.Status <> 3) and (CardSN.Status <> 9)
                                       {
                                         insert SpCardSN set SpCardSN.cCardSN := CardSN.nRec
                                              , SpCardSN.cSpOrd  := SpOrder.nRec
                                              , SpCardSN.dOrd    := SpOrder.dOrd
                                              , SpCardSN.nOrder  := SklOrder.nOrder;

                                         oSerialMove.UpdateSerialHistory(SpCardSN.cCardSN);

                                         update CardSN where (( SpCardSN.cCardSN == CardSN.nRec ))
                                           set CardSN.TipObjRes := 0
                                             , CardSN.cObjRes   := 0;
                                       }
                                     }
                         }
                      }
                    }
                  }

                  for (i_Gtsp_:=0;i_Gtsp_<=MarkerCount_Gtsp_;i_Gtsp_++)
                  {
                    if (GetMarker(MarkerTekSaldo_Gtsp_,i_Gtsp_,PickRec_Gtsp_) and
                             GetMarker(MarkerKolTekSaldo_Gtsp_,i_Gtsp_,PickKol_Gtsp_))
                    {
                      if ( GetFirst TekSaldo Where (( PickRec_Gtsp_ == TekSaldo.nRec )) = tsOK )
                      {
                        if (not boGettune('Sklad.ArchivMC'))
                        {
                          loCheckRashOrd._cMC := TekSaldo.cMC;
                          if loCheckRashOrd.GetFirst KatMCAr where ((_cMC == KatMCAr.nRec)) = tsOk
                            if (loCheckRashOrd.KatMCAr.IsArch = 1)
                            {
                              ShowTune('МЦ "' + loCheckRashOrd.KatMCAr.Name + '" находится в архиве!', 'Sklad.ArchivMC');
                              Continue;
                            }
                        }

                        var dkol_ : double = if(PickKol_Gtsp_ <> 0, PickKol_Gtsp_, SpOrder.kol);

                        Nal := 0;

                        if (Abs(dKol_) >= GetPresision_forKol) // нулевое количество
                          Nal := CheckNalNastr(SklOrder.dOrd, TekSaldo.cMC, SklOrder.cPodr, SklOrder.cMol, TekSaldo.cParty, True);

                        if (Nal < dkol_) AND ( SklOrder.VidOrder = 1 )
                        {
                          if (wGetTune('Sklad.ContrSpisRashOrd') = 0)
                          {
                            SpOrderDefault;
                            SpOrder.kol := loCheckRashOrd.PickRep.PickKol;
                          }
                          else
                          {
                            if (Abs(Nal) >= GetPresision_forKol)
                            {
                              SpOrderDefault;
                              SpOrder.kol := Nal;
                            }
                            else
                              Continue;
                          }
                        }
                        else
                        {
                          SpOrderDefault;
                          if (isDoocen)
                            SpOrder.Kol := 0;
                          else
                            SpOrder.kol := dKol_;
                        }

                        if (wGetTune('Sklad.ContrSpisRashOrd') = 0) OR ( SklOrder.VidOrder = 0 )
                        {
                          SpOrderDefault;
                          if (isDoocen)
                            SpOrder.Kol := 0;
                          else
                            SpOrder.kol := PickKol_Gtsp_;
                        }

                       SpOrder.cMC    := TekSaldo.cMC;
                       SpOrder.cParty := TekSaldo.cParty;

                       GetPriceRazrezOrder(TekSaldo.cMC, SklOrder.cPodr, SklOrder.cMOL, SpOrder.cParty, True);

                       if (IsLifoFifoNU)
                         SpOrder.OstatokN := SpOrder.Kol;

                       if ( IsLifoFifo OR (oMSview.GetTuneMSForPodr(SpOrder.ccPodr) <> 0) ) //для LIFO/FIFO
                       {
                          if (not isDoocen)
                            if ( SpOrder.Kol = 0 )
                              SpOrder.Kol := 1.0;

                         SpOrder.Ostatok := SpOrder.Kol;
                         SpOrder.Empty   := oSaldo_K.LoSetSpOrder_Empty( SpOrder.TipOrd
                                                                       , SpOrder.VidOrder
                                                                       , SpOrder.Ostatok
                                                                       , SpOrder.cSpSopr
                                                                       , SpOrder.ccPodr
                                                                       );
                       }

                       if (not oModifOrds.Check_wasSpisOrder(SpOrder.cMC, SpOrder.cParty, SklOrder.cPodr, SklOrder.cMol, 0, SkPr, SklOrder.dOrd, 1+ SklOrder.VidOrder))
                         and (CheckAllowMinusKol(SpOrder.kol))
                       {
                         Counts++;
                         oModifOrds.AnySpOrder_Insert(TypeSpOrder(SpOrder.buffer));
                       }
                       else
                         ReReadRecord(#SpOrder);

                       if ( SklOrder.VidOrder = 1 )
                       {
                         loCheckRashOrd.SpOrdercMC := SpOrder.cMC;
                         if loCheckRashOrd.GetFirst KatMC where (( SpOrdercMC == KatMC.nRec)) = tsOk
                           if (loCheckRashOrd.KatMC.wSerialReg <> 0)
                             for (i_Gtsp_1 := 0; i_Gtsp_1 <= MarkerCount_SerialN; i_Gtsp_1++)
                                if (GetMarker(MarkerSerialN_Gtsp_, i_Gtsp_1, PickSerialN))
                                  if (GetFirst CardSN where ((PickSerialN == CardSN.nRec)) = tsOk)
                                    if (CardSN.cMC  = SpOrder.cMC   ) and (CardSN.cParty = SpOrder.cParty) and
                                      (CardSN.cPodr = SklOrder.cPodr) and (CardSN.cMOL   = SklOrder.cMOL)
                                    {
                                      ii := 0;
                                      _LOOP SpCardSN where ((SpOrder.nRec == SpCardSN.cSpOrd))
                                        ii++;

                                      if (ii >= SpOrder.Kol)
                                        Break;

                                      if (CardSN.Status <> 7) and (CardSN.Status <> 3) and (CardSN.Status <> 9)
                                      {
                                        insert SpCardSN set SpCardSN.cCardSN := CardSN.nRec
                                             , SpCardSN.cSpOrd  := SpOrder.nRec
                                             , SpCardSN.dOrd    := SpOrder.dOrd
                                             , SpCardSN.nOrder  := SklOrder.nOrder;

                                        oSerialMove.UpdateSerialHistory(SpCardSN.cCardSN);

                                        update CardSN where (( SpCardSN.cCardSN == CardSN.nRec ))
                                          set CardSN.TipObjRes := 0
                                            , CardSN.cObjRes   := 0;
                                      }
                                    }
                       }
                     }
                   }
                 }
               }
             }
             2:
             {
               PushPos(#SpOrder);

               if (RunInterface('GetTekSaldoParty2', SklOrder.cPodr, SklOrder.cMol, SklOrder.SP) = cmDefault)
               {
                 if (wGetTune('Sklad.ContrSpisRashOrd') <> 0) And ( SklOrder.VidOrder = 1 )
                 {
                   loCheckRashOrd._Loop PickRep where (( 100 == PickRep.wlist)) ordered by index PickRep03
                   {
                     if GetFirst TekSaldo where (( loCheckRashOrd.PickRep.cRec == TekSaldo.nRec
                                               AND SklOrder.cPodr              == TekSaldo.cPodr (noIndex)
                                               AND SklOrder.cMOL               == TekSaldo.cMOL  (noIndex))) <> tsOk
                       Continue;

                     if (not boGettune('Sklad.ArchivMC'))
                     {
                       loCheckRashOrd._cMC := TekSaldo.cMC;
                       if loCheckRashOrd.GetFirst KatMCAr where ((_cMC == KatMCAr.nRec)) = tsOk
                         if (loCheckRashOrd.KatMCAr.IsArch = 1)
                         {
                           ShowTune('МЦ "' + loCheckRashOrd.KatMCAr.Name + '" находится в архиве!', 'Sklad.ArchivMC');
                           Continue;
                         }
                     }

                     var dkol_ : double = if(loCheckRashOrd.PickRep.pickKol <> 0, loCheckRashOrd.PickRep.pickKol, SpOrder.kol);

                     Nal := 0;

                     if (Abs(dKol_) >= GetPresision_forKol) // нулевое количество
                       Nal := CheckNalNastr(SklOrder.dOrd, TekSaldo.cMC, SklOrder.cPodr, SklOrder.cMol, TekSaldo.cParty, True);

                     if (Nal < dkol_)
                     {
                       if (Abs(Nal) >= GetPresision_forKol)
                       {
                         SpOrderDefault;
                         SpOrder.kol := Nal;
                       }
                       else
                         Continue;
                     }
                     else
                     {
                       SpOrderDefault;
                       if (isDoocen)
                         SpOrder.Kol := 0;
                       else
                         SpOrder.kol := dKol_;
                     }

                     SpOrder.cMC  := TekSaldo.cMC;
                     SpOrder.cParty := TekSaldo.cParty;
                     if loCheckRashOrd.GetFirst SaldoObj where (( PickRep.cUserDeskRep == SaldoObj.nRec )) = tsOk
                       oMTRFun.InsSpecMTR_Kit(coSpOrder, SpOrder.nRec, loCheckRashOrd.SaldoObj.cKitKau);

                     GetPriceRazrezOrder(TekSaldo.cMC, TekSaldo.cPodr, TekSaldo.cMOL, TekSaldo.cParty, True);

                     if (isDoocen)
                       SpOrder.Kol   := 0;
                     else
                       SpOrder.Kol   := loCheckRashOrd.PickRep.PickKol;

                     SpOrder.cParty  := TekSaldo.cParty;

                     if (IsLifoFifoNU)
                       SpOrder.OstatokN := SpOrder.Kol;

                     if ( IsLifoFifo OR (oMSview.GetTuneMSForPodr(SpOrder.ccPodr) <> 0) ) //для LIFO/FIFO
                     {
                       if (not isDoocen)
                         if ( SpOrder.Kol = 0 )
                           SpOrder.Kol := 1.0;

                       SpOrder.Ostatok := SpOrder.Kol;
                       SpOrder.Empty   := oSaldo_K.LoSetSpOrder_Empty( SpOrder.TipOrd
                                                                     , SpOrder.VidOrder
                                                                     , SpOrder.Ostatok
                                                                     , SpOrder.cSpSopr
                                                                     , SpOrder.ccPodr
                                                                     );
                     }

                     if (not oModifOrds.Check_wasSpisOrder(SpOrder.cMC, SpOrder.cParty, SklOrder.cPodr, SklOrder.cMol, 0, SkPr, SklOrder.dOrd, 1+ SklOrder.VidOrder))
                       and (CheckAllowMinusKol(SpOrder.kol))
                     {
                       Counts++;
                       oModifOrds.AnySpOrder_Insert(TypeSpOrder(SpOrder.buffer));
                     }
                     else
                       ReReadRecord(#SpOrder);
                   }
                 }
                 else
                   loCheckRashOrd._loop PickRep where (( 100 == PickRep.wlist)) ordered by index PickRep03
                   {
                     if GetFirst TekSaldo where (( loCheckRashOrd.PickRep.cRec == TekSaldo.nRec
                                               AND SklOrder.cPodr              == TekSaldo.cPodr (noIndex)
                                               AND SklOrder.cMOL               == TekSaldo.cMOL  (noIndex))) <> tsOk
                       Continue;

                     if (not boGettune('Sklad.ArchivMC'))
                     {
                       loCheckRashOrd._cMC := TekSaldo.cMC;
                       if loCheckRashOrd.GetFirst KatMCAr where ((_cMC == KatMCAr.nRec)) = tsOk
                         if (loCheckRashOrd.KatMCAr.IsArch = 1)
                         {
                           ShowTune('МЦ "' + loCheckRashOrd.KatMCAr.Name + '" находится в архиве!', 'Sklad.ArchivMC');
                           Continue;
                         }
                     }

                     PushPos(#SpOrder);
                     SpOrderDefault;
                     SpOrder.cMC    := TekSaldo.cMC;
                     SpOrder.cParty := TekSaldo.cParty;
                      if loCheckRashOrd.GetFirst SaldoObj where (( PickRep.cUserDeskRep == SaldoObj.nRec )) = tsOk
                        oMTRFun.InsSpecMTR_Kit(coSpOrder, SpOrder.nRec, loCheckRashOrd.SaldoObj.cKitKau);

                     GetPriceRazrezOrder(TekSaldo.cMC, TekSaldo.cPodr, TekSaldo.cMOL, TekSaldo.cParty, True);

                     if (isDoocen)
                       SpOrder.Kol := 0;
                     else
                       SpOrder.Kol := loCheckRashOrd.PickRep.PickKol;

                     if (IsLifoFifoNU)
                       SpOrder.OstatokN := SpOrder.Kol;

                     if ( IsLifoFifo OR (oMSview.GetTuneMSForPodr(SpOrder.ccPodr) <> 0) ) //для LIFO/FIFO
                     {
                        if (not isDoocen)
                          if ( SpOrder.Kol = 0 )
                            SpOrder.Kol := 1.0;

                        SpOrder.Ostatok := SpOrder.Kol;
                        SpOrder.Empty   := oSaldo_K.LoSetSpOrder_Empty( SpOrder.TipOrd
                                                                      , SpOrder.VidOrder
                                                                      , SpOrder.Ostatok
                                                                      , SpOrder.cSpSopr
                                                                      , SpOrder.ccPodr
                                                                      );
                      }

                      if (not oModifOrds.Check_wasSpisOrder(SpOrder.cMC, SpOrder.cParty, SklOrder.cPodr, SklOrder.cMol, 0, SkPr, SklOrder.dOrd, 1+ SklOrder.VidOrder))
                        and (CheckAllowMinusKol(SpOrder.kol))
                      {
                        Counts++;
                        oModifOrds.AnySpOrder_Insert(TypeSpOrder(SpOrder.buffer));
                      }
                      else
                        ReReadRecord(#SpOrder);
                   }
               }
             }
            end;

            PopPos(#SpOrder);
            RereadRecord(#SpOrder); // уберет запись, дабы проблем с стандартной вставкой не было

            if ( SklOrder.VidOrder = 0 ) and ( wTunePick = 0 )//приход
              StopVisual('', 0);

            Counts--;   // - 1 стандартная вставка убраная
          }
        else // редактируется ранее существовавшая
          {
            var cMCtmp: comp = SpOrder.cMC;
              case wTunePick of
                0:
                {
                  if ( RunInterface(getMC, cMCtmp) <> cmCancel )
                  {
                    if ( ( NOT canEditBackDate ) AND
                      oModifOrds.IsOstOnMSPrPer(True, SkPr, 0, SklOrder.cPodr, SklOrder.dOrd) )
                    {
                      if ( GetFirst KatMC where (( cMCtmp == KatMC.nRec )) = tsOk )
                        { }

                      ShowTune('В настройке установлен запрет модификации ордеров в закрытом периоде!',
                                if (SkPr = cgVidUchO_UKS, 'UKS.Doc.ModOrder',
                                if (SkPr = cgVidUchO_UPL, 'Manuf.ModOrder',
                                                          'McUsl.ModOrder'
                              )));
                      SklOrder.dOrd := Cur_Date;
                    }
                    else
                    {
                      if (not boGettune('Sklad.ArchivMC'))
                      {
                        loCheckRashOrd._cMC := cMCtmp;
                        if loCheckRashOrd.GetFirst KatMCAr where ((_cMC == KatMCAr.nRec)) = tsOk
                          if (loCheckRashOrd.KatMCAr.IsArch = 1)
                          {
                            ShowTune('МЦ "' + loCheckRashOrd.KatMCAr.Name + '" находится в архиве!', 'Sklad.ArchivMC');
                            Exit;
                          }
                      }

                      set SpOrder.cMC := cMCtmp;

                      if ( SklOrder.VidOrder = 1 )  // расход Пересчет средних цен
                        RecalcSrPricePos(True);

                      oModifOrds.AnySpOrder_Update(TypeSpOrder(SpOrder.buffer));
                    }
                  }
                }
                1:
                {
                  PushPos(#SpOrder);

                  if (RunInterface('GetTekSaldoParty',
                           True,              //- групповой выбор
                           True,              //- давать вводить кол-во
                           False,             //- давать возможность выбирать МЦ без тек. ост.
                           word(1),           //- только для ед. выбора
                           SklOrder.cPodr,    //- по подразделению
                           SklOrder.cMol,     //- по МОЛ
                           comp(0),           //- по МЦ
                           comp(0),           //- по Партии
                           comp(0),           //- по Объекту стр.
                           DOUBLE(0),         //- кол-во для одиночного выбора
                           word(2),           //- разрез менять можно только по МЦ
                           1,                 //- Используемый разрез (0-TekSaldo; 1-SaldoObj; 100-любой)
                           0,                 //- доп. режимы для работы с разрезом по Объектам
                           SklOrder.dOrd,     //- дата для расчета наличия
                           SklOrder.SP,       //- вид учета (cgVidUchO_Sklad - склад, cgVidUchO_UPL - производство, ...)
                           comp(0),           //- объект строительства в шапке АВР
                           comp(0)            //- целевой учет
                           ) = cmDefault )
                  {
                    //-------идентификаторы Маркеров--------------------------------------------
                    var  MarkerTekSaldo_Gtsp_       : TPtr;     // Маркеры для хранения выбора по Партиям
                    var  MarkerKolTekSaldo_Gtsp_    : TPtr;     //
                    var  MarkerCount_Gtsp_          : longint;
                    var  MarkerTekSaldo_Gtsp_MC_    : TPtr;     // Маркеры для хранения выбранных МЦ без тек. ост.
                    var  MarkerKolTekSaldo_Gtsp_MC_ : TPtr;
                    var  MarkerCount_Gtsp_MC_       : longint;
                    var  Marker_Gtsp_Obj            : TPtr;     // Маркеры для хранения выбора по Объектам стр.
                    var  MarkerKol_Gtsp_Obj         : TPtr;
                    var  MarkerCount_Gtsp_Obj       : longint;
                    var  MarkerSerialN_Gtsp_        : TPtr;     // Маркеры для хранения выбора по серийным номерам
                    var  MarkerCount_SerialN        : longint;
                    //-------------------------------
                    var  i_Gtsp_, i_Gtsp_1, ii      : longint;
                    var  PickRec_Gtsp_              : comp;
                    var  PickSerialN                : comp;
                    var  PickKol_Gtsp_              : double;
                    var  FlagFirst                  : boolean;

                    //---Инициализация Маркеров
                    Marker_Gtsp_Obj            := InitMarker ('GTSPC_MarkerTekSaldoObj'         ,8,100,10,False);
                    MarkerKol_Gtsp_Obj         := InitMarker ('GTSPC_MarkerKolTekSaldoObj'      ,8,100,10,False);
                    MarkerCount_Gtsp_Obj       := GetMarkerCount(Marker_Gtsp_Obj);
                    MarkerTekSaldo_Gtsp_       := InitMarker ('GTSPC_MarkerTekSaldoObj_Non'     ,8,100,10,False);
                    MarkerKolTekSaldo_Gtsp_    := InitMarker ('GTSPC_MarkerKolTekSaldoObj_Non'  ,8,100,10,False);
                    MarkerCount_Gtsp_          := GetMarkerCount(MarkerTekSaldo_Gtsp_);

                    MarkerTekSaldo_Gtsp_MC_    := InitMarker ('GTSPC_MarkerTekSaldo_MCNonOst'   ,8,100,10,False);
                    MarkerKolTekSaldo_Gtsp_MC_ := InitMarker ('GTSPC_MarkerKolTekSaldo_MCNonOst',8,100,10,False);
                    MarkerCount_Gtsp_MC_       := GetMarkerCount(MarkerTekSaldo_Gtsp_MC_);

                    MarkerSerialN_Gtsp_        := InitMarker ('GTSPC_MarkerSerialN'             ,8,100,10,False);
                    MarkerCount_SerialN        := GetMarkerCount(MarkerSerialN_Gtsp_);

                    FlagFirst := False;

                    for (i_Gtsp_:=0;i_Gtsp_<=MarkerCount_Gtsp_Obj;i_Gtsp_++)
                    {
                      if (GetMarker(Marker_Gtsp_Obj   ,i_Gtsp_,PickRec_Gtsp_) and
                          GetMarker(MarkerKol_Gtsp_Obj,i_Gtsp_,PickKol_Gtsp_))
                      {
                        if ( loCheckRashOrd.GetFirst SaldoObj Where (( PickRec_Gtsp_ == SaldoObj.nRec )) = tsOK )
                        {
                          if (not boGettune('Sklad.ArchivMC'))
                            if loCheckRashOrd.GetFirst KatMCAr where ((SaldoObj.cMC == KatMCAr.nRec)) = tsOk
                              if (loCheckRashOrd.KatMCAr.IsArch = 1)
                              {
                                ShowTune('МЦ "' + loCheckRashOrd.KatMCAr.Name + '" находится в архиве!', 'Sklad.ArchivMC');
                                Continue;
                              }

                          var dkol_ : double = if(PickKol_Gtsp_ <> 0, PickKol_Gtsp_, SpOrder.kol);

                          Nal := 0;

                          if (Abs(dKol_) >= GetPresision_forKol) // нулевое количество
                            Nal := CheckNalNastr(SklOrder.dOrd, loCheckRashOrd.SaldoObj.cMC, SklOrder.cPodr, SklOrder.cMol, loCheckRashOrd.SaldoObj.cParty, True);

                          if (not FlagFirst) and (Abs(Nal) >= GetPresision_forKol)
                          {
                            oVipMtrCount.MtrCheckDocs (coSpOrder, SpOrder.nRec, 0, true);
                            oMTRFun.DelSpecMTR(coSpOrder, SpOrder.nRec);
                          }

                          if (Nal < dkol_) AND ( SklOrder.VidOrder = 1 )
                          {
                            if (wGetTune('Sklad.ContrSpisRashOrd') = 0)
                            {
                              if (FlagFirst)
                                SpOrderDefault;
                              SpOrder.kol   := PickKol_Gtsp_;
                            }
                            else
                            {
                              if (Abs(Nal) >= GetPresision_forKol)
                              {
                                if (FlagFirst)
                                  SpOrderDefault;
                                SpOrder.kol := Nal;
                              }
                              else
                                Continue;
                            }
                           }
                           else
                           {
                             if (FlagFirst)
                               SpOrderDefault;
                             if (isDoocen)
                               SpOrder.Kol := 0;
                             else
                               SpOrder.kol := dKol_;
                           }

                          SpOrder.cMC    := loCheckRashOrd.SaldoObj.cMC;
                          SpOrder.cParty := loCheckRashOrd.SaldoObj.cParty;

                          if (  (SklOrder.VidOrder = 0)
                             or ((not boGetTune('Oper.RazrezCU' )) and (SpOrder.SP <> cgVidUchO_UPL))
                             or ((not boGetTune('Manuf.RazrezCU')) and (SpOrder.SP  = cgVidUchO_UPL))
                             )
                          {
                            InitMCInfo(SklOrder.dOrd);
                            LockValOt(True);
                            SkladProizv(SKlOrder.SP);
                            SpOrder.cVal   := StepMCInfo(loCheckRashOrd.SaldoObj.cMC, SpOrder.cVal,
                                                       if (SklOrder.cPodr = 0, comp(-1), SklOrder.cPodr),
                                                       if (SklOrder.cMOL  = 0, comp(-1), SklOrder.cMOL),
                                                       if (SpOrder.cParty = 0, comp(-1), SpOrder.cParty));

                            SpOrder.srPrice := AveragePrice;
                            SpOrder.VPrice  := AverageVPrice;
                            DoneMCInfo;
                          }

                          if (IsLifoFifoNU)
                            SpOrder.OstatokN := SpOrder.Kol;

                          if ( IsLifoFifo OR (oMSview.GetTuneMSForPodr(SpOrder.ccPodr) <> 0) ) //для LIFO/FIFO
                          {
                             if (not isDoocen)
                               if ( SpOrder.Kol = 0 )
                                 SpOrder.Kol := 1.0;

                             SpOrder.Ostatok := SpOrder.Kol;
                             SpOrder.Empty   := oSaldo_K.LoSetSpOrder_Empty( SpOrder.TipOrd
                                                                           , SpOrder.VidOrder
                                                                           , SpOrder.Ostatok
                                                                           , SpOrder.cSpSopr
                                                                           , SpOrder.ccPodr
                                                                           );
                           }

                           if (not oModifOrds.Check_wasSpisOrder(SpOrder.cMC, SpOrder.cParty, SklOrder.cPodr, SklOrder.cMol, 0, SkPr, SklOrder.dOrd, 1+ SklOrder.VidOrder))
                             and (CheckAllowMinusKol(SpOrder.kol))
                           {
                              if (  (SklOrder.VidOrder = 0)
                                 or ((not boGetTune('Oper.RazrezCU' )) and (SpOrder.SP <> cgVidUchO_UPL))
                                 or ((not boGetTune('Manuf.RazrezCU')) and (SpOrder.SP  = cgVidUchO_UPL))
                                 )
                              {
                                if (not FlagFirst)
                                {
                                  if ( SklOrder.VidOrder = 1 ) // расход Пересчет средних цен
                                    RecalcSrPricePos(False);

                                 oModifOrds.AnySpOrder_Update(TypeSpOrder(SpOrder.buffer));
                                }
                                else
                                {
                                  Counts++;
                                  oModifOrds.AnySpOrder_Insert(TypeSpOrder(SpOrder.buffer));
                               }
                             }

                             oMTRFun.InsSpecMTR_Kit(coSpOrder, SpOrder.nRec, loCheckRashOrd.SaldoObj.cKitKau);

                             if ((SklOrder.VidOrder = 1) and (  ((boGetTune('Oper.RazrezCU' )) and (SpOrder.SP <> cgVidUchO_UPL))
                                                             or ((boGetTune('Manuf.RazrezCU')) and (SpOrder.SP  = cgVidUchO_UPL))
                                                             ))
                             {
                               if (GetFirst SpecMTR = tsOk)
                                 oSald.CountPriceCU(SklOrder.dOrd, SkPr, SpecMTR.cSaldTune,
                                                  SpecMTR.cObj, SpecMTR.cKau[1], SpecMTR.cKau[2], SpecMTR.cKau[3], SpecMTR.cKau[4], SpecMTR.cKau[5],
                                                  SpecMTR.cKau[6], SpecMTR.cKau[7], SpecMTR.cKau[8], SpecMTR.cKau[9], SpOrder.cMC, SklOrder.cPodr, SklOrder.cMol, SpOrder.cParty,
                                                  dSrPrice, dvPrice, dKol, _cVal );
                               else
                                 oSald.CountPriceCU(SklOrder.dOrd, SkPr, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, SpOrder.cMC, SklOrder.cPodr, SklOrder.cMol, SpOrder.cParty,
                                                    dSrPrice, dvPrice, dKol, _cVal );

                               SpOrder.srPrice := dSrPrice;
                               SpOrder.VPrice  := dvPrice;
                               SpOrder.cVal    := _cVal;
                               if (not FlagFirst)
                               {
                                 if ( SklOrder.VidOrder = 1 ) // расход Пересчет средних цен
                                   RecalcSrPricePos(False);

                                 oModifOrds.AnySpOrder_Update(TypeSpOrder(SpOrder.buffer));
                               }
                               else
                               {
                                  Counts++;
                                  oModifOrds.AnySpOrder_Insert(TypeSpOrder(SpOrder.buffer));
                               }
                             }
                           }
                           else
                             ReReadRecord(#SpOrder);

                           FlagFirst := True;

                           if ( SklOrder.VidOrder = 1 )
                           {
                             loCheckRashOrd.SpOrdercMC := SpOrder.cMC;
                             if loCheckRashOrd.GetFirst KatMC where (( SpOrdercMC == KatMC.nRec)) = tsOk
                               if (loCheckRashOrd.KatMC.wSerialReg <> 0)
                                 for (i_Gtsp_1 := 0; i_Gtsp_1 <= MarkerCount_SerialN; i_Gtsp_1++)
                                   if (GetMarker(MarkerSerialN_Gtsp_, i_Gtsp_1, PickSerialN))
                                     if (GetFirst CardSN where ((PickSerialN == CardSN.nRec)) = tsOk)
                                       if (CardSN.cMC = SpOrder.cMC) and (CardSN.cParty = SpOrder.cParty) and
                                          (CardSN.cPodr = SklOrder.cPodr) and (CardSN.cMOL = SklOrder.cMOL)
                                       {
                                         ii := 0;
                                         _LOOP SpCardSN where ((SpOrder.nRec == SpCardSN.cSpOrd))
                                           ii++;

                                         if (ii >= SpOrder.Kol)
                                           Break;

                                         if (CardSN.Status <> 7) and (CardSN.Status <> 3) and (CardSN.Status <> 9)
                                         {
                                           insert SpCardSN set SpCardSN.cCardSN := CardSN.nRec
                                                , SpCardSN.cSpOrd  := SpOrder.nRec
                                                , SpCardSN.dOrd    := SpOrder.dOrd
                                                , SpCardSN.nOrder  := SklOrder.nOrder;

                                           oSerialMove.UpdateSerialHistory(SpCardSN.cCardSN);

                                           update CardSN where (( SpCardSN.cCardSN == CardSN.nRec ))
                                             set CardSN.TipObjRes := 0
                                               , CardSN.cObjRes   := 0;
                                         }
                                       }
                           }
                        }
                      }
                    }

                    for (i_Gtsp_:=0;i_Gtsp_<=MarkerCount_Gtsp_;i_Gtsp_++)
                    {
                      if (GetMarker(MarkerTekSaldo_Gtsp_,i_Gtsp_,PickRec_Gtsp_) and
                               GetMarker(MarkerKolTekSaldo_Gtsp_,i_Gtsp_,PickKol_Gtsp_))
                      {
                        if ( GetFirst TekSaldo Where (( PickRec_Gtsp_ == TekSaldo.nRec )) = tsOK )
                        {
                           if (not boGettune('Sklad.ArchivMC'))
                           {
                             loCheckRashOrd._cMC := TekSaldo.cMC;
                             if loCheckRashOrd.GetFirst KatMCAr where ((_cMC == KatMCAr.nRec)) = tsOk
                               if (loCheckRashOrd.KatMCAr.IsArch = 1)
                               {
                                 ShowTune('МЦ "' + loCheckRashOrd.KatMCAr.Name + '" находится в архиве!', 'Sklad.ArchivMC');
                                 Continue;
                               }
                           }

                           var dkol_ : double;
                           dkol_ := if(PickKol_Gtsp_ <> 0, PickKol_Gtsp_, SpOrder.kol);
                           Nal := 0;

                           if (Abs(dKol_) >= GetPresision_forKol) // нулевое количество
                             Nal := CheckNalNastr(SklOrder.dOrd, TekSaldo.cMC, SklOrder.cPodr, SklOrder.cMol, TekSaldo.cParty, True);

                           if (not FlagFirst) and (Abs(Nal) >= GetPresision_forKol)
                           {
                             oVipMtrCount.MtrCheckDocs (coSpOrder, SpOrder.nRec, 0, true);
                             oMTRFun.DelSpecMTR(coSpOrder, SpOrder.nRec);
                           }

                           if (Nal < dkol_) AND ( SklOrder.VidOrder = 1 )
                           {
                             if (wGetTune('Sklad.ContrSpisRashOrd') = 0)
                             {
                               if (FlagFirst)
                                  SpOrderDefault;
                               SpOrder.kol   := PickKol_Gtsp_;
                             }
                             else
                             {
                               if (Abs(Nal) >= GetPresision_forKol)
                               {
                                 if (FlagFirst)
                                    SpOrderDefault;
                                 SpOrder.kol := Nal;
                               }
                               else
                                 Continue;
                             }
                           }
                           else
                           {
                             if (FlagFirst)
                                SpOrderDefault;
                             if (isDoocen)
                               SpOrder.Kol := 0;
                             else
                               SpOrder.kol := dKol_;
                           }

                           SpOrder.cMC  := TekSaldo.cMC;
                           SpOrder.cParty  := TekSaldo.cParty;

                           GetPriceRazrezOrder(TekSaldo.cMC, SklOrder.cPodr, SklOrder.cMOL, SpOrder.cParty, True);

                           if (IsLifoFifoNU)
                             SpOrder.OstatokN := SpOrder.Kol;

                           if ( IsLifoFifo OR (oMSview.GetTuneMSForPodr(SpOrder.ccPodr) <> 0) ) //для LIFO/FIFO
                           {
                              if (not isDoocen)
                                if ( SpOrder.Kol = 0 )
                                  SpOrder.Kol := 1.0;

                             SpOrder.Ostatok := SpOrder.Kol;
                             SpOrder.Empty   := oSaldo_K.LoSetSpOrder_Empty( SpOrder.TipOrd
                                                                           , SpOrder.VidOrder
                                                                           , SpOrder.Ostatok
                                                                           , SpOrder.cSpSopr
                                                                           , SpOrder.ccPodr
                                                                           );
                           }

                           if oModifOrds.Check_wasSpisOrder(SpOrder.cMC, SpOrder.cParty, SklOrder.cPodr, SklOrder.cMol, 0, SkPr, SklOrder.dOrd, 1 + SklOrder.VidOrder)
                             or (not CheckAllowMinusKol(SpOrder.kol))
                             ReReadRecord(#SpOrder)
                           else
                           {
                             if (not FlagFirst)
                             {
                               if ( SklOrder.VidOrder = 1 ) // расход Пересчет средних цен
                                 RecalcSrPricePos(False);

                               oModifOrds.AnySpOrder_Update(TypeSpOrder(SpOrder.buffer));
                             }
                             else
                             {
                               Counts++;
                               oModifOrds.AnySpOrder_Insert(TypeSpOrder(SpOrder.buffer));
                             }
                           }

                           FlagFirst := True;

                           if ( SklOrder.VidOrder = 1 )
                           {
                             loCheckRashOrd.SpOrdercMC := SpOrder.cMC;
                             if loCheckRashOrd.GetFirst KatMC where (( SpOrdercMC == KatMC.nRec)) = tsOk
                               if (loCheckRashOrd.KatMC.wSerialReg <> 0)
                                 for (i_Gtsp_1 := 0; i_Gtsp_1 <= MarkerCount_SerialN; i_Gtsp_1++)
                                   if (GetMarker(MarkerSerialN_Gtsp_, i_Gtsp_1, PickSerialN))
                                     if (GetFirst CardSN where ((PickSerialN == CardSN.nRec)) = tsOk)
                                       if (CardSN.cMC   = SpOrder.cMC   ) and (CardSN.cParty = SpOrder.cParty) and
                                          (CardSN.cPodr = SklOrder.cPodr) and (CardSN.cMOL   = SklOrder.cMOL)
                                       {
                                         ii := 0;

                                         _LOOP SpCardSN where ((SpOrder.nRec == SpCardSN.cSpOrd))
                                           ii++;

                                         if (ii >= SpOrder.Kol)
                                           Break;

                                         if (CardSN.Status <> 7) and (CardSN.Status <> 3) and (CardSN.Status <> 9)
                                         {
                                           insert SpCardSN set SpCardSN.cCardSN := CardSN.nRec
                                                , SpCardSN.cSpOrd := SpOrder.nRec
                                                , SpCardSN.dOrd   := SpOrder.dOrd
                                                , SpCardSN.nOrder := SklOrder.nOrder;

                                           oSerialMove.UpdateSerialHistory(SpCardSN.cCardSN);

                                           update CardSN where (( SpCardSN.cCardSN == CardSN.nRec ))
                                             set CardSN.TipObjRes := 0
                                               , CardSN.cObjRes   := 0;
                                         }
                                       }
                           }
                        }
                      }
                    }
                  }
                }
                2:
                {
                  PushPos(#SpOrder);

                  if (RunInterface('GetTekSaldoParty2', SklOrder.cPodr, SklOrder.cMol, SklOrder.SP) = cmDefault)
                  {
                    var  FlagFirst : boolean;
                    FlagFirst := False;

                    if (wGetTune('Sklad.ContrSpisRashOrd') <> 0) AND ( SklOrder.VidOrder = 1 )
                    {
                      loCheckRashOrd._Loop PickRep where (( 100 == PickRep.wlist)) ordered by index PickRep03
                      {
                        if GetFirst TekSaldo where (( loCheckRashOrd.PickRep.cRec == TekSaldo.nRec
                                                  AND SklOrder.cPodr              == TekSaldo.cPodr (noIndex)
                                                  AND SklOrder.cMOL               == TekSaldo.cMOL  (noIndex))) <> tsOk
                          Continue;

                        if (not boGettune('Sklad.ArchivMC'))
                        {
                          loCheckRashOrd._cMC := TekSaldo.cMC;
                          if loCheckRashOrd.GetFirst KatMCAr where ((_cMC == KatMCAr.nRec)) = tsOk
                            if (loCheckRashOrd.KatMCAr.IsArch = 1)
                            {
                              ShowTune('МЦ "' + loCheckRashOrd.KatMCAr.Name + '" находится в архиве!', 'Sklad.ArchivMC');
                              Continue;
                            }
                        }

                        var dkol_ : double;
                        dkol_ := if(loCheckRashOrd.PickRep.pickKol <> 0, loCheckRashOrd.PickRep.pickKol, SpOrder.kol);
                        Nal := 0;

                        if (Abs(dKol_) >= GetPresision_forKol) // нулевое количество
                          Nal := CheckNalNastr(SklOrder.dOrd, TekSaldo.cMC, SklOrder.cPodr, SklOrder.cMol, TekSaldo.cParty, True);

                        if (not FlagFirst) and (Abs(Nal) >= GetPresision_forKol)
                        {
                          oVipMtrCount.MtrCheckDocs (coSpOrder, SpOrder.nRec, 0, true);
                          oMTRFun.DelSpecMTR(coSpOrder, SpOrder.nRec);
                        }

                        if (Nal < dkol_)
                        {
                          if (Abs(Nal) >= GetPresision_forKol)
                          {
                            if (FlagFirst)
                              SpOrderDefault;
                            SpOrder.kol := Nal;
                          }
                           else
                            Continue;
                        }
                        else
                        {
                          if (FlagFirst)
                            SpOrderDefault;
                          if (isDoocen)
                            SpOrder.Kol := 0;
                          else
                            SpOrder.kol := dKol_;
                        }

                        SpOrder.cMC  := TekSaldo.cMC;
                        SpOrder.cParty := TekSaldo.cParty;

                        if oModifOrds.Check_wasSpisOrder(SpOrder.cMC, SpOrder.cParty, SklOrder.cPodr, SklOrder.cMol, 0, SkPr, SklOrder.dOrd, 1+ SklOrder.VidOrder)
                          or (not CheckAllowMinusKol(SpOrder.kol))
                          ReReadRecord(#SpOrder)
                        else
                        {
                          GetPriceRazrezOrder(TekSaldo.cMC, SklOrder.cPodr, SklOrder.cMOL, SpOrder.cParty, True);

                          if (isDoocen)
                            SpOrder.Kol   := 0;
                          else
                            SpOrder.Kol   := loCheckRashOrd.PickRep.PickKol;

                          if (IsLifoFifoNU)
                            SpOrder.OstatokN := SpOrder.Kol;

                          if ( IsLifoFifo OR (oMSview.GetTuneMSForPodr(SpOrder.ccPodr) <> 0) ) //для LIFO/FIFO
                          {
                            if (not isDoocen)
                              if ( SpOrder.Kol = 0 )
                                SpOrder.Kol := 1.0;

                            SpOrder.Ostatok := SpOrder.Kol;
                            SpOrder.Empty   := oSaldo_K.LoSetSpOrder_Empty( SpOrder.TipOrd
                                                                          , SpOrder.VidOrder
                                                                          , SpOrder.Ostatok
                                                                          , SpOrder.cSpSopr
                                                                          , SpOrder.ccPodr );
                          }

                          if loCheckRashOrd.GetFirst SaldoObj where (( PickRep.cUserDeskRep == SaldoObj.nRec )) = tsOk
                            oMTRFun.InsSpecMTR_Kit(coSpOrder, SpOrder.nRec, loCheckRashOrd.SaldoObj.cKitKau);

                          if (not FlagFirst)
                          {
                            if ( SklOrder.VidOrder = 1 ) // расход Пересчет средних цен
                              RecalcSrPricePos(False);

                            oModifOrds.AnySpOrder_Update(TypeSpOrder(SpOrder.buffer));
                          }
                          else
                          {
                            Counts++;
                            oModifOrds.AnySpOrder_Insert(TypeSpOrder(SpOrder.buffer));
                          }
                        }

                        FlagFirst := True;
                      }
                    }
                    else
                      loCheckRashOrd._loop PickRep where (( 100 == PickRep.wlist)) ordered by index PickRep03
                      {
                        if GetFirst TekSaldo where (( loCheckRashOrd.PickRep.cRec == TekSaldo.nRec
                                                  AND SklOrder.cPodr              == TekSaldo.cPodr (noIndex)
                                                  AND SklOrder.cMOL               == TekSaldo.cMOL  (noIndex))) <> tsOk
                          Continue;

                        if (not boGettune('Sklad.ArchivMC'))
                        {
                          loCheckRashOrd._cMC := TekSaldo.cMC;
                          if loCheckRashOrd.GetFirst KatMCAr where ((_cMC == KatMCAr.nRec)) = tsOk
                            if (loCheckRashOrd.KatMCAr.IsArch = 1)
                            {
                              ShowTune('МЦ "' + loCheckRashOrd.KatMCAr.Name + '" находится в архиве!', 'Sklad.ArchivMC');
                              Continue;
                            }
                        }

                        PushPos(#SpOrder);
                        if (FlagFirst)
                          SpOrderDefault;
                        else
                        {
                          oVipMtrCount.MtrCheckDocs (coSpOrder, SpOrder.nRec, 0, true);
                          oMTRFun.DelSpecMTR(coSpOrder, SpOrder.nRec);
                        }

                        SpOrder.cMC  := TekSaldo.cMC;
                        SpOrder.cParty  := TekSaldo.cParty;

                        if oModifOrds.Check_wasSpisOrder(SpOrder.cMC, SpOrder.cParty, SklOrder.cPodr, SklOrder.cMol, 0, SkPr, SklOrder.dOrd, 1 + SklOrder.VidOrder)
                          or (not CheckAllowMinusKol(SpOrder.kol))
                           ReReadRecord(#SpOrder)
                        else
                        {
                          GetPriceRazrezOrder(TekSaldo.cMC, SklOrder.cPodr, SklOrder.cMOL, SpOrder.cParty, True);

                          if (isDoocen)
                            SpOrder.Kol   := 0;
                          else
                            SpOrder.Kol   := loCheckRashOrd.PickRep.PickKol;

                          if (IsLifoFifoNU)
                            SpOrder.OstatokN := SpOrder.Kol;

                          if ( IsLifoFifo OR (oMSview.GetTuneMSForPodr(SpOrder.ccPodr) <> 0) ) //для LIFO/FIFO
                          {
                            if (not isDoocen)
                              if ( SpOrder.Kol = 0 )
                                 SpOrder.Kol := 1.0;

                             SpOrder.Ostatok := SpOrder.Kol;
                             SpOrder.Empty   := oSaldo_K.LoSetSpOrder_Empty( SpOrder.TipOrd
                                                                           , SpOrder.VidOrder
                                                                           , SpOrder.Ostatok
                                                                           , SpOrder.cSpSopr
                                                                           , SpOrder.ccPodr );
                          }

                          if loCheckRashOrd.GetFirst SaldoObj where (( PickRep.cUserDeskRep == SaldoObj.nRec )) = tsOk
                            oMTRFun.InsSpecMTR_Kit(coSpOrder, SpOrder.nRec, loCheckRashOrd.SaldoObj.cKitKau);

                          if (not FlagFirst)
                          {
                            if ( SklOrder.VidOrder = 1 ) // расход Пересчет средних цен
                              RecalcSrPricePos(False);

                            oModifOrds.AnySpOrder_Update(TypeSpOrder(SpOrder.buffer));
                          }
                          else
                          {
                            Counts++;
                            oModifOrds.AnySpOrder_Insert(TypeSpOrder(SpOrder.buffer));
                          }
                        }

                        FlagFirst := True;
                    }
                  }
              }
              end;
          }

        ReReadRecord(#SpOrder);
        RescanPanel(#SklOrder);
        RedrawPanel(#SklOrder);

        var changefiled: integer;

        ReadMyDSK(changefiled,'forEditOrders',True);

        if(changefiled <> 1)
        {
          ClearAllEvents;       // убираем лишнее событие cmpick, которое откроет окно ввода количества с ДЕИ
          SelectField(#SpOrder.Kol);
        }

        SetModified(True);
      }
  //------------------------------------------------------------------------------
#ifdef _LINKMTR2SPEC_
    #SaldTune.Name
  , #vsKau1
  , #vsKau2
  , #vsKau3
  , #vsKau4
  , #vsKau5
  , #vsKau6
  , #vsKau7
  , #vsKau8
  , #vsKau9
  , #vsKau10 :
      {
        DoLinkMtrSpec(cgAct_Pick);
      }
#end
  //------------------------------------------------------------------------------
    #KatParty.Name, #KatParty.KOD:
      {
        if (SpOrder.method <> 0) AND
           (SpOrder.vidOrder = 0) AND
           (NOT f_KolEqual(SpOrder.kol, SpOrder.ostatok))
          {
            Message('По данному ордеру были произведены списания - изменять партию запрещено');
            Exit;
          }

        var cSavParty: comp;  cSavParty := SpOrder.cParty;

        if ( RunInterface('getPar__', SpOrder.cParty, SpOrder.cMC) <> cmCancel )
          {
            F_Change_Party(cSavParty);

#ifdef _USE_SERIAL_
            oSerialMove.ChangeSpOrderParty(SpOrder.nRec, SpOrder.cParty);
#end
          }
      }
  //------------------------------------------------------------------------------
    #SpOrder.rVPrice
  , #KlVal.SimVolV:
      {
        var dblCurse: double;

#ifdef _ZPRIHORD_VIP_
        if ( RunInterface('GetCurse', ordDPrice, SpOrder.cVal, dblCurse) <> cmCancel )
#else
        if ( RunInterface('GetCurse', SklOrder.dOrd, SpOrder.cVal, dblCurse) <> cmCancel )
#endif
          {
            if ( (SpOrder.cParty <> 0 ) AND (KatParty.cValPar <> 0 ) )
              if ( SpOrder.cVal <> KatParty.cValPar )
                {
                  set SpOrder.cVal := KatParty.cValPar;
                  Message('Валюта партии отличается от выбранной', Information);
                  Exit;
                }

            if ( (SpOrder.rSrPrice <> 0 ) OR (SpOrder.rVPrice <> 0 ) )
              if ( Message('Пересчитать валютную цену исходя из цены в НДЕ?', YesNo+Confirmation) = cmYes )
                {
                  set SpOrder.rVPrice := SpOrder.rSrPrice / dblCurse;
                  set SpOrder.VPrice  := oSaldo_K.RoundValOrd(SpOrder.rVPrice, SpOrder.kol);
                }
              else
                if ( Message('Пересчитать цену в НДЕ исходя из валютной цены?', YesNo+Confirmation) = cmYes )
                  {
                    set SpOrder.rSrPrice := SpOrder.rVPrice * dblCurse;
                    set SpOrder.SrPrice  := oSaldo_K.RoundRubOrd(SpOrder.rSrPrice, SpOrder.kol);
                  }

            oModifOrds.AnySpOrder_Update(TypeSpOrder(SpOrder.buffer));
            RescanPanel(#SpOrder);
            RescanPanel(#SklOrder);
          }
      }

    #SpOrder.kol:
      {
        oModifOrds.AnySpOrder_Update(TypeSpOrder(SpOrder.buffer)); // чтобы не приходило событие cmCheckRecord

        var kolOrd_, srPrOrd_: double;  kolOrd_:= SpOrder.kol;  srPrOrd_:= SpOrder.rSrPrice;
        var cMCOrd_, cSpOrd_: comp;     cMCOrd_:= SpOrder.cMC;  cSpOrd_ := SpOrder.nRec;

        RunInterface('KolDopEd'
                   , coSpOrder
                   , cSpOrd_
                   , word(1)
                   ,'Просмотр и редактирование количества МЦ в ДЕИ'
                   , cMCOrd_
                   , word(1)
                   , srPrOrd_
                   , word(2)
                   , word(2)
                   , comp(0)
                   , comp(0)
                   , kolOrd_
                   , longint(1)
                   , GetSoprHozTipDoc(SkPr, SklOrder.VidOrder)
                    );

        if (wGetTune('Sklad.AllowMinusKol') = 0) and (kolOrd_ < 0)
        {
          set SpOrder.kol := SpOrder.kol;
          ShowTune('Нельзя вводить отрицательное количество!','Sklad.AllowMinusKol');
        }
        else
          if kolOrd_ <> SpOrder.kol
          {
            if ( SklOrder.VidOrder = 1 ) and (wGetTune('Sklad.ContrSpisRashOrd') <> 0)
            {
              Nal := CheckNalNastr(SklOrder.dOrd, SpOrder.cMC, SklOrder.cPodr, SklOrder.cMol, SpOrder.cParty, True);
              Nal := Nal + SpOrder.Kol;

              if (Nal < kolOrd_)
              {
                message('Введенное количество по позиции превышает текущее наличие!');
                if (SpOrder.Kol <> Nal)
                  set SpOrder.kol := Nal;
              }
              else
                set SpOrder.kol := kolOrd_;
            }
            else
              set SpOrder.kol := kolOrd_;
         }
      }
  //------------------------------------------------------------------------------
    #SpOrder.rSrPrice
  , #SpOrder.SrPrice
  , #SumPrice:
      {
        PutCommand(cmOpenSearch);
      }
  //------------------------------------------------------------------------------
  end; // case

  if ( IsDoocen )
    case CurField of
    //------------------------------------------------------------------------------
      #KatMC.Name,
      #KatMC.BarKod,
      #KatParty.Name,
      #KatParty.KOD:
        isPick := True;
    //------------------------------------------------------------------------------
      #NewSimvolV:
        {
          var cValSav: comp;  cValSav := KlVal.nRec;

          if ( (RunInterface('GetValot', cValSav) = cmCancel ) OR (cValSav = SpOrder.cVal) )
            Exit;

#ifdef _ZPRIHORD_VIP_
          set OldVPrice := oValFunc.GetAnyCurrency(SpOrder.cVal, OldVPrice, sub_day(ordDPrice   , 1), cValSav);
#else
          set OldVPrice := oValFunc.GetAnyCurrency(SpOrder.cVal, OldVPrice, sub_day(SpOrder.dOrd, 1), cValSav);
#endif
          SpOrder.cVal := cValSav;

#ifdef _ZPRIHORD_VIP_
          set NewVPrice := oValFunc.GetAnyCurrency(0, NewSrPrice, sub_day(ordDPrice   , 1), SpOrder.cVal);
#else
          set NewVPrice := oValFunc.GetAnyCurrency(0, NewSrPrice, sub_day(SpOrder.dOrd, 1), SpOrder.cVal);
#endif
          set SpOrder.SrPrice  := (NewSrPrice - OldSrPrice) * KolMC;
          set SpOrder.VPrice   := (NewVPrice  - OldVPrice ) * KolMC;
          set SpOrder.rSrPrice := SpOrder.SrPrice;
          set SpOrder.rVPrice  := SpOrder.VPrice;

          if GetFirst KlVal where (( cValSav == KlVal.nRec)) = tsOk
            { }

          set NewSimvolV := KlVal.SimvolV;

          RedrawPanel(#SklOrder);
        }
    //------------------------------------------------------------------------------
    end; // case

  Result := True;
}

//********************************************************************************
Function F_SpOrder_Pick: boolean;
{
  Result := F_SpOrder_Pick_New(False);
}

//********************************************************************************
Function F_Value10: boolean;
{
  F_Value10 := False;
  if ( Message ('Удалить позиции с нулевым количеством МЦ?', YesNo+Confirmation+mfSwapButtons) <> cmYes )
    Exit;

  if ( CurTable = #SpOrder )
    {
      StartNewVisual(vtNumericVisual, vfTimer + vfBreak + vfConfirm, 'Удаляются позиции с нулевым количеством...', 1);
      PushPos(#SpOrder);

      _LOOP SpOrder
        if ( NOT NextVisual )
          Break
        else
          if ( (SpOrder.Kol = 0 ) AND ( NOT isDoocen ) )
            {
#ifdef _ZPRIHORD_VIP_
              loCheckRashOrd.SpOrder_nRec := SpOrder.nRec;
              loCheckRashOrd.delete SpDocSmeta where (( coSpOrder == SpDocSmeta.coTable and SpOrder_nRec == SpDocSmeta.cSpec ));
#end

#ifdef _RASHORD_VIP_
              loCheckRashOrd.SpOrder_nRec := SpOrder.nRec;
              loCheckRashOrd.delete SpDocSmeta where (( coSpOrder == SpDocSmeta.coTable and SpOrder_nRec == SpDocSmeta.cSpec ));
#end

              oModifOrds.AnySpOrder_Delete(TypeSpOrder(SpOrder.buffer));
            }

      PopPos(#SpOrder);
      RereadRecord(#SpOrder);
      StopVisual('', 0);
    }

  RescanPanel(#SpOrder);
  RedrawPanel(#SpOrder);
  F_Value10 := True;
}

//********************************************************************************

Function F_SklOrder_SetDefault( IsVidOrder      : word
                              ; GetIt           : word
                               #ifdef USE_ORDERS_INHERIT
                              ; IsDooc: boolean
                               #end
                              ): boolean;
{
  Result := False;

  ClearBuffer(#SklOrder);

  RescanPanel(#SklOrder);
  RescanPanel(#SpOrder);

  SklOrder.nRec := GetNextNRec(#SklOrder, 0);
  SklOrder.SP   := SkPr;

  if ( IsVidOrder = 0 ) // приход
    {
      #ifdef USE_ORDERS_INHERIT
      if ( IsDooc )
        {
          SklOrder.TipOrd   := 3; // в конце идет SklOrder.TipOrd++
          SklOrder.VidOrder := 0;
        }
      else
      #end
        if ( if( SkPr = 0, RunDialog(GetTipOrder,       SklOrder.TipOrd),
                           RunDialog(GetTipOrderProizv, SklOrder.TipOrd) ) <> cmCancel )
          SklOrder.VidOrder := 0
        else
          {
            RereadRecord(#SklOrder);
            Exit;
          }
    }
  else // расход
    {
      if ( prAvePrice )
        {
          if ( if( SkPr = 0, RunDialog('GetTipOrderRash'      , SklOrder.TipOrd)
                           , RunDialog('GetTipOrderRashProizv', SklOrder.TipOrd) ) <> cmCancel )
            SklOrder.VidOrder := 1;
          else
            {
              RereadRecord(#SklOrder);
              Exit;
            }
        }
      else
        {
         if (oMSview.GetMethodSpisPodr(SklOrder.cPodr) <> 0)
           Message('Не предусматрено ручное создание расходных ордеров при данной методике списания', Information)
         else
           if (boGetTune('Oper.NalUch') and ((wGetTune('Oper.NalUch.MSRP') <> 2) OR (wGetTune('Oper.NalUch.MSSN') <> 2)))
             Message('Не предусматрено ручное создание расходных ордеров при данной методике списания налогового учета', Information);

          RereadRecord(#SklOrder);
          Exit;
        }
    }

  if ( GetIt = 1 )
    if ( getCurPodr <> 0 )
      set SklOrder.cPodr := getCurPodr;
    else
    {
      if ( SklOrder.cPodr = 0 )
      {
        if ( NOT GetSklad )
          Exit;
      }
      else
      {
        if ( boGetTune('Pick.SkladWithMol') )
        {
          if ( SklOrder.cMOL <> 0 ) and ( KatMol.cSkl <> SklOrder.cPodr )
            SklOrder.cMOL := 0;   // обнулить МОЛ, если не из того склада

          ResetBounds(#KatMol);
          if ( GetFirst KatMol where ((SklOrder.cPodr == KatMol.cSkl)) = tsOk )
          {
            var last: comp;
            last := KatMol.nRec;
            if ( isAvtoMol ) //автовыбор МОЛ
              if ( GetNext KatMol where ((SklOrder.cPodr == KatMOL.cSkl)) <> tsOk )
                set SklOrder.cMOL := Last
              else
                {
                  SelectField(#KatMOL.Name);
                  PutCommand(cmPick);
                }
          }

          SetBounds(#KatMol);
        }
      }
    }

  if ( GetFirst KatPodr where ((SklOrder.cPodr == KatPodr.nRec)) = tsOk )
    SklOrder.cGrPodr := KatPodr.cGrPodr;

  if ( fltMask = 0 )
    SklOrder.dOrd := Cur_Date;
  else
    SklOrder.dOrd := if(Cur_Date < BegDate, BegDate, if(Cur_Date > EndDate, EndDate, Cur_Date));

  SklOrder.nOrder := oModifOrds.GetNextNOrderTekDate((SklOrder.VidOrder = 0 ), SklOrder.cPodr, SkPr, SklOrder.dOrd);

  F_ProtRec_PositionChanged;

  if ( IsProtected(#SklOrder) )
    Exit;

  SklOrder.YearOrd := Year(Cur_Date);
  SklOrder.TipOrd  := SklOrder.TipOrd + 1;
  SklOrder.Descr   := getUserDescr;
  SklOrder.DesGr   := getUserDesGr;

  Counts      := 0;
  SumOrd      := 0;
  VSumOrd     := 0;
  SimValutOrd := ' ';

  SelectField(#KatMOL.Name);

  if ( isAvtoMol ) // автовыбор МОЛ в документах
    if ( SklOrder.cMOL = 0 )
      // проверяем, если на складе 1 МОЛ - то заносим его сразу, если нет - выбор
      if( GetFirst KatMol where ((SklOrder.cPodr == KatMol.cSkl)) <> tsOk)
        PutCommand(cmPick);
      else
        {
          var savemol: comp;  SaveMol := KatMol.nRec;
          if( GetLast KatMol where ((SklOrder.cPodr == KatMol.cSkl)) = tsOk)
            if SaveMol = KatMol.nRec // Один Склад - Одно МОЛ
              set SklOrder.cMol := SaveMol;
            else
              PutCommand(cmPick);
        }

  if (m_sCurrentBarKod <> '')
    {
      if (oArchiveFuncs.IsExistArttr(m_sCurrentBarKod, 'NORDER'))
        SklOrder.nOrder := oArchiveFuncs.GetValueStringForNewDoc(m_sCurrentBarKod, 'NORDER');

      if (oArchiveFuncs.IsExistArttr(m_sCurrentBarKod, 'DORD'))
        SklOrder.dOrd := oArchiveFuncs.GetValueDateForNewDoc(m_sCurrentBarKod, 'DORD');

      // пока не решили что делать с дескриптором и потому отключили
      // SklOrder.DESGR := oArchiveFuncs.GetValueStringForNewDoc(m_sCurrentBarKod, 'DESGR');
      // SklOrder.DESCR := oArchiveFuncs.GetValueStringForNewDoc(m_sCurrentBarKod, 'DESCR');

      SetModified(True);
    }

  Result := True;
}

//********************************************************************************

Function F_SpOrder_SetDefault: boolean;
{
  Result := False;

  if ( IsProtected(#SklOrder) )
    Exit;

  SpOrder.SP := SklOrder.SP;

  // расход: не средние цены, 3 - внутреннее перемещение
  if (SklOrder.VidOrder = 1)
    if (
        (oMSview.GetTuneMSForPodr(SklOrder.cPodr) = 1)
       OR
        (IsLifoFifoNU)
       OR
        ( (IsLifoFifo) AND (SklOrder.TipOrd <> 3) )
       )
      {
        ShowTune('При данной методике списания не предусмотрено добавление позиций МЦ'#13'См. также методику списания по подразделению', 'Oper.L_F');
        Exit;
      }

  SpOrderDefault;

  Counts++;

  RedrawPanel(#SklOrder);
  RedrawPanel(#SpOrder);
  
  Result := True;
}

//********************************************************************************

Function F_SklOrder_CheckRecord: boolean;
{
  Result := False;

  // расход: не средние цены 3 - внутреннее перемещение
  if (SklOrder.VidOrder = 1)
    if (
        (oMSview.GetTuneMSForPodr(SklOrder.cPodr) = 1)
       OR
        (IsLifoFifoNU)
       OR
        ( (IsLifoFifo) AND (SklORder.TipOrd <> 3) )
       )
      {
        Message('При данном методе списания редактирование ордера невозможно'#13'См. также методику списания по подразделению', Information);
        RereadRecord;
        Exit;
      }

  OrdScan; // важно т.к. может заноситься неверная информация в SoprHoz

  if ( NOT CheckOrder )
    {
      RereadRecord;
      Exit;
    }

  Result := True;
}

//********************************************************************************

Function F_SpOrder_CheckRecord: boolean;
{
  Result := False;

  if ( ( SpOrder.kol = 0 ) AND (SpOrder.srPrice = 0) AND ( SpOrder.vPrice = 0 ) )
    if ( SpOrder.nRec = 0 ) OR (( SpOrder.cMC = 0 ) AND ( SpOrder.cParty = 0 ))
      Exit;

  // расход: не средние цены, 3 - внутреннее перемещение
  if (SklOrder.VidOrder = 1)
    if (
        (oMSview.GetTuneMSForPodr(SklOrder.cPodr) = 1)
       OR
        (IsLifoFifoNU)
       OR
        ( (IsLifoFifo) AND (SklORder.TipOrd <> 3) )
       )
    {
      ShowTune('При данной методике списания редактирование ордера запрещено'#13'См. также методику списания по подразделению', 'Oper.L_F');
      RereadRecord(#SpOrder);
      Exit;
    }

  SpOrder.dOrd   := SklOrder.dOrd;
  SpOrder.ccMOL  := SklOrder.cMOL;
  SpOrder.ccPodr := SklOrder.cPodr;

  if ( isDoocen )
    set SpOrder.Kol := 0;

  set SklOrder.cMOL := SpOrder.ccMOL; //установить признак модификации SklOrder

  if IsValid(#SpOrder)
    if ( SpOrder.cMC = 0 )
    {
      Message('Не указана матценность', Information);
      SelectField(#KatMC.Name);
      PutCommand(cmPick);
      Exit;
    }

  if IsValid(#SpOrder)
    if ( SpOrder.kol = 0 ) AND ( NOT isDoocen )
    {
      Message('Не указано количество', Information);
      SelectField(#SpOrder.Kol);
      Exit;
    }

  Result := True;
}

//********************************************************************************

Function F_SklOrder_DeleteRecord (bMess : boolean): boolean; //??? проверить не вызывается ли для защищенных записей
{
  Result := False;

  if IsProtected(#SklOrder)
    {
      ProcessCommand(cmProtectedInput);
      Exit;
    }

#ifdef _USE_SERIAL_
  if ( not oSerialMove.CanDeleteOrder(SklOrder.nRec) )
    {
      if (bMess)
        Message('В ордере введены серийные номера. Удалить документ невозможно.');
      Exit;
    }
#end

  if (SklOrder.cSopr <> 0)
    if (GetFirst KatSopr where ((SklOrder.cSopr == KatSopr.nRec)) = tsOk)
    {
      if (SklOrder.TipOrd <> 10)
        if (sGetTune('Doc.ModSopr.DelOrdStat') <> '')
          {
            loCheckRashOrd._cNotes := KatSopr.cNote;

            if (loCheckRashOrd.GetFirst KatNotes where (( _cNotes == KatNotes.nRec )) = tsOk)
              if (instr(UpCase(sGetTune('Doc.ModSopr.DelOrdStat')), UpCase(loCheckRashOrd.KatNotes.Name)) <> 0)
              {
                if (bMess)
                  ShowTune('Запрещено удаление ордеров в данном статусе накладной!', 'Doc.ModSopr.DelOrdStat');

                Exit;
              }
          }

      if (KatSopr.VidSopr = 101) or (KatSopr.VidSopr = 108) or (KatSopr.VidSopr = 600) or
         (KatSopr.VidSopr = 601) or (KatSopr.VidSopr = 602) or (KatSopr.VidSopr = 603) or
         (KatSopr.VidSopr = 605) or (KatSopr.VidSopr = 606)
      {
        var cKatSoprNRec : comp = KatSopr.nRec;

        if loCheckRashOrd.GetFirst KatSoprCheck where (( cKatSoprNRec == KatSoprCheck.cKatSopr )) = tsOk
        {
          var cKatSoprCheck : comp = loCheckRashOrd.KatSoprCheck.nRec;

          if loCheckRashOrd.GetFirst SklOrderRash where (( cKatSoprCheck == SklOrderRash.cSopr)) = tsOk
          {
             if (bMess)
               Message('У накладной есть акт на прием услуг, по которому создан ордер дооценки - удаление приходного ордера невозможно', information);

             Exit;
          }
        }
      }
    }

  if (bMess)
    if ( Message('Удалить ордер '+SklOrder.nOrder + '?', YesNo+Confirmation+mfSwapButtons) <> cmYes )
      Exit;

  if (NOT CanEditOrderWithRash(if(bMess, True, False)))
    Exit;

  if ( SklOrder.VidOrder = 0 ) // приход
    if ( SumCorrect )
      DeleteOrder(True)
    else
      {
        if (bMess)
          Message('Невозможно удалить ордер, т.к. по его позициям уже были сформированы расходные ордера', Information);

        Exit;
      }

  if ( SklOrder.VidOrder = 1 )
    DeleteOrder(True);

  RereadRecord(#SpOrder);
  RereadRecord(#SklOrder);

  OrdScan;

  Result := True;
}

//********************************************************************************
// для дооценки тоже пока подходит

Function F_SpOrder_DeleteRecord: boolean; //??? проверить не вызывается ли для зацищенных записей
{
  Result := False;

  if ( IsProtected(#SklOrder) )
    Exit;

  if ( NOT CanEditOrderWithRash(True) )
    Exit;

  if (SklOrder.cSopr <> 0)
    if (GetFirst KatSopr where ((SklOrder.cSopr == KatSopr.nRec)) = tsOk)
    {
      if (SklOrder.TipOrd <> 10)
        if (sGetTune('Doc.ModSopr.DelOrdStat') <> '')
          {
            loCheckRashOrd._cNotes := KatSopr.cNote;

            if (loCheckRashOrd.GetFirst KatNotes where (( _cNotes == KatNotes.nRec )) = tsOk)
              if (instr(UpCase(sGetTune('Doc.ModSopr.DelOrdStat')), UpCase(loCheckRashOrd.KatNotes.Name)) <> 0)
              {
                ShowTune('Запрещено удаление ордеров в данном статусе накладной!', 'Doc.ModSopr.DelOrdStat');
                Exit;
              }
          }

      if (KatSopr.VidSopr = 101) or (KatSopr.VidSopr = 108) or (KatSopr.VidSopr = 600) or
         (KatSopr.VidSopr = 601) or (KatSopr.VidSopr = 602) or (KatSopr.VidSopr = 603) or
         (KatSopr.VidSopr = 605) or (KatSopr.VidSopr = 606)
      {
        var cKatSoprNRec : comp = KatSopr.nRec;

        if loCheckRashOrd.GetFirst KatSoprCheck where (( cKatSoprNRec == KatSoprCheck.cKatSopr )) = tsOk
        {
          var cKatSoprCheck : comp = loCheckRashOrd.KatSoprCheck.nRec;

          if loCheckRashOrd.GetFirst SklOrderRash where (( cKatSoprCheck == SklOrderRash.cSopr)) = tsOk
          {
             Message('У накладной есть акт на прием услуг, по которому создан ордер дооценки - удаление невозможно', information);
             Exit;
          }
        }
      }
    }

  if ( Length(SDocNumber) > 0 )
    if ( Message('Данному ордеру соответствует накладная.'#13 +
                 'Изменение ордера может привести к некорректной ситуации!'#13#13 +
                 'Сохранить изменения?', YesNo+Confirmation+mfSwapButtons) <> cmYes )
      {
        RereadRecord(#SpOrder);
        Exit;
      }

  if ( IsProtected(#SklOrder) )
    Exit;

  if ( IsProtected(#SpOrder) )
    Exit;

  if ( SklOrder.VidOrder = 0 ) // приход
    if ( NOT (CheckSpKol) )
      {
        Message('Нельзя удалять данную позицию ордера', Information);
        Exit;
      }

  if ( NOT CheckVzv )
    {
      Message('Данную позицию ордера удалять нельзя, т.к. по ней уже были произведены возвраты', Information);
      Exit;
    }

  if ( Message('Удалить данную позицию ордера?', YesNo+Confirmation+mfSwapButtons) <> cmYes )
    Exit;

#ifdef _USE_SERIAL_
  if ( not oSerialMove.RemoveHistory(SpOrder.nRec) )
    {
      Message('В ордере введены серийные номера. Удаление невозможно.');
      Exit;
    }
#end

  set SklOrder.dOrd := SklOrder.dOrd;

  case SpOrder.vidOrder of
  //-------------------------------------------------------------
    0: insTbl.DeleteSpEnviroment(toSpReceiptOrder, SpOrder.nRec);
  //-------------------------------------------------------------
    1: insTbl.DeleteSpEnviroment(toSpDebitOrder, SpOrder.nRec);
  //-------------------------------------------------------------
  end;

  if (SklOrder.VidOrder = 1) // расход
    if ( IsLifoFifo OR ( oMSview.GetTuneMSForPodr(SklOrder.cPodr) = 1 ) )
      oOrdLIFO.RestoreOnePrihOrd(True, SpOrder.nRec);

  if (IsLifoFifoNU)
    oSetPriceNU.RestoreOstatokN(True, SpOrder.nRec);

  if ( (SklOrder.SP = 0) AND (SpOrder.method = 3) )
    {
      if (SklOrder.vidOrder = 0) AND ((SpOrder.tipOrd >= 4) AND (SpOrder.tipOrd <= 7))
        UpdateDooc_toRash_SpOrders(False);
    }

#ifdef _ZPRIHORD_VIP_
  loCheckRashOrd.SpOrder_nRec := SpOrder.nRec;
  loCheckRashOrd.delete SpDocSmeta where (( coSpOrder == SpDocSmeta.coTable and SpOrder_nRec == SpDocSmeta.cSpec ));
#end

#ifdef _RASHORD_VIP_
  loCheckRashOrd.SpOrder_nRec := SpOrder.nRec;
  loCheckRashOrd.delete SpDocSmeta where (( coSpOrder == SpDocSmeta.coTable and SpOrder_nRec == SpDocSmeta.cSpec ));
#end

  oModifOrds.AnySpOrder_Delete(TypeSpOrder(SpOrder.buffer));

  if ( GetNext SpOrder <> tsOk )
    {}

  RedrawPanel(#SklOrder);
  Result := True;
}

//********************************************************************************

Function F_SklOrder_CheckField: boolean;
{
  Result := False;

  if ( NOT CanEditOrderWithRash(True) )
    {
      RereadRecord(#SklOrder);
      Exit;
    }

  case CurField of
  //------------------------------------------------------------------------------
#ifdef _ZPRIHORD_VIP_
    #AttrValD.VDATE:
      {
        if ExtAttr_Create(coSklOrder, 'ДАТА_ЦЕН', cgAttrType_Date) <> 0
          dSetAttr(coSklOrder, SklOrder.nRec,'ДАТА_ЦЕН', AttrValD.VDATE);

        if ( Message('Пересчитать цены в НДЕ исходя из валютных цен?', YesNo+Confirmation) = cmYes )
         {
           var Curse : TSumma;

           StartNewVisual(vtDownVisual, 0, 'Пересчет валютных цен в спецификации ордера', 10);
           PushPos(#SpOrder);

           _LOOP SpOrder
             {
               NextVisual;
               ProtectRecord(#SpOrder, False);

               if ( oValFunc.GetCurse(SpOrder.cVal, ordDPrice, Curse) )
                 {
                   SpOrder.rSrPrice := SpOrder.VPrice * Curse;
                   SpOrder.rSrPrice := oSaldo_K.RoundRubOrd(SpOrder.rSrPrice, SpOrder.kol);
                 }

               oModifOrds.AnySpOrder_Update(TypeSpOrder(SpOrder.buffer));
             }

           ProtectRecord(#SpOrder, True);
           PopPos(#SpOrder);
           StopVisual('', 0);
         }
        else
          if ( Message('Пересчитать валютные цены исходя из цен в НДЕ?', YesNo+Confirmation) = cmYes )
            {
               var Curse : TSumma;

               StartNewVisual(vtDownVisual, 0, 'Пересчет валютных цен в спецификации ордера', 10);
               PushPos(#SpOrder);

               _LOOP SpOrder
                 {
                   NextVisual;
                   ProtectRecord(#SpOrder, False);

                   if ( oValFunc.GetCurse(SpOrder.cVal, ordDPrice, Curse) )
                     {
                       SpOrder.rVPrice := SpOrder.rSrPrice / Curse;
                       SpOrder.VPrice  := oSaldo_K.RoundValOrd(SpOrder.rVPrice, SpOrder.kol);
                     }

                   oModifOrds.AnySpOrder_Update(TypeSpOrder(SpOrder.buffer));
                 }

               ProtectRecord(#SpOrder, True);
               PopPos(#SpOrder);
               StopVisual('', 0);
            }
      }
#endif
  //------------------------------------------------------------------------------
    #SklOrder.dOrd:
      {
        var tmpDate: Date;   tmpDate := StrToDate(OldFieldValue, 'DD/MM/YYYY');

        if ( word(SklOrder.dOrd) = 0 )
          {
            Message('Введите дату ордера', Information);
            set SklOrder.dOrd := tmpDate;
            Exit;
          }

       if (wGetTune('Sklad.OrderFuture') = 0)
         if (SklOrder.dOrd > Cur_Date)
         {
           ShowTune('Нельзя создать складской ордер c датой больше текущей!', 'Sklad.OrderFuture');
           set SklOrder.dOrd := tmpDate;
           Exit;
         }


        if ( ( fltMask <> 0 ) AND ( (SklOrder.dOrd < BegDate) OR (SklOrder.dOrd > EndDate) ) )
          {
            Message('Введенная дата ордера находится вне диапазона дат фильтра. '#13 +
                    'Будет восстановлено старое значение даты.'#13 +
                    'Изменить фильтр можно при помощи <Alt+B>', Warning+Information);

            set SklOrder.dOrd := tmpDate;
            Exit;
          }

        if (not oModifOrds.CheckUniqNoOrd(SklOrder.nRec, SklOrder.SP, SklOrder.VidOrder, Year(SklOrder.dOrd), SklOrder.nOrder, True))
        {
          set SklOrder.dOrd := tmpDate;
          Exit;
        }

        if ( oModifOrds.IsOstOnMSPrPer(True, SkPr, 0, SklOrder.cPodr, SklOrder.dOrd) )
          {
            ShowTune('В настройке установлен запрет модификации ордеров в закрытом периоде!'#13'Изменение даты будет отменено',
                     if (SkPr = cgVidUchO_UKS, 'UKS.Doc.ModOrder',
                      if (SkPr = cgVidUchO_UPL, 'Manuf.ModOrder',
                         'McUsl.ModOrder'
                    )));
            set SklOrder.dOrd := tmpDate;
            Exit;
          }

        if ( ( SklOrder.VidOrder = 0 ) AND ( SklOrder.cSopr = 0 ) AND IsValid(#SpOrder) )
          {
            var Curse: TSumma;
            var Updated, boCurse: boolean;
            Updated := boCurse := False;
            if ( coGetTune('BaseCurrency') = 0 )
              if RecordExists SpOrder where ((SklOrder.nRec == SpOrder.cSklOrder AND
                                              0             << SpOrder.rVPrice (noIndex) )) = tsOk
                 boCurse := True;

            if ( coGetTune('BaseCurrency') <> 0 )
              OR ( ( coGetTune('BaseCurrency') = 0 ) AND ( boCurse ) )
            {
              if ( Message('Пересчитать валютные цены исходя из цен в НДЕ?', YesNo+Confirmation) = cmYes )
              {
                StartNewVisual(vtDownVisual, 0, 'Пересчет валютных цен в спецификации ордера', 10);
                Updated := True;
                PushPos(#SpOrder);

                _LOOP SpOrder
                  {
                    NextVisual;
                    ProtectRecord(#SpOrder, False);
#ifdef _ZPRIHORD_VIP_ //ordDPrice
                    if ( oValFunc.GetCurse(SpOrder.cVal, ordDPrice, Curse) )
#else
                    if ( oValFunc.GetCurse(SpOrder.cVal, SklOrder.dOrd, Curse) )
#endif
                      {
                        SpOrder.rVPrice := SpOrder.rSrPrice / Curse;
                        SpOrder.VPrice  := oSaldo_K.RoundValOrd(SpOrder.rVPrice, SpOrder.kol);
                      }

                    oModifOrds.AnySpOrder_Update(TypeSpOrder(SpOrder.buffer));
                  }

                ProtectRecord(#SpOrder, True);
                PopPos(#SpOrder);
                StopVisual('', 0);
              }
              else
                if ( Message('Пересчитать цены в НДЕ исходя из валютных цен?', YesNo+Confirmation) = cmYes )
                {
                  StartNewVisual(vtDownVisual, 0, 'Пересчет цен в НДЕ в спецификации ордера', 10);
                  Updated := True;
                  PushPos(#SpOrder);

                  _LOOP SpOrder
                    {
                      NextVisual;
                      ProtectRecord(#SpOrder, False);
#ifdef _ZPRIHORD_VIP_ //ordDPrice
                      if ( oValFunc.GetCurse(SpOrder.cVal, ordDPrice, Curse) )
#else
                      if ( oValFunc.GetCurse(SpOrder.cVal, SklOrder.dOrd, Curse) )
#endif
                        {
                          SpOrder.rSrPrice := SpOrder.rVPrice * Curse;
                          SpOrder.SrPrice  := oSaldo_K.RoundRubOrd(SpOrder.rSrPrice, SpOrder.kol);
                        }

                      oModifOrds.AnySpOrder_Update(TypeSpOrder(SpOrder.buffer));
                    }

                  ProtectRecord(#SpOrder, True);
                  PopPos(#SpOrder);
                  StopVisual('', 0);
                }
             }
             else
             {
                StartNewVisual(vtDownVisual, 0, 'Пересчет сальдовых остатков', 10);
                Updated := True;
                PushPos(#SpOrder);

                _LOOP SpOrder
                  {
                    NextVisual;
                    ProtectRecord(#SpOrder, False);
                    oModifOrds.AnySpOrder_Update(TypeSpOrder(SpOrder.buffer));
                  }

                ProtectRecord(#SpOrder, True);
                PopPos(#SpOrder);
                StopVisual('', 0);
             }

             if ( Updated )
             {
               OrdScan;
               RescanPanel(#SpOrder);
             }
          }
      }
  //------------------------------------------------------------------------------
    #SklOrder.nOrder:
      {
        if ( SklOrder.nOrder = '' )
        {
          Message('Необходимо указать номер ордера', Information);
          set SklOrder.nOrder := OldFieldValue;
          Exit;
        }

        if (not oModifOrds.CheckUniqNoOrd(SklOrder.nRec, SklOrder.SP, SklOrder.VidOrder, SklOrder.YearOrd, SklOrder.nOrder, False))
          set SklOrder.nOrder := OldFieldValue;
      }
  //------------------------------------------------------------------------------
  #ifndef __ListSkl_vip__
    #AttrValP.vString:
      {
        SetModified(True);
        oOrdHoz.UpdateSoprHoz(SklOrder.nRec, SklOrder.cSopr, cValOrd, sumOrd, vSumOrd, SklOrder.dOrd);
      }
  #end
  //------------------------------------------------------------------------------
  end; // case

  Result := True;
}

#ifndef __ListSkl_vip__
//******************************************************************************
Procedure SaveAttr_Primechanie;
{
// определяем новый defain для приходных и расходных ордеров
#ifdef _ZPRIHORD_VIP_
#define _PRIH_RASH_
#end

#ifdef _RASHORD_VIP_
#define _PRIH_RASH_
#end

#ifdef _PRIH_RASH_
  sSetAttr(coSklOrder, SklOrder.nRec, 'Примечание в ордерах', AttrValP.vString);
#endif
}
#endif

//********************************************************************************

Create view LF
From
  SpOrder;

//********************************************************************************

Function F_SpOrder_CheckField: boolean;
var Nal : double;
{
  Result := False;

  if ( NOT CanEditOrderWithRash(True) )
    {
      RereadRecord(#SpOrder);
      Exit;
    }

  if ( Length(SDocNumber) > 0 )
    if ( Message('Данному ордеру соответствует накладная.'#13 +
                 'Изменение ордера может привести к некорректной ситуации.'#13#13 +
                 'Сохранить изменения?', YesNo+Confirmation+mfSwapButtons) <> cmYes )
      {
        RereadRecord(#SpOrder);
        Exit;
      }

  StartNewVisual(vtIndicatorVisual, vfSilent, '', 0);

  StopVisual('', 0);

  var KolMCNoZero: double; KolMCNoZero := if(f_KolIsZero(KolMC), 1, kolMC);

  case CurField of
  //---------------------
    #NewSrPrice: //переоценка
      {
        set SpOrder.SrPrice  := (NewSrPrice - OldSrPrice) * KolMCNoZero;
        set SpOrder.rSrPrice := SpOrder.SrPrice;

        if ( SpOrder.cVal = 0 )
          Exit;

        if ( Message('Рассчитать новую валютную цену?', YesNo+Confirmation) <> cmYes )
          Exit;

#ifdef _ZPRIHORD_VIP_
        set NewVprice := oValFunc.GetAnyCurrency(0, NewSrPrice, ordDPrice   , SpOrder.cVal);
#else
        set NewVprice := oValFunc.GetAnyCurrency(0, NewSrPrice, SpOrder.dOrd, SpOrder.cVal);
#endif
        set SpOrder.VPrice := (NewVPrice - OldVPrice) * KolMCNoZero;

        SpOrder.rSrPrice := SpOrder.SrPrice;
        SpOrder.rVPrice  := SpOrder.VPrice;
      }
  //---------------------
    #NewVPrice:  //переоценка
      {
        set SpOrder.VPrice  := (NewVPrice   - OldVPrice) * KolMCNoZero;
        set SpOrder.rVPrice := SpOrder.VPrice;
        if ( SpOrder.cVal = 0 )
          Exit;

        if ( Message('Рассчитать новую рублевую цену?', YesNo+Confirmation) <> cmYes )
          Exit;
#ifdef _ZPRIHORD_VIP_
        set NewSrPrice := oValFunc.GetAnyCurrency(SpOrder.cVal, NewVPrice, ordDPrice   , 0);
#else
        set NewSrPrice := oValFunc.GetAnyCurrency(SpOrder.cVal, NewVPrice, SpOrder.dOrd, 0);
#endif
        set SpOrder.SrPrice := (NewSrPrice - OldSrPrice) * KolMCNoZero;
        SpOrder.rSrPrice := SpOrder.SrPrice;
        SpOrder.rVPrice  := SpOrder.VPrice;
      }
  //---------------------
    #newPriceN:
    {
      set SpOrder.priceN := (newPriceN - oldPriceN) * if(f_KolIsZero(kolMCN), 1.0, kolMCN);
      set SpOrder.SummN  := SpOrder.priceN;
      set SpOrder.SummN  := oSaldo_K.RoundRubOrd(SpOrder.priceN, if(isDoocen, 1, SpOrder.Kol))*if(isDoocen, 1, SpOrder.Kol);
    }
  //---------------------
   #SpOrder.priceN:
   {
      set newPriceN     := SpOrder.priceN/if(abs(kolMCN) < GetPresision_forKol, 1, kolMCN) + oldPriceN;
      set SpOrder.SummN := SpOrder.priceN*if(isDoocen, 1, SpOrder.Kol);
          SpOrder.SummN := oSaldo_K.RoundRubOrd(SpOrder.priceN, if(isDoocen, 1, SpOrder.Kol)) * if(isDoocen, 1, SpOrder.Kol);
   }
  //---------------------
    #SpOrder.SummN:
    {
      set SpOrder.PriceN := SpOrder.SummN/if(isDoocen, 1, SpOrder.Kol);
      set SpOrder.SummN  := oSaldo_K.RoundRubOrd(SpOrder.priceN, if(isDoocen, 1, SpOrder.Kol)) *if(isDoocen, 1, SpOrder.Kol);
    }
  //---------------------
    #SpOrder.rSrPrice,
    #SpOrder.srPrice,
    #sumPrice:
      {
        var oldSrPr : string;  oldSrPr  := if ( isDoocen, OldFieldValue, string(SpOrder.SrPrice) );
        var oldRSrPr: string;  oldRSrPr := OldFieldValue;

        if ( SpOrder.VidOrder <> 0 )
          {
            if ( IsLifoFifo
            OR IsLifoFifoNU
            OR (oMSview.GetTuneMSForPodr(SpOrder.ccPodr) <> 0) )
              {
                Message('При данной методике списания редактировать цену в расходных ордерах запрещено', 0);
                set SpOrder.SrPrice  := double(oldSrPr);
                set SpOrder.rSrPrice := double(oldRSrPr);
                SetModified(False);
                Exit;
              }

            if ( Message('Списание должно проходить по средней цене.'#13 +
                        'Изменение цены списания может привести к нарушению методики формирования цен.'#13#13 +
                        'Продолжить?', YesNo+Confirmation+mfSwapButtons) <> cmYes )
              {
                set SpOrder.SrPrice  := double(oldSrPr);
                set SpOrder.rSrPrice := double(oldRSrPr);
                SetModified(False);
                Exit;
              }
          } //расх.

        if ( NOT isDoocen )
          ModifyAllPrice(False);
        else
          {
            set NewSrPrice := (SpOrder.SrPrice / KolMCNoZero) + OldSrPrice;
            set SpOrder.rSrPrice := SpOrder.SrPrice;

            if ( SpOrder.cVal = 0 )
              Exit;

            if ( Message('Рассчитать новую валютную цену?', YesNo+Confirmation) <> cmYes )
              Exit;

#ifdef _ZPRIHORD_VIP_
            set NewVprice := oValFunc.GetAnyCurrency(0, NewSrPrice, ordDPrice   , SpOrder.cVal);
#else
            set NewVprice := oValFunc.GetAnyCurrency(0, NewSrPrice, SpOrder.dOrd, SpOrder.cVal);
#endif
            set SpOrder.VPrice := (NewVPrice - OldVPrice) * KolMCNoZero;

            SpOrder.rSrPrice := SpOrder.SrPrice;
            SpOrder.rVPrice  := SpOrder.VPrice;
          }
      }
  //---------------------
    #SpOrder.rVPrice
  , #SpOrder.vPrice:
      {
        var oldVpr : string; oldVPr  := if ( isDoocen, OldFieldValue, string(SpOrder.VPrice) );
        var oldRVpr: string; oldRVPr := OldFieldValue;

        if ( SpOrder.VidOrder <> 0 )
          {
            if ( IsLifoFifo OR IsLifoFifoNU OR (oMSview.GetTuneMSForPodr(SpOrder.ccPodr) <> 0) )
             {
               Message('При данном методе списания редактировать цену в расходных ордерах запрещено', 0);
               set SpOrder.VPrice  := double(oldVpr);
               set SpOrder.rVPrice := double(oldRVpr);
               SetModified(False);
               Exit;
             }

           if ( Message('Списание должно проходить по средней цене.'#13 +
                        'Изменение цены списания может привести к нарушению методики формирования цен.'#13#13+
                        'Продолжить?', YesNo+Confirmation+mfSwapButtons) <> cmYes )
             {
               set SpOrder.VPrice  := double(oldVpr);
               set SpOrder.rVPrice := double(oldRVpr);
               SetModified(False);
               Exit;
             }
          } //расх.

        if ( NOT isDoocen )
          ModifyAllPrice(True);
        else
          {
            set NewVprice       := (SpOrder.VPrice / KolMCNoZero) + OldVPrice;
            set SpOrder.rVPrice := SpOrder.VPrice;

            if ( SpOrder.cVal = 0 )
              Exit;

            if ( Message('Рассчитать новую рублевую цену?', YesNo+Confirmation) <> cmYes )
              Exit;
#ifdef _ZPRIHORD_VIP_
            set NewSrPrice      := oValFunc.GetAnyCurrency(SpOrder.cVal, NewVPrice, ordDPrice   , 0);
#else
            set NewSrPrice      := oValFunc.GetAnyCurrency(SpOrder.cVal, NewVPrice, SpOrder.dOrd, 0);
#endif
            set SpOrder.SrPrice := (NewSrPrice - OldSrPrice) * KolMCNoZero;
            SpOrder.rSrPrice    := SpOrder.SrPrice;
            SpOrder.rVPrice     := SpOrder.VPrice;
          }
      }
  //---------------------
    #SpOrder.kol:
      {
        if ( (SklOrder.TipOrd >= 4) AND (SklOrder.TipOrd <= 7) )
          {
            set SpOrder.Kol := 0;
            Exit;
          }

        if (wGetTune('Sklad.AllowMinusKol') = 0) and (SpOrder.kol  < 0)
        {
          set SpOrder.kol := Double(OldFieldValue);
          ShowTune('Нельзя вводить отрицательное количество!','Sklad.AllowMinusKol');
          Exit;
        }

        var oldKol: double;  oldKol := Double(OldFieldValue);

        fEdIzm.CheckKolDiskretAll ( SpOrder.Kol, fEdIzm.GetUchOtpEdNRec(KatMC.nRec, 1), KatEd.nRec, True, True );

        if ( SpOrder.VidOrder = 1 ) and (wGetTune('Sklad.ContrSpisRashOrd') <> 0)
        {
          Nal := CheckNalNastr(SklOrder.dOrd, SpOrder.cMC, SklOrder.cPodr, SklOrder.cMol, SpOrder.cParty, True);
          if (SklOrder.dOrd <= Cur_Date)
            Nal += OldKol;

          if (Nal < SpOrder.Kol)
          {
            message('Введенное количество по позиции превышает текущее наличие!');
            if (Nal <> OldKol)
              set SpOrder.kol := Nal;
            else
            {
              set SpOrder.Kol := oldKol;
              ReReadRecord(#SpOrder);
              SetModified(False);
              Exit;
            }
          }
        }

        if ( IsLifoFifo OR IsLifoFifoNU OR (oMSview.GetTuneMSForPodr(SpOrder.ccPodr) <> 0) )
          {
            if ( SpOrder.VidOrder <> 0 )
              {
                Message('При данной методике списания редактировать количество в расходных ордерах запрещено');
                set SpOrder.Kol := oldKol;
                SetModified(False);
                Exit;
              }
            else
              {
                if f_FirstKolIsGreater( oldKol - SpOrder.Ostatok, SpOrder.KOL )
                  {
                    Message('МЦ из данного приходного ордера уже списана', 0);
                    set SpOrder.Kol := oldKol;
                    Exit;
                  }
                else
                  {
                    set SpOrder.Ostatok  := SpOrder.Ostatok  + (SpOrder.Kol - oldKol);
                    set SpOrder.OstatokN := SpOrder.OstatokN + (SpOrder.Kol - oldKol);
                        SpOrder.Empty    := oSaldo_K.LoSetSpOrder_Empty( SpOrder.TipOrd
                                                                       , SpOrder.VidOrder
                                                                       , SpOrder.Ostatok
                                                                       , SpOrder.cSpSopr
                                                                       , SpOrder.ccPodr
                                                                       );
                  }
              }
          }

        set SpOrder.SrPrice := oSaldo_K.RoundRubOrd(SpOrder.rSrPrice, SpOrder.kol);
        set SpOrder.VPrice  := oSaldo_K.RoundValOrd(SpOrder.rVPrice , SpOrder.kol);

        SetModified(True);
      }
  //---------------------
  end; // case

  //------------------------------------------------------------------------------
  //если указана валюта
  var Curse: TSumma;

#ifdef _ZPRIHORD_VIP_ //ordDPrice
  if ( (oValFunc.GetCurse(SpOrder.cVal, ordDPrice    , Curse)) AND ( NOT (isDoocen )) )
#else
  if ( (oValFunc.GetCurse(SpOrder.cVal, SklOrder.dOrd, Curse)) AND ( NOT (isDoocen )) )
#endif
    case CurField of
    //------------------------------------------------------------------------------
      #SpOrder.rVPrice:
        if ( SpOrder.rVPrice <> 0 )
          {
            var doMakePrice: boolean; doMakePrice := True;

            case wGetTune('Sklad.ValRubCalc') of
              0: doMakePrice := False;
              2: doMakePrice := ( Message('Пересчитать цену в НДЕ исходя из валютной цены?', YesNo+Confirmation) = cmYes )
            end;

            set SpOrder.vPrice := oSaldo_K.RoundValOrd(SpOrder.rVPrice, SpOrder.kol);

            if ( doMakePrice )
              {
                set SpOrder.rSrPrice := SpOrder.rVPrice * Curse;
                set SpOrder.SrPrice  := oSaldo_K.RoundRubOrd(SpOrder.rSrPrice, SpOrder.kol);
              }
          }
    //------------------------------------------------------------------------------
      #SpOrder.rSrPrice
    , #SumPrice:
        if ( SpOrder.rSrPrice <> 0 )
          {
            var doMakePrice: boolean; doMakePrice := True;

            case wGetTune('Sklad.ValRubCalc') of
              0: doMakePrice := False;
              2: doMakePrice := ( Message('Пересчитать валютную цену исходя из цены в НДЕ?', YesNo+Confirmation) = cmYes );
            end;

            set SpOrder.srPrice := oSaldo_K.RoundRubOrd(SpOrder.rSrPrice, SpOrder.kol);

            if ( doMakePrice )
              {
                set SpOrder.rVPrice := SpOrder.rSrPrice / Curse;
                set SpOrder.VPrice  := oSaldo_K.RoundValOrd(SpOrder.rVPrice, SpOrder.kol);
              }
          }
    //------------------------------------------------------------------------------
  end; // case

  //округление цены, а не стоимости
  if ( NOT isDoocen )
    {
      set SpOrder.srPrice := oSaldo_K.RoundRubOrd(SpOrder.rSrPrice, SpOrder.kol);
      set SpOrder.vPrice  := oSaldo_K.RoundValOrd(SpOrder.rVPrice , SpOrder.kol);
    }

  if ( SklOrder.vidOrder = 0 ) //устанавливаем цену в расходных
    if ( SpOrder.nRec <> 0 )
      if  (IsLifoFifo OR IsLifoFifo OR (oMSview.GetTuneMSForPodr(SpOrder.ccPodr) <> 0))
        case CurField of
        //------------------------------------------------------------------------------
          #SpOrder.rSrPrice
        , #SpOrder.rVPrice
        , #sumPrice:
            {
              StartNewVisual(vtRotateVisual, 0, 'Установка цены списания в расходных ордерах', 1);

              var cRec_: comp;    cRec_ := SpOrder.nRec;
              var beg_: boolean;  beg_  := True;

              LF._LOOP SpOrder where ((cRec_ == SpOrder.cSpOrder))
                {
                  NextVisual;
                  if ( beg_ )
                    if ( Message('Установить данную цену в соответствующих ордерах отпуска?', Confirmation + YesNo) <> cmYes )
                      Break;

                  beg_ := False;

                  if ( LF.SpOrder.vidOrder = 0 )
                    Continue; //подстраховка чтобы не испортить приходы

                  LF.SpOrder.rSrPrice := SpOrder.rSrPrice;
                  LF.SpOrder.rVPrice  := SpOrder.rVPrice;
                  LF.SpOrder.srPrice  := 0; //округлится в тригере
                  LF.SpOrder.vPrice   := 0; //округлится в тригере
                  LF.SpOrder.cVal     := SpOrder.cVal;

                  oModifOrds.AnySpOrder_update( TypeSpOrder(LF.SpOrder.buffer) );
                }

              StopVisual('', 0);
            }
        //------------------------------------------------------------------------------
        end; //case

  RedrawPanel(#SpOrder);

  Result := True;
}

//********************************************************************************

Function F_SklOrder_SetCurField: boolean;
{
  Result := False;

  case Target of
  //---------------
    #KatPodr.Name:
      if ( SklOrder.cPodr = 0 )
        PutCommand(cmPick);
  //---------------
  end;

  Result := True;
}

//********************************************************************************

Function F_SpOrder_SetCurField: boolean;
{
  Result := False;

  if ( isDoocen )
    case CurField of
    //-------------
      #KatMC.Name
    , #KatMC.BarKod
    , #KatParty.Name
    , #KatParty.KOD:
        {
          if ( isPick )
            GetMCInfo;

          isPick := False;
        }
    //-------------
    end; //case
  else
    case Target of
    //-------------
      #KatMC.Name
    , #KatMC.BarKod:
        if ( SpOrder.cMC = 0 )
          PutCommand(cmPick);
    //-------------
    end; // case

  Result := True;
}

//********************************************************************************

Function F_SklOrder_DelOnProtect: boolean;
{
  Result := False;

  if ( IsProtected(#SklOrder) )
    Exit;

  if ( CurWindow = wnMainWindow )
    Exit;

#ifdef _USE_SERIAL_
  if ( not oSerialMove.CanChangeRzOrder(SklOrder.nRec) )
    {
      Message('В ордере введены серийные номера. Изменить разрез невозможно.');
      Exit;
    }
#end

  if ( NOT CanEditOrderWithRash(True) )
    Exit;

  if (SklOrder.VidOrder = 1)
  {
    if (
        (oMSview.GetTuneMSForPodr(SklOrder.cPodr) = 1)
        or
        (IsLifoFifoNU)
        or
        ( (IsLifoFifo) AND (SklOrder.TipOrd <> 3) )
       )
    {
      ShowTune('Изменение ордера при данной методике списания невозможно'#13'См. также методику списания по подразделению', 'Oper.L_F');
      Exit;
    }

    if (wGetTune('Sklad.ContrSpisRashOrd') <> 0)
      if (isValid(#SpOrder))
      {
        if (CurField = #SklOrder.dOrd)
        {
          ShowTune('Нельзя изменить дату ордера при наличии спецификаций!' , 'Sklad.ContrSpisRashOrd');
          Exit;
        }

        if (CurField = #KatPodr.Name) OR (CurField = #KatMOL.Name)
        {
          ShowTune('Нельзя изменить разрез списания при наличии спецификаций!' , 'Sklad.ContrSpisRashOrd');
          Exit;
        }
      }
  }
  case CurField of
  //---------------
    #SklOrder.dOrd,
    #KatPodr.Name:
      {
        Exit;
      }
  //---------------
    #SDocNumber:
      {
        if ( NOT isDoocen )
          Exit;

        set SklOrder.cSopr := 0;
      }
  //---------------
    #KatMol.Name:
      {
        if ( NOT canEditBackDate )
          if ( IsOstPrPer(SklOrder.dOrd, 'Запрет модификации ордеров в закрытом периоде') )
            Exit;

        if (SklOrder.cMOL <> 0) AND (SklOrder.vidOrder = 0) AND (boGetTune('Oper.NeedMOL'))
          {
            ShowTune('Установлена настройка', 'Oper.NeedMOL');
            Exit;
          }

        set SklOrder.cMOL := 0;
      }
  //---------------
   #KatParty.Name, #KatParty.KOD:
     {
       set SpOrder.cParty := 0;
       set SpOrder.cVal := coBaseCurrency;

       if ( SklOrder.VidOrder = 1 )
         RecalcSrPricePos(True);
     }
  //---------------
  #ifndef __ListSkl_vip__
  #ifndef _KartStor_VIP_
  #HozOperViewName:
    {
      var tmpVidOrd: word;
      tmpVidOrd := GetSoprHozTipDoc(SklOrder.SP, SklOrder.vidOrder);

      if NOT oCCOIO.CanChangeOborot(tmpVidOrd, SklOrder.nRec)
        Exit;

      iTxoBind.ResetServer;
      iTxoBind.UnBind(SoprHoz.BufferP);
      iTxoBind.ProcessProtokol;
      ReReadRecord;
    }
  #end
  #end
  //---------------
  end; // case

  Result := True;
}

//********************************************************************************

Function F_SpOrder_DelOnProtect: boolean;
{
  Result := False;

  if ( IsProtected(#SklOrder) )
    Exit;

  if ( IsProtected(#SpOrder) )
    Exit;

  if ( CurWindow = wnMainWindow )
    Exit;

  if ( NOT CanEditOrderWithRash(True) )
    Exit;

  if ( isDoocen )
    case CurField of
    //----------------
      #KatMC.Name
    , #KatMC.BarKod
    , #KatParty.Name
    , #KatParty.KOD:
        isPick := True;
    //----------------
    end; //case

  case CurField of
  //----------------
    #KatMC.BarKod
  , #KatMC.Name:
      {
        Exit;
      }
  //----------------
    #KlVal.SimVolV:
      if ( KatParty.cValPar <> 0 )
        {
          Message('Установлена валюта партии', Information);
          Exit;
        }
      else
        {
          set SpOrder.cVal   := 0;
          set SpOrder.VPrice := 0;

          oModifOrds.AnySpOrder_Update(TypeSpOrder(SpOrder.buffer));

          RescanPanel(#SpOrder);
          RescanPanel(#SklOrder);
        }
  //----------------
    #KatParty.Name, #KatParty.KOD:
      {
        set SpOrder.cParty := 0;
        set SpOrder.cVal := coBaseCurrency;

        if ( SklOrder.VidOrder = 1)
          RecalcSrPricePos(True);
      }
  //----------------
#ifdef _LINKMTR2SPEC_
    #SaldTune.Name
  , #vsKau1
  , #vsKau2
  , #vsKau3
  , #vsKau4
  , #vsKau5
  , #vsKau6
  , #vsKau7
  , #vsKau8
  , #vsKau9
  , #vsKau10 :
      {
        DoLinkMtrSpec(cgAct_Del);
      }
#end
  //----------------
  end; // case

  Result := True;
}

//********************************************************************************

Create view loOborud as select * from UKSKoeff;

Function F_SetCurTable: boolean;
{
  Result := False;
  
  if (CurTable = #SklOrder) AND (IsValid(#SklOrder))
    if (SklOrder.cMOL = 0) AND (SklOrder.vidOrder = 0) AND boGetTune('Oper.NeedMOL')
      {
        ShowTune('Установлена настройка', 'Oper.NeedMOL');
        SelectField(#KatMOL.Name);
        Exit;
      }

  if ( (CurTable = #SpOrder) AND (IsValid(#SpOrder)) )
    {
      PushPos(#SpOrder);
      _LOOP SpOrder
        if ( isDoocen )
          {
            if ((SpOrder.srPrice = 0 ) AND (SpOrder.vPrice = 0 ) AND (SpOrder.priceN = 0 ))
            {
              var bMess: boolean;
              bMess := True;

              if  (wGetTune('Country') = ccBel)
              {
                var cZatr: comp;
                cZatr := oMTRFun.GetZatrUKS(coSpOrder, SpOrder.nRec);

                // Если в ордере указана статья затрат, для которой есть коэффициент переоценки НЗС,
                // то нулевая сумма переоценки допустима
                if (loOborud.GetFirst UKSKoeff where (( word(2) == UKSKoeff.PrKoeff and
                                                        word(0) == UKSKoeff.Connect and
                                                        cZatr   == UKSKoeff.cRec )) = tsOk)
                  bMess := False;
              }

              if (bMess)
              {
                Message('В спецификации имеются позиции с нулевой ценой МЦ.'#13 +
                        'Исправьте это или удалите данные позиции.', Information);
                Break;
              }
            }
          }
        else
          if (SpOrder.Kol = 0 )
            {
              Message('В спецификации имеются позиции с нулевым количеством МЦ.'#13 +
                      'Отредактируйте нулевое количество или удалите данные позиции.', Information);
              Break;
            }
      PopPos(#SpOrder);
    }

  Result := True;
}

//********************************************************************************
// пересчет средних цен в ордере по Alt+D

Procedure CountSrPrices;
{
  if ( (IsProtected(#SklOrder)) OR (IsProtected(#SpOrder)) )
    {
      Message('Документ доступен только для просмотра', Information);
      Exit;
    }

  if ( NOT canEditBackDate )
    if ( IsOstPrPer(SklOrder.dOrd, 'Запрет модификации ордеров в закрытом периоде') )
      Exit;

  if NOT ( ( CurTable = #SklOrder ) AND prAvePrice AND IsValid(#SpOrder) )
    Exit;

  if ( Message('Пересчитать средние цены в ордере?', YesNo+Confirmation) <> cmYes )
    Exit;

  if ( NOT InitMCInfo(SklOrder.dOrd) )
    Exit;

  LockValOt(True);

  SkladProizv(SkPr);

  PushPos(#SpOrder);

  _LOOP SpOrder
    {
      NextVisual;

      SpOrder.srPrice  := 0;
      SpOrder.VPrice   := 0;
      SpOrder.rSrPrice := 0;
      SpOrder.rVPrice  := 0;

      var kol_: double; kol_ := SpOrder.kol;

      SpOrder.kol := 0;

      oModifOrds.AnySpOrder_Update(TypeSpOrder(SpOrder.buffer)); //для корректного сальдового остатка

      if( (SpOrder.SP = 0) AND (SpOrder.vidOrder = 1) AND (oMSview.GetTuneMSForPodr(SpOrder.ccPodr) = 1 ))
        {
          if ( oMSview.GetPrices_MSPrih2( SpOrder.rSrPrice, SpOrder.rVPrice, SpOrder.cVal, SpOrder.cSpOrder))
            {};
        }
      else
        {
          GetPriceRazrezOrder(SpOrder.cMC, SklOrder.cPodr, SklOrder.cMOL, SpOrder.cParty, False);
        }

      set SpOrder.kol      := kol_;
      set SpOrder.srPrice  := oSaldo_K.RoundRubOrd(SpOrder.rSrPrice, SpOrder.kol);
      set SpOrder.vPrice   := oSaldo_K.RoundValOrd(SpOrder.rVPrice, SpOrder.kol);

      oModifOrds.AnySpOrder_Update(TypeSpOrder(SpOrder.buffer));
    }

  PopPos(#SpOrder);

  DoneMCInfo;

  set SklOrder.dOrd := SklOrder.dOrd;

  OrdScan;
  RedrawPanel(#SklOrder);
  ReReadRecord(#SpOrder);
  RescanPanel(#SpOrder);
}

//********************************************************************************
//Возвращает цвет шрифта для серийного номера
//********************************************************************************
function GetSerialColor: word;
var _countRec: Longint;
{
  _countRec := 0;

  if ((not isValid(tnKatMC)) OR (KatMC.wSerialReg <> 1))
    {
      Result := ColorSysBlack;
      Exit;
    }

  _loop SpCardSN
    _countRec++;

  if (_countRec <> SpOrder.Kol)
    Result := ColorSysRed
  else
    Result := ColorSysBlack;
}

//********************************************************************************
