//------------------------------------------------------------------------------
//                                            (c) 1994,2010 корпорация Галактика
// Галактика 8.10 - Контур логистики. Модуль "L_Smeta".
// Парсер текстового файла формата АРПС 1.10
//------------------------------------------------------------------------------
#ifndef _Arps110Parser_vih_
#define _Arps110Parser_vih_

const
  // Типы записей файла формата АРПС 1.10
  cgArpsTypeComment = 0;
  cgArpsTypeStandartId = 1;
  cgArpsTypeDocumentId = 3;
  cgArpsTypePartHeader = 10;
  cgArpsTypePosition = 20;
  cgArpsTypeKoeff = 25;
  cgArpsTypeResource = 30;
  cgArpsTypeLimCosts = 50;
  cgArpsTypeUnknown = rvMaxWord;

  // Типы данных файла формата АРПС 1.10
  cgArpsFieldTypeString = 1; // в контексте vip кода представлен типом string
  cgArpsFieldTypeFloat = 2; // в контексте vip кода представлен типом double
  cgArpsFieldTypeInteger = 3; // в контексте vip кода представлен типом longint
  cgArpsFieldTypeMemo = 4; // в контексте vip кода представлен ссылкой на запись в таблице AllMemo


  // *** Поля записи cgArpsTypeComment ***

  cgArpsTypeCommentFieldContent = 1; // ссылка на содержимое комментария в AllMemo (AllMemo.nRec)

  // *** Поля записи cgArpsTypeDocumentId ***

  cgArpsDocumentFieldObjectName = 2; // 2) Наименование договора (объекта) (текст).
  cgArpsDocumentFieldContractorName = 8; // 8) Наименование организации-подрядчика (текст).
  cgArpsDocumentFieldPriceYear = 15; // 15) В каких ценах составлен документ (число).
  cgArpsDocumentFieldPeriod = 16; // 16) Период, за который составлен документ в формате ГГГГММ ( в описании
                                  // формата АРПС 1.10 это поле описано как число, но для удобства конвертации
                                  // в дату мы будем его импортировать как строку (см. InitFieldsDescript ).


  // *** Поля записи  cgArpsTypePartHeader ***

  cgArpsPartFieldLevel = 1; // 1) Уровень заголовка (целое неотрицательное число).
  cgArpsPartFieldNum = 2; // 2) Номер данного раздела (целое неотрицательное число).
  cgArpsPartFieldLevelName = 3; // 3) Наименование раздела (текст).


  // *** Поля записи  cgArpsTypePosition ***

  cgArpsPositionFieldNum = 1; // 1) Номер строки в документе (положительное число).
  cgArpsPositionFieldName = 4; // 4) Наименование позиции (текст)
  // Поля 5-14 содержат показатели позиции документа на единицу объема работ без учета различных поправочных
  // коэффициентов, зависящих от условий работ
  cgArpsPositionFieldOZP = 6; // 6) Основная заработная плата (число, руб.).
  cgArpsPositionFieldEMM = 7; // 7) Стоимость эксплуатации машин и механизмов (число, руб.)
  cgArpsPositionFieldZPM = 8; // 8) Заработная плата машинистов (число, руб.) (входит в общую стоимость эксплуатации машин и механизмов)
  cgArpsPositionFieldMC = 9; // 9) Стоимость материалов (число, руб.).
  // Поля 15-24 содержат показатели позиции документа на единицу объема работ с учетом всех примененных
  // поправочных коэффициентов, зависящих от условий работ
  cgArpsPositionFieldOZPWithKoeff = 16; // 16) Основная заработная плата (число, руб.).
  cgArpsPositionFieldEMMWithKoeff = 17; // 17) Стоимость эксплуатации машин и механизмов (число, руб.)
  cgArpsPositionFieldZPMWithKoeff = 18; // 18) Заработная плата машинистов (число, руб.) (входит в общую стоимость эксплуатации машин и механизмов).
  cgArpsPositionFieldMCWithKoeff = 19; // 19) Стоимость материалов (число, руб.)
  cgArpsPositionFieldJobVolume = 26; // 26) Объем работ (число)
  cgArpsPositionFieldSlaveFlag = 27; // 27) Признак подчиненности (число). Поле содержит 0 для обычных позиций
  cgArpsPositionFieldNormRate = 27;  // документа и норму расхода (ненулевую) на единицу объема основной работы
                                     // для позиций, относящихся к другим позициям (2 константы для удобства)
  cgArpsPositionFieldSmetaNum = 29;// 29) Номер сметы (текст).


  // *** Поля записи  cgArpsTypeKoeff ***

  cgArpsKoeffFieldType = 1; // 1) Тип поправки (число) (соотв. конст. описаны в smeta.inc)
  cgArpsKoeffFieldPrimenenie = 2; // 2) К чему относится поправка (число) (соотв. конст. описаны в smeta.inc)
  cgArpsKoeffFieldOperaiton = 3; // 3) Действие (число) (конст. разл. действий описаны в smeta.inc)
  cgArpsKoeffFieldValue = 4; // 4) Значение поправочного коэффициента (число)
  cgArpsKoeffFieldName = 5; // 5) Наименование поправочного коэффициента (текст)


  // *** Поля записи cgArpsTypeResource ***

  cgArpsResourceFieldCode = 1; // 1) Код ресурса (текст)
  cgArpsResourceFieldUnit = 2; // 2) Единица измерения (текст).
  cgArpsResourceFieldName = 3; // 3) Наименование ресурса (текст)
  cgArpsResourceFieldTypeId = 4; // 4) Признак типа ресурса (число):
    // типы ресурсов
    cgArpsResourceType_ZP = 0; // 0 - заработная плата
    cgArpsResourceType_EM = 1; // 1 - эксплуатация машин и механизмов
    cgArpsResourceType_MC = 2; // 2 - материал
  cgArpsResourceFieldNormRash = 5; // 5) Норма расхода ресурса на единицу объема работ (число)
  cgArpsResourceFieldPriceNorm = 6; // 6) Цена единицы ресурса нормативная (число, руб.).
  cgArpsResourceFieldPriceFact = 7; // 7) Цена единицы ресурса фактическая (число, руб.).
  cgArpsResourceFieldPriceLocal = 8; // 8) Цена единицы ресурса местная (число, руб.).


  // *** Поля записи cgArpsTypeLimCosts ***

  cgArpsLimCostsFieldName = 1; // 1) Наименование затрат (текст).
  cgArpsLimCostsFieldKoef = 2; // 2) Коэффициент (число).
  // 3) Сумма затрат (число).
  // 4) Сумма с учетом данного вида затрат (число).

end;

// Таблицы, накачиваемые импортированными из файла данными

#doc
Содержит записи импортированного файла формата АРПС
#end
Table struct TblRecords "Записи импортируемого файла"
(
  nRec: comp,
  RecType: word "Код типа записи",
  cNode: comp "Ссылка на владельца"
)
with index
(
  TblRecords01 = nRec(Unique, Surrogate),
  TblRecords02 = cNode + RecType
//  TblRecords03 = RecType
);

#doc
Содержит поля записей импортированного файла формата АРПС
#end
Table struct TblFields "Поля записей импортируемого файла"
(
  nRec: comp,
  FieldNum: word,
  ValType: word,
  cOwner: comp,
  dVal: double,
  sVal: string,
  iVal: longint,
  cMemVal: comp // ссылка на таблицу AllMemo (т.к. для таблицы в памяти нельзя создать мемо-поле)
)
with index
(
  TblFields01 = nRec(Unique, Surrogate),
  TblFields02 = cOwner+FieldNum,
  TblFields03 = ValType
);

#doc
Описание структуры записей АРПС файла
#end
Table struct TblFieldsDescript "Структура записей АРПС"
(
  RecType: word "Код типа записи",
  FieldNum: word,
  FieldType: word
)
with index
(
  TblFieldsDescript01 = RecType + FieldNum
);

#doc
Внешние исключения, генерируемые методами парсера
#end
exception ExArpsParserError;

VipInterface Arps110Parser
  licensed(free);

public:
  destructor Done;

  #doc
  Стартовая функция запуска парсера.
  Внешних исключений не генерирует.
  #end
  function RunParser(
    _importFileName: string // имя файла формата АРПС для парсинга
    ): boolean; // возвращает true, если файл разобран без ошибок

  #doc
  Возвращает значение указанного поля записи
  При ошибке генерирует исключение ExArpsParserError, объявленное в заголовочном файле
  #end
  function GetFieldValue(
    _fieldOwner: comp; // ссылка на запись АРПС
    _fieldNum: word // номер поля записи (для указания полей использовать константы из заголовочного файла)
    ): variant; // возвращает значение указанного поля

  #doc
  Возвращает тип указанной записи АРПС. Константы типов записей описаны в заголовочном файле: cgArpsType*
  #end
  function GetRecordType( _nrec: comp ): word;

  #doc
  Событие генерируется парсером при добавлении записи в лог работы парсера
  #end
  event procedure EventLogWriteLn( msg: string );

  // Чтобы собрать компонент с отладочным кодом необходимо вызвать
  // компайлер с предопределенным макро DEBUG:
  // 4onecomp.bat l_smeta /Macro.Define:DEBUG
  // Затем можно вызвать интерфейс L_Smeta::Arps110Parser в отладочном режиме через меню Сервис-Утилиты-Запуск внешнего интерфейса
  #ifdef DEBUG
  // при вызове этой ф-ции появл. окошко, в котором можно посмотреть содержимое таблиц парсера,
  // потестить парсер и т.п.
  procedure DbgShowDebugWindow;
  #endif
end;
#endif
