//********************************************************************************
//                                                        (c) корпорация Галактика
// Галактика 5.85 - логистика
// Функции для работы с маркерами и таблицами PickRep, Pick при выборе фильтров
//********************************************************************************

Create view lPMarker
Var
  pUserDeskRep: comp;
From
  PickRep
, Pick
, KatOrgDescr
;

Procedure DelPickRep(wListSour : word);
{
  lPMarker.pUserDeskRep := UserDeskRep.nRec;

  lPMarker.delete PickRep where (( UserName     == PickRep.OwnName  and
                                   pUserDeskRep == PickRep.cUserDeskRep and
                                   wListSour    == PickRep.wList ));
}

#ifndef __Hide_CountPickRep__
// Пересчет выбранных элементов в PickRep
Function CountPickRep(wListSour : word) : TNumPick;
{
  lPMarker.pUserDeskRep := UserDeskRep.nRec;

  Result := 0;

  lPMarker._LOOP PickRep where (( UserName     == PickRep.OwnName      and
                                  pUserDeskRep == PickRep.cUserDeskRep and
                                  wListSour    == PickRep.wList ))
    Result++;
}
#end

// Перегон из Marker'а в PickRep
Procedure Marker2PickRep(mrkName : string; wList : word; var cRescomp : comp; var NumPick : TNumPick);
var
  i, cMarker, cCount : longint;
  PickRec            : comp;
{
  cMarker := InitMarker(mrkName, 8, 100, 10);
  NumPick := 0;
  cCount  := GetMarkerCount(cMarker);

  FOR(i := 0; i < cCount; i++)
    if GetMarker(cMarker, i, PickRec)
      {
        lPMarker.ClearBuffer(lPMarker.tnPickRep);

        lPMarker.PickRep.OwnName      := UserName;
        lPMarker.PickRep.wList        := wList;
        lPMarker.PickRep.cRec         := PickRec;
        lPMarker.PickRep.PickNum      := i;
        lPMarker.PickRep.cUserDeskRep := UserDeskRep.nRec;

        if ( lPMarker.insert current PickRep = tsOk )
          NumPick++;
      }

  if ( NumPick = 1 )
    {
      set cRescomp := lPMarker.PickRep.cRec;
      DelPickRep(wList);
    }
  else
    set cRescomp := 0;

  DoneMarker(cMarker, mrkName);
}

Procedure Marker2PickRepEx(mrkName : string; wList : word; var NumPick : TNumPick);
var
  i, cMarker, cCount : longint;
  PickRec            : comp;
{
  cMarker := InitMarker(mrkName, 8, 100, 10);
  NumPick := 0;
  cCount  := GetMarkerCount(cMarker);

  FOR(i := 0; i < cCount; i++)
    if GetMarker(cMarker, i, PickRec)
      {
        lPMarker.ClearBuffer(lPMarker.tnPickRep);

        lPMarker.PickRep.OwnName      := UserName;
        lPMarker.PickRep.wList        := wList;
        lPMarker.PickRep.cRec         := PickRec;
        lPMarker.PickRep.PickNum      := i;
        lPMarker.PickRep.cUserDeskRep := UserDeskRep.nRec;

        if ( lPMarker.insert current PickRep = tsOk )
         NumPick++;
      }

  DoneMarker(cMarker, mrkName);
}

// Перегон из PickRep в Marker
Procedure PickRep2Marker (mrkName : string; wList : word; cRescomp : comp);
// cRescomp = 0 если множ.выбор и <> 0 если единичный
var
  cMarker : longint;
{
  lPMarker.pUserDeskRep := UserDeskRep.nRec;

  cMarker := InitMarker(mrkName, 8, 100, 10);

  ClearMarker(cMarker);

  if ( cRescomp = 0 )
    {
      lPMarker._LOOP PickRep noVisual where (( UserName     == PickRep.OwnName      and
                                               pUserDeskRep == PickRep.cUserDeskRep and
                                               wList        == PickRep.wList ))
        InsertMarker(cMarker, lPMarker.PickRep.cRec);
    }
  else
    InsertMarker(cMarker, cRescomp);

  DoneMarker(cMarker, mrkName);
}

Procedure DelPick(wListSour: word);
{
  lPMarker.delete Pick where (( wListSour == Pick.wList ));
}

#ifndef __Hide_SomeMethods__
Procedure Pick2PickRepBody(bZero : boolean; wListSour, wListDest : word; var cRescomp : comp; var NumPick : TNumPick);
{
  NumPick := 0;

  lPMarker._LOOP Pick noVisual where (( wListSour == Pick.wList ))
    {
      // Не включаем нулевые нреки
      if ( not bZero and ( lPMarker.Pick.cRec = 0 ) )
        Continue;

      lPMarker.ClearBuffer(lPMarker.tnPickRep);

      lPMarker.PickRep.nRec         := 0;
      lPMarker.PickRep.OwnName      := UserName;
      lPMarker.PickRep.wList        := wListDest;
      lPMarker.PickRep.cRec         := lPMarker.Pick.cRec;
      lPMarker.PickRep.PickKol      := lPMarker.Pick.PickKol;
      lPMarker.PickRep.PickNum      := lPMarker.Pick.PickNum;
      lPMarker.PickRep.cUserDeskRep := UserDeskRep.nRec;

      if ( lPMarker.insert current PickRep = tsOk )
        NumPick++;
    }

  if ( NumPick = 1 )
    {
      cRescomp := lPMarker.PickRep.cRec;
      DelPickRep(wListDest);
    }
  else
    cRescomp := 0;
}

Procedure Pick2PickRep(wListSour, wListDest : word; var cRescomp : comp; var NumPick : TNumPick);
{
  Pick2PickRepBody(False, wListSour, wListDest, cRescomp, NumPick);
}

//  (Pick.cRec = 0)  тоже копируется
Procedure Pick2PickRepEx(wListSour, wListDest : word; var cRescomp : comp; var NumPick : TNumPick);
{
  Pick2PickRepBody(True, wListSour, wListDest, cRescomp, NumPick);
}

Procedure PickRep2Pick(wListSour, wListDest : word; cRescomp : comp);
{
  lPMarker.pUserDeskRep := UserDeskRep.nRec;

  DelPick(wListDest);

  if ( cRescomp = 0 )
    lPMarker._LOOP PickRep NoVisual where (( UserName     == PickRep.OwnName and
                                             pUserDeskRep == PickRep.cUserDeskRep and
                                             wListSour    == PickRep.wList ))
      {
        lPMarker.ClearBuffer(lPMarker.tnPick);

        lPMarker.Pick.nRec    := 0;
        lPMarker.Pick.wList   := wListDest;
        lPMarker.Pick.cRec    := lPMarker.PickRep.cRec;
        lPMarker.Pick.PickKol := lPMarker.PickRep.PickKol;
        lPMarker.Pick.PickNum := lPMarker.PickRep.PickNum;

        if ( wListDest = 11 )
          lPMarker.Pick.FilialNo := 1;

        lPMarker.insert current Pick;
      }
  else
    {
      lPMarker.ClearBuffer(lPMarker.tnPick);

      lPMarker.Pick.nRec    := 0;
      lPMarker.Pick.wList   := wListDest;
      lPMarker.Pick.cRec    := cRescomp;
      lPMarker.Pick.PickKol := 0;
      lPMarker.Pick.PickNum := 0;

      if ( wListDest = 11 )
        lPMarker.Pick.FilialNo := 1;

      lPMarker.insert current Pick;
    }
}
#end

// Заполнение маркера KatOrgDescr на основе маркера KatOrg
Procedure SetKatOrgDescrMarker;
var
  cKatOrg, cKatOrgDescr, mCount, i : longint;
  cRec                             : comp;
{
  cKatOrg      := InitMarker('KatOrg',      8, 100, 10);
  cKatOrgDescr := InitMarker('KatOrgDescr', 8, 100, 10);

  ClearMarker(cKatOrgDescr);

  mCount := GetMarkerCount(cKatOrg);

  FOR(i := 0; i < mCount; i++)
  {
    if GetMarker(cKatOrg, i, cRec)
      if ( lPMarker.GetFirst KatOrgDescr where (( cRec == KatOrgDescr.cRec )) = tsOk )
        InsertMarker(cKatOrgDescr, lPMarker.KatOrgDescr.nRec);
  }

  DoneMarker(cKatOrg,      'KatOrg');
  DoneMarker(cKatOrgDescr, 'KatOrgDescr');
}

//------------------------------------------------------------------------------
Function CopyPickInMarker(pwList: word; strNameMarker: string) : longint;
var
  i
, MrkPickedList : longint;
{
  i := 0;
  // сохраняем в маркер, то что есть в Pick.wList = pwList
  MrkPickedList := InitMarker(strNameMarker, 8, 100, 10, False);
  ClearMarker(MrkPickedList);

  if ( lPMarker.RecordExists Pick where (( pwList == Pick.wList )) = tsOk )
    lPMarker._Loop Pick where (( pwList == Pick.wList ))
    {
      InsertMarker(MrkPickedList, lPMarker.Pick.cRec);
      i++;
    }

  if ( i > 0 )
    DoneMarker(MrkPickedList, strNameMarker)
  else
    DoneMarker(MrkPickedList, '');

  CopyPickInMarker := i;
};

//------------------------------------------------------------------------------
// pwMode = 0 - удалять из Pick, очистить маркер после восстановления Pick
//          1 - удалять из Pick
//          2 - очистить маркер после восстановления Pick
Function CopyMarkerInPick(strNameMarker: string; pwList, pwMode: word) : longint;
var
  MrkPickedList : longint;
  boRestorePick : boolean;
  mCount
, i
, iNum
, iPrevNum : longint;
  cRecElem : comp;
{
  if ( Trim(strNameMarker) = '')
    Exit;

  boRestorePick    := False;
  CopyMarkerInPick := 0;

  MrkPickedList := InitMarker(strNameMarker, 8, 100, 10, False);
  mCount        := GetMarkerCount(MrkPickedList);

  if ((pwMode = 0) OR ((pwMode AND 1) = 1))
    DelPick( pwList );

  iPrevNum := 0;

  if Not ((pwMode = 0) OR ((pwMode AND 1) = 1))
    if ( lPMarker.GetLast Pick where ((pwList == Pick.wList)) = tsOk )
      iPrevNum := lPMarker.Pick.PickNum;

  FOR(i := 0; i < mCount; i++)
    if GetMarker(MrkPickedList, i, cRecElem)
      {
        iNum++;

        lPMarker.ClearBuffer(lPMarker.tnPick);

        lPMarker.Pick.wList   := pwList;
        lPMarker.Pick.PickNum := iPrevNum + iNum;
        lPMarker.Pick.PickKol := 0;
        lPMarker.Pick.cRec    := cRecElem;

        if ( pwList = 11 )
          lPMarker.Pick.FilialNo := 1;

        if ( lPMarker.insert current Pick <> tsOk )
          iNum--;
      }

  if ((pwMode = 0) OR ((pwMode AND 2) = 2))
    ClearMarker(MrkPickedList);

  DoneMarker(MrkPickedList, strNameMarker);

  CopyMarkerInPick := iNum;
}


//------------------------------------------------------------------------------
// служит для чистки логов компиляции
// ни где не вызывается
Function MyWarningKiller : boolean;
var w : TNumPick;
{
  MyWarningKiller := True;
  Marker2PickRepEx('', 0, w);
  SetKatOrgDescrMarker;
}
