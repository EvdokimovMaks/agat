//********************************************************************************
//                                                        (c) корпорация Галактика
// Галактика 5.85 - логистика
// Функции для работы с маркерами и таблицами PickRep, Pick при выборе фильтров
//********************************************************************************

#Info Лучше использовать методы pMarkFun.vih вместо дублирующих функций в данной vpp

Create view lPMarker
Var
  pUserDeskRep: comp;
From
  PickRep
, Pick
, KatOrgDescr
;

Function CheckPickRep(wListSour : word): boolean;
{
  Result := ( lPMarker.RecordExists PickRep where (( UserID       == PickRep.cUser        and
                                                     pUserDeskRep == PickRep.cUserDeskRep and
                                                     wListSour    == PickRep.wList )) = tsOk );
}

Procedure DelPickRep(wListSour : word);
{
  lPMarker.pUserDeskRep := UserDeskRep.nRec;

  if CheckPickRep(wListSour)
    lPMarker.delete PickRep where (( UserID       == PickRep.cUser        and
                                     pUserDeskRep == PickRep.cUserDeskRep and
                                     wListSour    == PickRep.wList ))
  else
    lPMarker.delete PickRep where (( UserName     == PickRep.OwnName      and
                                     pUserDeskRep == PickRep.cUserDeskRep and
                                     wListSour    == PickRep.wList ));
}

// Пересчет выбранных элементов в PickRep
Function CountPickRep(wListSour : word) : TNumPick;
{
  lPMarker.pUserDeskRep := UserDeskRep.nRec;

  Result := 0;

  if CheckPickRep(wListSour)
  {
    lPMarker._LOOP PickRep where (( UserID       == PickRep.cUser        and
                                    pUserDeskRep == PickRep.cUserDeskRep and
                                    wListSour    == PickRep.wList ))
      Result++
  }
  else
  {
    lPMarker._LOOP PickRep where (( UserName     == PickRep.OwnName      and
                                    pUserDeskRep == PickRep.cUserDeskRep and
                                    wListSour    == PickRep.wList ))
      Result++;
  }
}

// Перегон из Marker'а в PickRep
Procedure Marker2PickRep(mrkName : string; wList : word; var cRescomp : comp; var NumPick : TNumPick);
var
  i, cMarker, cCount : longint;
  PickRec            : comp;
{
  cMarker := InitMarker(mrkName, 8, 100, 10);
  NumPick := 0;
  cCount  := GetMarkerCount(cMarker);

  FOR(i := 0; i < cCount; i++)
    if GetMarker(cMarker, i, PickRec)
      {
        lPMarker.ClearBuffer(lPMarker.tnPickRep);

        lPMarker.PickRep.cUser        := UserID;
        lPMarker.PickRep.OwnName      := UserName;
        lPMarker.PickRep.wList        := wList;
        lPMarker.PickRep.cRec         := PickRec;
        lPMarker.PickRep.PickNum      := i;
        lPMarker.PickRep.cUserDeskRep := UserDeskRep.nRec;

        if ( lPMarker.insert current PickRep = tsOk )
          NumPick++;
      }

  if ( NumPick = 1 )
    {
      set cRescomp := lPMarker.PickRep.cRec;
      DelPickRep(wList);
    }
  else
    set cRescomp := 0;

  DoneMarker(cMarker, mrkName);
}

Procedure Marker2PickRepEx(mrkName : string; wList : word; var NumPick : TNumPick);
var
  i, cMarker, cCount : longint;
  PickRec            : comp;
{
  cMarker := InitMarker(mrkName, 8, 100, 10);
  NumPick := 0;
  cCount  := GetMarkerCount(cMarker);

  FOR(i := 0; i < cCount; i++)
    if GetMarker(cMarker, i, PickRec)
      {
        lPMarker.ClearBuffer(lPMarker.tnPickRep);

        lPMarker.PickRep.cUser        := UserID;
        lPMarker.PickRep.OwnName      := UserName;
        lPMarker.PickRep.wList        := wList;
        lPMarker.PickRep.cRec         := PickRec;
        lPMarker.PickRep.PickNum      := i;
        lPMarker.PickRep.cUserDeskRep := UserDeskRep.nRec;

        if ( lPMarker.insert current PickRep = tsOk )
         NumPick++;
      }

  DoneMarker(cMarker, mrkName);
}

// Перегон из PickRep в Marker
Procedure PickRep2Marker (mrkName : string; wList : word; cRescomp : comp);
// cRescomp = 0 если множ.выбор и <> 0 если единичный
var
  cMarker : longint;
{
  lPMarker.pUserDeskRep := UserDeskRep.nRec;

  cMarker := InitMarker(mrkName, 8, 100, 10);

  ClearMarker(cMarker);

  if ( cRescomp <> 0 )
    InsertMarker(cMarker, cRescomp)
  else
    if CheckPickRep(wList)
    {
      lPMarker._LOOP PickRep noVisual where (( UserID       == PickRep.cUser        and
                                               pUserDeskRep == PickRep.cUserDeskRep and
                                               wList        == PickRep.wList ))
        InsertMarker(cMarker, lPMarker.PickRep.cRec);
    }
    else
    {
      lPMarker._LOOP PickRep noVisual where (( UserName     == PickRep.OwnName      and
                                               pUserDeskRep == PickRep.cUserDeskRep and
                                               wList        == PickRep.wList ))
        InsertMarker(cMarker, lPMarker.PickRep.cRec);
    }

  DoneMarker(cMarker, mrkName);
}

Procedure DelPick(wListSour: word);
{
  lPMarker.delete Pick where (( wListSour == Pick.wList ));
}

Procedure Pick2PickRepBody(bZero : boolean; wListSour, wListDest : word; var cRescomp : comp; var NumPick : TNumPick);
{
  NumPick := 0;

  lPMarker._LOOP Pick noVisual where (( wListSour == Pick.wList ))
    {
      // Не включаем нулевые нреки
      if ( not bZero and ( lPMarker.Pick.cRec = 0 ) )
        Continue;

      lPMarker.ClearBuffer(lPMarker.tnPickRep);

      lPMarker.PickRep.nRec         := 0;
      lPMarker.PickRep.cUser        := UserID;
      lPMarker.PickRep.OwnName      := UserName;
      lPMarker.PickRep.wList        := wListDest;
      lPMarker.PickRep.cRec         := lPMarker.Pick.cRec;
      lPMarker.PickRep.PickKol      := lPMarker.Pick.PickKol;
      lPMarker.PickRep.PickNum      := lPMarker.Pick.PickNum;
      lPMarker.PickRep.cUserDeskRep := UserDeskRep.nRec;

      if ( lPMarker.insert current PickRep = tsOk )
        NumPick++;
    }

  if ( NumPick = 1 )
    {
      cRescomp := lPMarker.PickRep.cRec;
      DelPickRep(wListDest);
    }
  else
    cRescomp := 0;
}

Procedure Pick2PickRep(wListSour, wListDest : word; var cRescomp : comp; var NumPick : TNumPick);
{
  Pick2PickRepBody(False, wListSour, wListDest, cRescomp, NumPick);
}

//  (Pick.cRec = 0)  тоже копируется
Procedure Pick2PickRepEx(wListSour, wListDest : word; var cRescomp : comp; var NumPick : TNumPick);
{
  Pick2PickRepBody(True, wListSour, wListDest, cRescomp, NumPick);
}

Procedure AddPickRec(wListDest: word; pRec: comp; pKol: double; pNum: longint);
{
  lPMarker.ClearBuffer(lPMarker.tnPick);

  lPMarker.Pick.nRec    := 0;
  lPMarker.Pick.wList   := wListDest;
  lPMarker.Pick.cRec    := pRec;
  lPMarker.Pick.PickKol := pKol;
  lPMarker.Pick.PickNum := pNum;

  if ( wListDest = 11 )
    lPMarker.Pick.FilialNo := 1;

  lPMarker.insert current Pick;
}

Procedure PickRep2Pick(wListSour, wListDest : word; cRescomp : comp);
{
  lPMarker.pUserDeskRep := UserDeskRep.nRec;

  DelPick(wListDest);

  if ( cRescomp <> 0 )
    AddPickRec(wListDest, cRescomp, 0, 0)
  else
    if CheckPickRep(wListSour)
    {
      lPMarker._LOOP PickRep NoVisual where (( UserID       == PickRep.cUser        and
                                               pUserDeskRep == PickRep.cUserDeskRep and
                                               wListSour    == PickRep.wList ))
        AddPickRec(wListDest, lPMarker.PickRep.cRec, lPMarker.PickRep.PickKol, lPMarker.PickRep.PickNum);
    }
    else
    {
      lPMarker._LOOP PickRep NoVisual where (( UserName     == PickRep.OwnName      and
                                               pUserDeskRep == PickRep.cUserDeskRep and
                                               wListSour    == PickRep.wList ))
        AddPickRec(wListDest, lPMarker.PickRep.cRec, lPMarker.PickRep.PickKol, lPMarker.PickRep.PickNum);
    }
}

// Заполнение маркера KatOrgDescr на основе маркера KatOrg
Procedure SetKatOrgDescrMarker;
var
  cKatOrg, cKatOrgDescr, mCount, i : longint;
  cRec                             : comp;
{
  cKatOrg      := InitMarker('KatOrg',      8, 100, 10);
  cKatOrgDescr := InitMarker('KatOrgDescr', 8, 100, 10);

  ClearMarker(cKatOrgDescr);

  mCount := GetMarkerCount(cKatOrg);

  FOR(i := 0; i < mCount; i++)
  {
    if GetMarker(cKatOrg, i, cRec)
      if ( lPMarker.GetFirst KatOrgDescr where (( cRec == KatOrgDescr.cRec )) = tsOk )
        InsertMarker(cKatOrgDescr, lPMarker.KatOrgDescr.nRec);
  }

  DoneMarker(cKatOrg,      'KatOrg');
  DoneMarker(cKatOrgDescr, 'KatOrgDescr');
}

//------------------------------------------------------------------------------
Function CopyPickInMarker(pwList: word; strNameMarker: string) : longint;
var
  MrkPickedList : longint;
{
  Result := 0;
  // сохраняем в маркер, то что есть в Pick.wList = pwList
  MrkPickedList := InitMarker(strNameMarker, 8, 100, 10, False);
  ClearMarker(MrkPickedList);

  if ( lPMarker.RecordExists Pick where (( pwList == Pick.wList )) = tsOk )
    lPMarker._Loop Pick where (( pwList == Pick.wList ))
    {
      InsertMarker(MrkPickedList, lPMarker.Pick.cRec);
      Result++;
    }

  if ( Result > 0 )
    DoneMarker(MrkPickedList, strNameMarker)
  else
    DoneMarker(MrkPickedList, '');
}

//------------------------------------------------------------------------------
// pwMode = 0 - удалять из Pick, очистить маркер после восстановления Pick
//          1 - удалять из Pick
//          2 - очистить маркер после восстановления Pick
Function CopyMarkerInPick(strNameMarker: string; pwList, pwMode: word) : longint;
var
  MrkPickedList : longint;
  boRestorePick : boolean;
  mCount
, i
, iNum
, iPrevNum : longint;
  cRecElem : comp;
{
  if ( Trim(strNameMarker) = '')
    Exit;

  boRestorePick := False;
  Result := 0;

  MrkPickedList := InitMarker(strNameMarker, 8, 100, 10, False);
  mCount        := GetMarkerCount(MrkPickedList);

  if ((pwMode = 0) OR ((pwMode AND 1) = 1))
    DelPick( pwList );

  iPrevNum := 0;

  if Not ((pwMode = 0) OR ((pwMode AND 1) = 1))
    if ( lPMarker.GetLast Pick where ((pwList == Pick.wList)) = tsOk )
      iPrevNum := lPMarker.Pick.PickNum;

  FOR(i := 0; i < mCount; i++)
    if GetMarker(MrkPickedList, i, cRecElem)
      {
        iNum++;

        lPMarker.ClearBuffer(lPMarker.tnPick);

        lPMarker.Pick.wList   := pwList;
        lPMarker.Pick.PickNum := iPrevNum + iNum;
        lPMarker.Pick.PickKol := 0;
        lPMarker.Pick.cRec    := cRecElem;

        if ( pwList = 11 )
          lPMarker.Pick.FilialNo := 1;

        if ( lPMarker.insert current Pick <> tsOk )
          iNum--;
      }

  if ((pwMode = 0) OR ((pwMode AND 2) = 2))
    ClearMarker(MrkPickedList);

  DoneMarker(MrkPickedList, strNameMarker);

  Result := iNum;
}
