//------------------------------------------------------------------------------
//                                                      (c) корпорация Галактика
// Галактика 5.80 - модуль "Платежный календарь"
// Построитель деревьев
//------------------------------------------------------------------------------

/*
   Для построения простейшего дерева
 1. Tree_Init                         - начало построения (передача параметров)
 2. Внутри цикла по анализируемой таблице
    2.1. AddLevel_Start               - начало добавления ветки
    2.2. AddLevel_Tab or AddLevel_Kau - добавление уровня (можно в цикле)
    2.3. AddLevel_Finish              - завершение добавления ветки
    2.4. Sums_AddToNode               - добавления сумм к ветке
 3. Tree_Done                         - завершение построения (можно не делать)

!   Подключение:
! #include aTreeNew.vih //  iTree, TStructOut, ObjTreeNames
*/

#ifndef __ATreeNEW__
#define __ATreeNEW__
//******************************************************************************
#ifdef ComponentVersion
#component "F_TreeNEW"
#end
//******************************************************************************
#include ofpdef.vpp

#include aTreeOut.vpp // Описание таблиц для построителя деревьев
#include aTreeNam.vih // Описание уровней для построителя деревьев

#doc
Построитель деревьев
#end
ObjInterface objTreeNew;

  //////////////////// ФУНКЦИИ ИНИЦИАЛИЗАЦИИ /////////////////////////////////
  #doc
  Инициализация: номер отчета и число сумм
  #end
  Function  Tree_Init(_pObj: ObjTreeNames; _nReport: word; _NumSums: word): boolean;

  #doc
  Деинициализация (после построения дерева)
  #end
  Function  Tree_Done: boolean;

  #doc
  Название для папки Итого
  #end
  Procedure Tree_SetItogoName(_sName: TName);

  #doc
  Установка текущего отчета
  #end
  Procedure Tree_SetNReport(_nReport: word);

  #doc
  Есть привязки к документам
  #end
  Procedure Tree_SetHasDocs(_HasDocs: boolean);

  #doc
  Изменение объекта, из которого берутся имена и сортировки уровней
  #end
  Procedure Tree_SetObj(_pObj: ObjTreeNames);

  #doc
  Имя, чтобы группы с одинаковыми названиями могли быть различными в дереве
  #end
  Procedure Tree_SetInvisibleLen(_level: word; _len: word);

  #doc
  Уровень, который нельзя удалять <i>(используется при удалении пустых групп)</i>
  #end
  Procedure Tree_SetLevNotDelete(_LevNotDelete: word);

  #doc
  Открывать организации как КАУ (для иерархических аналитических отчетов)
  #end
  Procedure Tree_SetOpenOrgAsKau(_OpenOrgAsKau: boolean);

  #doc
  Документ, разделенный на части, отображать в папках по 1 разу
  #end
  Procedure Tree_SetDocOneInNodes(_DocOneInNodes: boolean);

  #doc
  Способ подсчета сумм на узлах
  #end
  procedure Tree_SetTotalsByChildren(Value: boolean);

  #doc
  Число уровней иерархии
  #end
  Function  Tree_GetMaxLevelN(_nReport: word): word;

  #doc
  Возвращает имена в ветке
  #end
  Function Branch_GetName(_cNode: comp): string;

  /////////////////////// РАБОТА С СУММАМИ ///////////////////////////////////
  #doc
  Пересчет сумм всего дерева
  #end
  Function  Sums_RecountAll(_nReport: word; _SumsNpp: word): boolean;

  #doc
  Пересчет указанной суммы всего дерева
  #end
  Function  Sums_RecountCur(_nReport: word; _SumsNpp: word; _SumN: word): boolean;

  #doc
  Пересчет сумм всего дерева
  #end
  Function Branch_RecountAll(_cNode: comp; _SumsNpp: word): boolean;

  #doc
  Привязывает суммы к указанному листу
  #end
  Function  Sums_AddToNode(_cRec: comp; _pTreeSums: TPTreeSums; _Npp: word): boolean;

  #doc
  Добавление сумм к уровням всего дерева
  #end
  Function  Sums_AddToTree(_nReport: word; _SumsNpp: word): boolean;

  #doc
  Добавляет сумму по всей ветке снизу вверх
  #end
  Function  Sums_AddOneToBranch(_cNode: comp; _SumsNpp: word; _nSum: word; _Sum: double): boolean;

  #doc
  Добавляет все суммы вверх от указанного узла
  #end
  Function Sums_AddFromNodeToBranch(_cNode: comp; _wDirect: word): boolean;

  ////////////////////// ПОСТРОЕНИЕ ДЕРЕВА ///////////////////////////////////
  #doc
  Добавляет уровень и возвращает ссылку на sTempDescr
  #end
  Function  AddLevel_Tab(_Level: word; _wTable  : word; _cTable: comp): comp;

  #doc
  Добавляет уровень и возвращает ссылку на sTempDescr (расширенный вариант)
  #end
  function  AddLevel_Tab2(_Level: word; _wTable: word; _cTable: comp; isHier: boolean; _MaxLevels: word): comp;

  #doc
  Добавляет уровень КАУ (и возвращает ссылку на sTempDescr)
  #end
  Function  AddLevel_Kau(_Level: word; _wTable: word; _cTable: comp; _isKauIer: word; _cTopRec: comp): comp;

  #doc
  Добавляет уровень КАУ с учетом количества максимально раскрываемых уровней КАУ
  #end
  Function  AddLevel_KauIerByNum(_Level: word; _wTable: word; _cTable: comp;
                                 _isKauIer: word; _NumLevels: word): comp;

  #doc
  Начало формирования ветки
  #end
  Function  AddLevel_Start(var _rStructOut: TStructOut): boolean;

  #doc
  Завершение формирования ветки (с добавлением листьев и привязок к документам)
  #end
  Function  AddLevel_Finish: comp;

  ///////////////// ПЕРЕНОС ВЕТКИ НА НОВОЕ МЕСТО /////////////////////////////
  #doc
  Удаление ветки по ссылке на узел (возвращает уровень, до которого удалили)
  #end
  Function  Branch_DelByGroup(_cNode: comp; var _retNode: comp): boolean;

  #doc
  То же, но вначале находим узел по ссылке на запись
  #end
  Function  Branch_DelByGroupRec(_Code: word; _RecType: word; _cRec: comp): boolean;

  #doc
  То же, но по маркеру - записи указанного типа (маркер удаляет)
  #end
  Function  Branch_DelByMarker(_markTree: longint; _RecType: word): boolean;

  #doc
  Удаление веток по помеченным записям, если нет - по группе
  #end
  Function  Branch_DelByMarkerOrGroup(_markTree: longint; _cNode: comp; _RecType: word): boolean;

  #doc
  Помещает ветку в маркер (для пометки уровня)
  #end
  Function  Branch_ToFromMarker(_Code: word; _cNode: comp; _marker: longint; _ToFrom: boolean): boolean;

  ////////////////// РАБОТА С АНАЛИТИКОЙ ДЕРЕВА //////////////////////////////
  #doc
  По ветке заполняет контейнер аналитик (начиная с указанного узла) до _cTill - прочие (если _cTill <> 0)
  #end
  Function Analitic_FillCont(_cLeaf: comp; _cTill: comp; var _ContAn: longint): boolean;

  #doc
  По узлу из ветки заполняет контейнер аналитикой всей ветки
  #end
  Function Analitic_FillContFrom(_cNode: comp; var _ContAn: longint): boolean;

  #doc
  По контейнеру аналитик строит ветку (начиная с указанного узла)
  #end
  Function Analitic_MakeBrach(_rStructOut: TStructOut; _cNode, _cLeaf: comp; _ContAn: longint): comp;

  #doc
  Интерфейс редактирования аналитик текущей ветки
  #end
  Function Analitic_RunWin(_ContAn: longint): boolean;


  #doc
  Редактирование аналитик ветки с перестроением
  #end
  Function Analitic_RunEdit(_rStructOut: TStructOut; _cNode: comp; _cLeaf: comp): comp;

  #doc
  Строит ветку с проверкой на существование уже с такой аналитикой
  #end
  Function Analitic_MakeBrachChecked(_rStructOut: TStructOut; _cNode: comp;
                                     _ContOld, _ContNew: longint;
                                     var _recLeaf: comp): boolean;

  #doc
  Находит первую указанную аналитику в ветке при проходе снизу вверх
  #end
  Function Analitic_FindInBranch(_cNode: comp; _wKau: word): comp;

  ////////// ДОБАВЛЕНИЕ ГРУППЫ ВО ВСЕ ДЕРЕВО НА УКАЗАННЫЙ УРОВЕНЬ /////////////////
  #doc
  Очистка
  #end
  Procedure AddGroup_Start;

  #doc
  Очистка
  #end
  Procedure AddGroup_Finish;

  #doc
  Перед добавлением запоминаем уровни, к которым надо добавлять
  #end
  Function  AddGroup_RememberBywTable(_Code: word; _wTable: word; _isKau: word): boolean;

  #doc
  То же, но еще и по _cTable
  #end
  Function  AddGroup_RememberBycTable(_Code: word; _wTable: word; _cTable: comp; _isKau: word): boolean;

  #doc
  То же, но по Param
  #end
  Function  AddGroup_RememberByParam(_Code: word; _Param: word): boolean;

  #doc
  То же, но по Param и уровнем, не меньше указанного
  #end
  Function AddGroup_RememberByParamLevel(_Code: word; _Param: word; _MinLevel: word): boolean;

  #doc
  То же, но по Номеру уровня
  #end
  Function  AddGroup_RememberByLevel(_Code: word; _Level: word): boolean;

  #doc
  То же, но по номеру уровня в указанной ветке
  #end
  Function  AddGroup_RememberByBranch(_cLeaf: comp; _Level: word): boolean;

  #doc
  Добавление уровня к запомненным в Remember записям
  #end
  Function  AddGroup_ToRemembered(_wTable: word; _cTable: comp; _IsKau: word; _IsKauIer: word): boolean;

  #doc
  Добавление контейнера аналитик к запомненным в Before записям
  #end
  Function AddGroup_ContAnToRemembered(_ContAn: longint; _IsKauIer: word): boolean;

  ///////////////////// РАБОТА С МАРКЕРОМ ////////////////////////////////////
  #doc
  Записывает в маркер доки группы указанного типа (возвращает количество записей)
  #end
  Function  GetGroupDocs(_marker: longint; _cNode: comp; _RecType: word): word;

  #doc
  Записывает в маркер помеченные записи
  #end
  Function  GetMarkerDocs(_markTree: longint; _markDocs: longint; _RecType: word): word;

  #doc
  Записывает в маркер помеченные записи, если нет - записи группы (или текущую)
  #end
  Function  GetMarkerOrGroupDocs(_markTree: longint; _markDocs: longint; _cNode: comp; _RecType: word): word;

  #doc
  Из маркера достает узлы с указанным типом и записывает в новый маркер
  #end
  Function GetMarkerWithType(_type: word; _markTree: longint; _markWithType: longint): longint;

  #doc
  Тестовое окно (можно повесить на скрытую горячую клавишу)
  #end
  Procedure SeeTestWindow(_sTitle: string);

  /////////////////// РАБОТА С НАСТРОЙКОЙ ////////////////////////////////////
  #doc
  Формирование структуры дерева из настройки
  #end
  Function Tune_AddLevelIer(_Code: word; _nLevel: word; _wTable: word;
                            _LevelName: string; _LevelPrefix: string;
                            _IsIer: word; _NumOpenedLevels: word): boolean;

  #doc
  Формирование структуры дерева из настройки
  #end
  Function  Tune_AddLevel(_Code: word; _nLevel: word; _wTable: word): boolean;

  #doc
  Удаление записи из описания иерархии по коду таблицы
  #end
  Function  Tune_DelLevel(_Code: word; _wTable: word): boolean;

  #doc
  Количество уровней
  #end
  Function  Tune_Number(_Code: word): word;

  #doc
  Перенумеруем, чтобы номера шли через 1
  #end
  Function  Tune_Numbering(_Code: word): boolean;

  #doc
  Номер уровня в настройке, на котором находится таблица
  #end
  Function  Tune_GetLevel(_Code: word; _wTable: word): word;

  #doc
  Количество раскрываемых уровней иерархии
  #end
  Function Tune_GetIerNumber(_Code: word; _wTable: word; var _isIer: word; var _numLevels: word): boolean;

  #doc
  То же, но в уже построенном дереве (учитывая раскрытую аналитику)
  #end
  Function  Tree_GetLevel(_Code: word; _wTable: word; _isKau: word; _isOpened: word): word;

  #doc
  Таблица
  #end
  Function  Tune_GetTable(_Code: word; _nLevel: word): word;

  #doc
  Удаление всей настройки
  #end
  Function  Tune_Clear(_Code: word): boolean;

  #doc
  Заполнение по таблице RepGrLst с уровня _fromLevel (обычно = 1)
  (например, заполнялись в pump.vpp, ссылка - в UserDeskRep)
  #end
  Function Tune_FillByPumped(_Code: word; _fromLevel: word; _cGroup: comp): boolean;

  #doc
  Заполнение по таблице SpRepOne с уровня _fromLevel (обычно = 1)
  (например, _cTune = UserDeskRep.nRec)
  #end
  Function Tune_FillBySpRepOne(_Code: word; _fromLevel: word; _cTune: comp): boolean;

  #doc
  Количество сортировок на указанном уровне (0-листовой)
  #end
  Function TuneSort_Number(_Code: word; _Level: word): word;

  #doc
  Заполняет массив сортировкой (пока листьев)
  #end
  Function TuneSort_FillByPumped(_Code: word; _cGroup: comp; _cSort: comp): boolean;

  #doc
  Поиск сортировки
  #end
  Function TuneSort_GetByNpp(_Code: word; _Level: word; _Npp: word): word;

  ///////////////////// ОТЧЕТЫ ПО ДЕРЕВЬЯМ ///////////////////////////////////
  #doc
  По группе формируем, а стоим на листе - False
  #end
  Function TreeRep_CheckMakeReport(_byGroup: boolean; _isLeaf: word): boolean;

  ///////////////////// РАЗЛИЧНЫЕ АТРИБУТЫ ///////////////////////////////////
  #doc
  По ссылке на запись находит лист
  #end
  Function Tree_FindLeafByRec(_Code: word; _RecType: word; _cRec: comp): comp;

  #doc
  Узел на один уровень выше указанного
  #end
  Function Tree_GetAboveNode(_cNode: comp): comp;

  #doc
  Уровень указанного типа, вышестоящий для текущего листа
  #end
  Function Tree_FindRecByType(_cNode: comp; _wTable: word; _isKau: word; var _retValue: comp): boolean;

  #doc
  Событие для динамического переопределения наименования аналитики
  #end
  Event Procedure Event_GetKauName(_wAn: word; _cAn: comp; var _Value: string;
                                   var _isGet: boolean; _Level: word);

  #doc
  Событие для динамического переопределения кода аналитики
  #end
  Event Procedure Event_GetKauCode(_wAn : word; _cAn : comp; var _Value : string; var _isGet : boolean);
  #doc
  Событие для динамического переопределения вышестоящей аналитики
  #end
  Event Procedure Event_GetKauNode(_wAn : word; _cAn : comp; var _Value : comp  ; var _isGet : boolean);

End; //objTreeNew

ObjInterface objTreeNew1 (objTreeNew);
  #doc
  Код КАУ если coKauReff. Использовать сразу после Tune_GetTable;
  #end
  Function Tune_GetKAUCode: word;
  #doc
  Формирование структуры дерева из настройки (с возможность указать Код КАУ)
  #end
  Function Tune_AddLevelIerEx(_Code: word; _nLevel: word; _wTable: word;
                              _LevelName: string; _LevelPrefix: string;
                              _IsIer: word; _NumOpenedLevels: word; _wKAU: word): boolean;

End; //objTreeNew


VipInterface iTreeNew implements objTreeNew1
  #Licensed_Free
;
//******************************************************************************
#end //__ATreeNEW__
