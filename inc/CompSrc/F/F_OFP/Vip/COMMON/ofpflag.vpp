//------------------------------------------------------------------------------
//                                                      (c) корпорация Галактика
// Галактика 5.80 - модуль "Платежный календарь"
// Функции для работы с флагами/битовыми масками
//------------------------------------------------------------------------------

// -----------------------------------------------------------------------------
// устанавливает бит
Function BitOn(var _Field: word; n: word): boolean;
{
  BitOn := False;
  _Field := _field or (word(1) shl n);
}

// -----------------------------------------------------------------------------
// сбрасывает бит
Function BitOff(var _Field: word; n: word): boolean;
{
  BitOff := False;
  _Field := _field and word(not (word(1) shl n));
}

// -----------------------------------------------------------------------------
// установлен ли бит
Function IsBit(_Field: word; n: word): boolean;
{
  IsBit := (((_Field shr n) and word(1)) = 1);
}

// -----------------------------------------------------------------------------
// выключение нескольких битов
Function BitsOff(var _Field: word; _maska: word): boolean;
{
  BitsOff := False;
  _Field := _field and word(not _maska);
}

// -----------------------------------------------------------------------------
// выключить флаг
Function FlagOff(var num: word; n1: word): boolean;
{
  if (n1 < 1) or (n1 > 16)
    FlagOff := False;
  else
  {
    BitOff(num, n1 - 1);
    FlagOff := True;
  }
}

// -----------------------------------------------------------------------------
// включить флаг
Function FlagOn(var num: word; n1: word): boolean;
{
  if (n1 < 1) or (n1 > 16)
    FlagOn := False;
  else
  {
    BitOn(num, n1 - 1);
    FlagOn := True;
  }
}

// -----------------------------------------------------------------------------
// установлен ли флаг
Function IsFlagWord(num: word; n1: word): boolean;
{
  if (n1 = 0) // какой-нибудь флаг
  {
    if (num <> 0)
      IsFlagWord := True;
    else
      IsFlagWord := False;
  }
  else        // указанный флаг (1..N)
      IsFlagWord := IsBit(num, n1-1);
}

// -----------------------------------------------------------------------------
// инвертировать в маске num бит n1  (не тестировано)
Function FlagInvert(var num: word; n1: word): boolean;
{
  Var _NullWord: word;
  _NullWord := word(0);

  BitOn( _NullWord, n1); // может и num xor Not ( BitOn( Empty_num, n1));
  num := num xor _NullWord;

  FlagInvert := True;
}

// -----------------------------------------------------------------------------
// устанавливает бит
Function LBitOn(var _Field: longint; n: longint): boolean;
{
  LBitOn := False;
  _Field := _field or (word(1) shl n);
}

// -----------------------------------------------------------------------------
// сбрасывает бит
Function LBitOff(var _Field: longint; n: longint): boolean;
{
  LBitOff := False;
  _Field := _field and (not (word(1) shl n));
}

// -----------------------------------------------------------------------------
// установлен ли бит
Function LIsBit(_Field: longint; n: longint): boolean;
{
  LIsBit := (((_Field shr n) and word(1)) = 1);
}

// -----------------------------------------------------------------------------
// выключение нескольких битов
Function LBitsOff(var _Field: longint; _maska: longint): boolean;
{
  LBitsOff := False;
  _Field := _field and (not _maska);
}

// -----------------------------------------------------------------------------
// выключить флаг
Function LFlagOff(Var num: longint; n1: longint): boolean;
{
  if (n1 < 1) or (n1 > 16)
    LFlagOff := False;
  else
  {
    LBitOff(num, n1 - 1);
    LFlagOff := True;
  }
}

// -----------------------------------------------------------------------------
// включить флаг
Function LFlagOn(var num: longint; n1: longint): boolean;
{
  if (n1 < 1) or (n1 > 16)
    LFlagOn := False;
  else
  {
    LBitOn(num, n1 - 1);
    LFlagOn := True;
  }
}

// -----------------------------------------------------------------------------
// установлен ли флаг
Function IsFlagLong( num: longint; n1: longint): boolean;
{
  if (n1 = 0) // какой-нибудь флаг
  {
    if (num <> 0)
      IsFlagLong := True;
    else
      IsFlagLong := False;
  }
  else        // указанный флаг (1..N)
      IsFlagLong := LIsBit(num, n1-1);
}

// -----------------------------------------------------------------------------
// инвертировать в маске num бит n1  (не тестировано)
Function LFlagInvert(var num: longint; n1: longint): boolean;
{
  Var _NullWord: longint;
  _NullWord := longint(0);

  LBitOn( _NullWord, n1);
  num := num xor _NullWord;

  LFlagInvert := True;
}

// -----------------------------------------------------------------------------
// степень двойки
Function MyStepen2(_st: word): longint;
var res: longint;
{
  res := 1;
  while _st > 0
  {
     res := res * 2;
     _st := _st - 1;
  }
  MyStepen2 := res;
}
// -----------------------------------------------------------------------------
// часть поля (логич.) по полю (UnPack) _Source - родитель; _Target - потомок
Function FldToFld( _Source: word   // Big
                 ; _Target: word   // Small
                  ; _Begin: byte
                   ; _Long: byte
                 ; _Initer: word
                         ): word;  // Not Initer
{
  Var __iCur: byte;
  FldToFld := If( _Initer = 0
                 , _Target    // BigToSmall (Pack)
                 , _Source);  // SmallToBig (UnPack)

  for(__iCur := 0; __iCur < _Long; Inc(__iCur) )
    If (( IsBit(  _Source, __iCur) != IsBit( _Target, __iCur + _Begin)) )
      FldToFld := FldToFld xor word( 1b shl (__iCur + _Begin));
}

// -----------------------------------------------------------------------------
// часть поля (логич.) по полю (UnPack) _Source - родитель; _Target - потомок
Function FldInFld( _Source: word
                  ; _Begin: byte
                   ; _Long: byte
                         ): word;
{
  Var __Target: word;
  __Target := 0;
  Var __iCur: byte;
!    If ( IsBit( __Target, __iCur) != IsBit( _Source, __iCur + _Begin ))
  for (__iCur := 0; __iCur < _Long; Inc(__iCur) )
    If IsBit( _Source, __iCur + _Begin)
      BitOn( __Target, __iCur);
!      __Target := __Target xor ( 1b shl __iCur);

  FldInFld := __Target;
}

// -----------------------------------------------------------------------------
// поле (логич.) по части поля  (Pack) _Source - потомок; _Target - родитель
Function FldOutFld( _Source: word
                  ; _Target: word
                   ; _Begin: byte
                    ; _Long: byte
                          ): word;
{
  Var __iCur: byte;
  for(__iCur := 0; __iCur < _Long; Inc(__iCur) )
  {
    If (( IsBit(  _Source, __iCur) != IsBit( _Target, __iCur + _Begin)) )
      _Target := _Target xor word( 1b shl (__iCur + _Begin));
  }

  FldOutFld := _Target;
}
