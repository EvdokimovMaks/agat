/*
 ╔═══════════════════════════════════════════════════════════════════════════╗
 ║                     (c) 1994,97 корпорация ГАЛАКТИКА                      ║
 ║ Проект        : ГАЛАКТИКА                                                 ║
 ║ Система       : Производственное планирование                             ║
 ║ Версия        : 6.00                                                      ║
 ║ Назначение    : Редактирование спецификации производственной программы    ║
 ║ Ответственный : Сенькевич Игорь Казимирович (IGORS)                       ║
 ║ Параметры     : есть                                                      ║
 ╚═══════════════════════════════════════════════════════════════════════════╝
*/

#ifndef TABMEM
#define TABMEM

table struct vtHor
(
  cNrec        : comp,
  Name         : string[80],
  TypeF        : LongInt,
  TypeHier     : comp,
  KodGrKau     : word,
  TypeGl       : LongInt,
  NumFix       : word,
  NppGrKau     : word,    // номер в группе КАU
  NumAll       : longint, // уникальный номер
  Num          : longint,
  VidSum       : longint, // что хранится
  KolSum       : word, // сколько всего значений хранится
  cMnAnal      : comp,
  cVtHor       : comp
)
with Index
(
 vtHor01 = cNrec + TypeHier + NppGrKau + VidSum,
 vtHor02 = Num,
 vtHor03 = NumAll,
 vtHor04 = cVtHor ,
 vtHor05 = NumFix,
 vtHor06 = TypeHier + KodGrKau + cNrec,
 vtHor07 = KodGrKau + cNrec + VidSum,     //???
 vtHor08 = TypeHier + VidSum + cVtHor + NumAll,
 vtHor09 = TypeHier + NumAll
 );

type TVtHor  = record as table VtHor;

table struct EditHor
(
  Name         : string[80],
  Num          : longint,
  cMnAnal      : comp
)
with Index
(
 EditHor01 = Num,
 EditHor02 = cMnAnal
 );


table struct vtVert
(
  cNrec : comp,
  wType : word,
  Num   : longint
)

with Index
(
 vtVert01 = cNrec,
 vtVert02 = Num
);

table struct TMemVid2
(
  Nrec     : comp,
  SysNum   : word,
  Num      : word,
  NameVip  : string[40],
  ABBR     : string[20],
  KolRec   : comp,
  NameRaz  : string[80],
  cRole    : comp,
  cMemo    : comp
)

with Index
(
 TMemVid200 = NRec,
 TMemVid201 = SysNum + ABBR  + Num,
 TMemVid202 = KolRec + ABBR  + Num + SysNum,
 TMemVid203 = SysNum + Num,
 TMemVid204 = SysNum + cRole + Num,
 TMemVid205 = NameRaz
);

table struct TMemClaim
(
  cNrec     : comp,
  KodGrKau  : word,
  PrMc      : word,
  dStart    : date,
  dFinish   : date,
  Kol       : double,
  cOtpED    : comp,
  cMCUSL    : comp
)

with Index
(
 TMemClaim01 = PrMc + cMCUSL + cNrec + KodGrKau
);

table struct vtHorTree
(
  cNrec        : comp,
  Name         : string[80],
  TypeF        : word,
  TypeHier     : comp,
  KodGrKau     : word,
  TypeGl       : LongInt,
  NumFix       : word,
  NppGrKau     : word,    // номер в группе КАU
  NumAll       : longint, // уникальный номер
  Num          : longint,
  VidSum       : word, // что хранится
  KolSum       : word, // сколько всего значений хранится
  cMnAnal      : comp,
  cVtHor       : comp,
  Level        : longint,   // номер уровня (0 - для корня)
  NumFather    : longint,   // номер родителя               ( какой-то  NumAll )
  NumBaby      : longint,   // номер одного из детей        ( какой-то  NumAll )
  Prev         : longint,   // предыдущий элемент на уровне ( какой-то  NumAll )
  Next         : longint    // следующий  элемент на уровне ( какой-то  NumAll )
)
with Index
(
 vtHorTree00 = NumAll,
 vtHorTree01 = TypeHier + NumAll,
 vtHorTree02 = Level    + VidSum   + NumAll,
 vtHorTree03 = TypeHier + NppGrKau + cNRec,
 vtHorTree04 = TypeHier + KodGrKau + cNRec,
 vtHorTree05 = TypeHier + Level  + NumAll,
 vtHorTree06 = TypeHier + Level  + VidSum + NumAll,
 vtHorTree07 = TypeHier + Level  + NumFather + NumAll,
 vtHorTree08 = NumFather
 );

//'для хранения объектов планирования
Table Struct tmpObject
(
 TypeIzd      : Word,
 cIzd         : tNRec
)
With Index
(
 tmpObject_01 = TypeIzd + cIzd
);

//'для хранения декомпозированных МЦ
Table Struct tmpDecomp
(
 cMC  : tNRec,
 Koef : Double,
 Owner: tNRec
)
;
//для хранения Агрегированных МЦ
Table Struct tmpAgregir
(
  NRec      : tNrec ,
  cMain     : tNrec ,  //"Ссылка на обобщенную МЦ из набора",
  cFather   : tNrec ,  //"Ссылка на родителя",
  cMC       : tNrec ,  //"Ссылка на себя МЦ",
  cSpMc     : tNrec ,  //"Ссылка на спецификацию МЦ",
  cSpMnPlan : tNrec ,  //"Ссылка на позицию документа SpMnPlan",
  Level     : Word  ,  //"уровень",
  tpPlan    : Word  ,  //"= 1 является семейством (обобщенным)",
  NAME      : tName ,
  Diskret   : word  ,  // делимость Ед.Изм. = 1 -неделимая, иначе делимая
  FlagPos   : word  ,  // флаг позиции 0 - неиспользовали
                       //              1 - забрали в tmpAgrRez полностью
                       //              2 - забрали в tmpAgrRez частично
                       //              3 - не анализировать
  KolPlan   : Double,  //"Количество из документа
  Kol       : Double,  //"Количество в комплекте",'% входимости'
  Rezult    : Double,  //"Расчетное значение  Rezult := (KolPlan/100)*Kol;
  MinRez    : Double,  //Мин. результат расчетного значения из поддерева;
  Ostatok   : Double   //остаток МЦ после агрегирования
)
With Index
(
 tmpAgregir00  = Nrec(Unique, Surrogate, Journal),
 tmpAgregir01  = cMain + cFather,
 tmpAgregir02  = tpPlan + cFather,
 tmpAgregir03  = cFather,
 tmpAgregir04  = cMC + cFather,
 tmpAgregir05  = cMC + cSpMc,
 tmpAgregir06  = cMC + tpPlan + FlagPos
)
;

Table Struct tmpAgreg
(
  NRec      : tNrec ,
  cMain     : tNrec ,  //"Ссылка на обобщенную МЦ из набора",
  cFather   : tNrec ,  //"Ссылка на родителя",
  cMC       : tNrec ,  //"Ссылка на себя МЦ",
  cSpMc     : tNrec ,  //"Ссылка на спецификацию МЦ",
  cSpMnPlan : tNrec ,  //"Ссылка на позицию документа SpMnPlan",
  Level     : Word  ,  //"уровень",
  tpPlan    : Word  ,  //"= 1 является семейством (обобщенным)",
  NAME      : tName ,
  Diskret   : word  ,  // делимость Ед.Изм. = 1 -неделимая, иначе делимая
  FlagPos   : word  ,  // флаг позиции 0 - неиспользовали
                       //              1 - забрали в tmpAgrRez полностью
                       //              2 - забрали в tmpAgrRez частично
                       //              3 - не анализировать
  KolPlan   : array[1..14] of Double,  //"Количество из документа
  Kol       : array[1..14] of Double,  //"Количество в комплекте",'% входимости'
  Rezult    : array[1..14] of Double,  //"Расчетное значение  Rezult := (KolPlan/100)*Kol;
  MinRez    : Double,  //Мин. результат расчетного значения из поддерева;
  Ostatok   : Double   //остаток МЦ после агрегирования
)
With Index
(
 tmpAgreg  = Nrec(Unique, Surrogate, Journal),
 tmpAgreg01  = cMain + cFather,
 tmpAgreg02  = tpPlan + cFather,
 tmpAgreg03  = cFather,
 tmpAgreg04  = cMC + cFather,
 tmpAgreg05  = cMC + cSpMc,
 tmpAgreg06  = cMC + tpPlan + FlagPos,
 tmpAgreg07  = Level
);


//для хранения Агрегированных МЦ
Table Struct tmpAgrRez
(
  NRec      : tNrec ,
  cMC       : tNrec ,  //"Ссылка на себя МЦ",
  cSpMnPlan : tNrec ,  //"Ссылка на позицию документа источника SpMnPlan",
  cSpMnPlan2: tNrec ,  //"Ссылка на позицию документа приемника SpMnPlan",
  NAME      : tName ,
  FlagPos   : word  ,  // флаг позиции 0 - неиспользовали
                       //              1 - использовали
  Rezult    : Double   //"Расчетное значение  Rezult := (KolPlan/100)*Kol;
)
With Index
(
 tmpAgrRez00  = Nrec(Unique, Surrogate, Journal)
)
;

Table Struct tmpAgrRez2
(
  NRec      : tNrec ,
  cMC       : tNrec ,  //"Ссылка на себя МЦ",
  cSpMnPlan : tNrec ,  //"Ссылка на позицию документа источника SpMnPlan",
  cSpMnPlan2: tNrec ,  //"Ссылка на позицию документа приемника SpMnPlan",
  NAME      : tName ,
  FlagPos   : word  ,  // флаг позиции 0 - неиспользовали
                       //              1 - использовали
  Rezult    : array[1..14] of Double   //"Расчетное значение  Rezult := (KolPlan/100)*Kol;
)
With Index
(
 tmpAgrRez200  = Nrec(Unique, Surrogate, Journal)
)
;

//для хранения всех подчиненных МЦ нижнего уровня для конкретной обобщенной МЦ
Table Struct tmpAgrBaby
(
  cOwner      : tNrec , // Владелец - обобщенная МЦ
  cBaby       : tNrec   // ссылка на подчиненную МЦ
)
With Index
(
 tmpAgrBaby00  = cOwner + cBaby
)
;

Table Struct tmpPickParam
(
 ParamName      : tName,
 ParamCode      : Word,
 ParamTypeEdIzm : Word,
 ParamSort      : Word
)
With Index
(
 tmpPickParam01 = ParamCode,
 tmpPickParam02 = ParamSort
);
/*
table struct VrVid
(
  Name         : string[80],
  NumAll       : longint, // уникальный номер
  NumVid       : word,
  cVrVid       : comp
)
with Index
(
 VrVid01 = cVrVid + NumAll,
 VrVid02 = NumVid
 );
*/
table struct TabVidNum
(
  CnstRole1   : word,
  CnstRole2   : word,
  CnstRole3   : word,
  CnstRole4   : word,
  KatRoleNRec1: comp,
  KatRoleNRec2: comp,
  KatRoleNRec3: comp,
  KatRoleNRec4: comp,
  wSysNum     : word,
  KolAn       : word
)

with Index
(
 TabVidNum01 = CnstRole1 + CnstRole2 + CnstRole3 + CnstRole4,
 TabVidNum02 = KatRoleNRec1 + KatRoleNRec2 + KatRoleNRec3 + KatRoleNRec4 + wSysNum,
 TabVidNum03 = KatRoleNRec1,
 TabVidNum04 = KatRoleNRec2,
 TabVidNum05 = KatRoleNRec3,
 TabVidNum06 = KatRoleNRec4,
 TabVidNum07 = wSysNum
);
table struct SysMnfRole
(
  Num         : word,
  CnstRole    : word,
  KatRoleNRec : comp
)

with Index
(
 SysMnfRole01 = KatRoleNRec + Num,
 SysMnfRole02 = CnstRole
);

Table Struct AlgInDocList_Declare
(
 TypeDoc     : Word,     // Тип документа из MnPlan.inc
 cDoc        : Comp,     // Ссылка на документ таблица MnPlan
 Number      : LongInt,  // Уникальный номер документа в списке
 NumPr       : word,     // Номер представления (Резерв) для документов план
 cSp         : comp,     // ссылка на позицию спецификации
 wTypeNorm   : Word,     // Тип нормы
 cNorm       : Comp,     // Ссылка на нормы
 dataP       : date,
 cOtpEd      : comp,
 Kol         : double,
 Price       : double,
 cVal        : comp,     // ссылка на валюту
 flag        : word,     // Флаг (пока не используется)
 wObject     : word,     // тип объекта, для которого используем нормы
 cObject     : comp      // объект, для которого используем нормы
)
With Index
(
 AlgInDocList_01 = Number (Unique,AutoInc),
 AlgInDocList_02 = TypeDoc + cDoc + Number
);

//=======================================================================
// Временные таблицы, формируются 93-им алгоритмом,
// используются системным интерфейсом N10015
//-----------------------------------------------------------------------

Table Struct OwnertmpAgr
(
  NRec       : tNrec ,
  cMnPlanNRec : comp,
  FormPlNRecInterf : comp
)
With Index
(
 OwnertmpAgr01  = Nrec(Unique, Surrogate, Journal),
 OwnertmpAgr05  = cMnPlanNRec + FormPlNRecInterf
);

Table Struct tmpAgrSpMnPlan
(
  NRec       : tNrec ,
  OwnertmpAgrNRec : tNrec,
//  LastUser   : string,
  NumSort    : LongInt, // поле для сортировки
  FlagItogo  : word,    // признак строки итого = 1 - эта строка "Итого"
  AnItogo    : comp,
  An_1       : Comp,
  An_2       : Comp,
  An_3       : Comp,
  An_4       : Comp,
  An_5       : Comp,
  An_6       : Comp,
  An_7       : Comp,
  An_8       : Comp,
  An_9       : Comp,
  An_10      : Comp,
  NameStr    : string,
  Level      : word,
  cMnPlanNRec : comp,
  FormPlNRecInterf : comp
)
With Index
(
 tmpAgrSpMnPlan01  = Nrec(Unique, Surrogate, Journal),
 tmpAgrSpMnPlan02  = NumSort,
 tmpAgrSpMnPlan03  = Level,
// tmpAgrSpMnPlan04  = An_1 + An_2 + An_3 + An_4 + An_5 + An_6 + An_7 + An_8 +
//                     An_9 + An_10 + cMnPlanNRec + FormPlNRecInterf,
 tmpAgrSpMnPlan04  = An_1 + An_2 + An_3 + An_4 + An_5 + An_6 + An_7 + An_8 +
                     An_9 + An_10 + OwnertmpAgrNRec,
 tmpAgrSpMnPlan05  = OwnertmpAgrNRec + NumSort
// tmpAgrSpMnPlan05  = cMnPlanNRec + FormPlNRecInterf + NumSort
);

Table Struct tmpAgrSpMnPl
(
  NRec               : tNrec  ,
  OwnertmpAgrNRec    : tNrec,
  tmpAgrSpMnPlanNRec : Comp   ,
  NumSort            : LongInt,  // поле для сортировки
  AnColumn           : Comp   ,
  FlagItogo          : word   ,  // признак колонки итого = 1 - эта колонка "Итого"
  FlagItogoSpMnPlan  : word   ,  // копия признака "Итого" из tmpAgrSpMnPlan
  Level              : word   ,  // копия Level из tmpAgrSpMnPlan
  Kol                : Double ,  // количество
  NameStr            : string
)
With Index
(
 tmpAgrSpMnPl01  = Nrec(Unique, Surrogate, Journal),
 tmpAgrSpMnPl02  = OwnertmpAgrNRec,
 tmpAgrSpMnPl03  = tmpAgrSpMnPlanNRec + AnColumn + OwnertmpAgrNRec,
 tmpAgrSpMnPl04  = tmpAgrSpMnPlanNRec + NumSort,
 tmpAgrSpMnPl05  = tmpAgrSpMnPlanNRec + FlagItogo,
 tmpAgrSpMnPl06  = OwnertmpAgrNRec + tmpAgrSpMnPlanNRec + NumSort,
 tmpAgrSpMnPl07  = OwnertmpAgrNRec + NumSort,
 tmpAgrSpMnPl08  = NumSort
);



#include tmptableuks.tbl

#end