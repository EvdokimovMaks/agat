/*
 ╔═══════════════════════════════════════════════════════════════════════════╗
 ║                     (c) 1994,97 корпорация ГАЛАКТИКА                      ║
 ║                                                                           ║
 ║ Проект        : ГАЛАКТИКА                                                 ║
 ║ Система       : Кадры                                                     ║
 ║ Версия        : 7.1                                                       ║
 ║ Назначение    : Объектный интерфейс с процедурами для фильтра по          ║
 ║                 сотрудникам/подразделениям                                ║
 ║ Ответственный : Магниченко Александр Викторович                           ║
 ╚═══════════════════════════════════════════════════════════════════════════╝
*/

#ifndef _ComFiltr_INCLUDED_
#define _ComFiltr_INCLUDED_

#ifdef ComponentVersion
#component "z_Staff"
#end

#doc
Объектный интерфейс с процедурами для фильтра по сотрудникам/подразделениям
#end
objinterface ICommonFiltr;

#doc
Запускаем cmInit Интерфейса
#end
procedure ObjInit;

#doc
 Запуск интерфейса выбора подразделений с набивкой соответствующего маркера DeptMarker
#end
procedure SelectPodr;

#doc
Запуск интерфейса выбора сотрудников с набивкой соответствующего маркера PsnMarker
#end
procedure SelectPsn;

#doc
	Процедура выравнивания маркеров согласно установленным фильтрам. Актуальна перед
	запуском отчетов или загрузки\переформирования какого-то интерфейса. Собственно,
	как правило, она и так запускается :). Но можно ручками из интерфейса-владельца
	экземпляра объекта
#end
procedure EndSelect;

#doc
	Набивка временной таблицы сотрудников на основании таблицы персонс и выбранных
  ограничений: 'работающие', 'текущие', 'архив', 'вся картотека'
#end
procedure InitTmpTable;

#doc
	Процедура закрытия отката\закрытия. Сохранение части маркеров и т.п. Не актуальна,
	скорее всего, для внешнего использования.
#end
procedure IntClose(Flag : boolean);

#doc
	Процедура наполнения маркеров по подразделениям и сотрудникам в том случае, если
	в реальности их не настраивали, а надо собственно подтянуть всех, кто есть.
#end
procedure SelectAllPsn;

#doc
	Очистка фильтра по подразделениям
#end
procedure ClearDepartmentsFilter;

#doc
	Очистка маркера по персонам
#end
procedure ClearPersonsFilter;

#doc
	Получить ссылку на маркер по подразделениям
#end
function GetDepartmentsMarker: longint;

#doc
	Получить ссылку на маркер по сотрудникам
#end
function GetPersonsMarker: longint;

#doc
	Получить выбранное подразделение. Работает корректно только для случаев одиночного
	выбора подразделений, в противном возвращает просто первый элемент маркера
#end
function GetMarkedDepartment: comp;

#doc
  Получить выбранного сотрудника. Работает корректно только для случаев одиночного
	выбора сотрудников, в противном возвращает просто первый элемент маркера
#end
function GetMarkedPerson: comp;

#doc
	Получить строковое значение установленного фильтра по подразделениям, например:
	'не установлен'
#end
function GetDepartmentsFilterStr: string;

#doc
  Получить строковое значение установленного фильтра по сотрудникам, например:
	'не установлен'
#end
function GetPersonsFilterStr: string;

#doc
	Получить значение установленного ограничения на Персонс:
	0 - 'работающие',
	1 - 'текущие',
	2 - 'архив'
  3 - 'вся картотека'
#end
function GetPersonsState: word;

#doc
	Переформировать временную таблицу для заданного другого ограничения на Персонс
	0 - 'работающие',
	1 - 'текущие',
	2 - 'архив'
  3 - 'вся картотека'
#end
procedure SetPersonsState(NewState: word);

#doc
	Открыты ли дополнительные фильтры (характер работы, перевод в филиал).
	1 - если установлен хоть какой-нибудь фильтр
#end
function GetAFltState: word;

#doc
	Открыть/закрыть дополнительные фильтра
#end
procedure SetAFltState(NewState: word);

#doc
	То же самое, что GetAFltState. Просто на будущее
#end
function GetPFltState: word;

#doc
  То же самое, что SetAFltState. Просто на будущее
#end
procedure SetPFltState(NewState: word);

#doc
	Получить кол-во записей в маркере по подразделениям
#end
function GetDeptCount: LongInt;

#doc
	Получить кол-во записей в маркере по сотрудникам
#end
function GetPsnCount: LongInt;

#doc
	Сохранить настройки фильтрации
#end
procedure StoreAllParams;

end;

#doc
Объектный интерфейс с процедурами для фильтра по сотрудникам/подразделениям
#end
objinterface ICommonFiltr2;

#doc
Процедура добавления значения в маркер по заданным параметрам и перечитка маркера
#end
procedure SetAndRefresh(cValue: comp; wKindMarker: word);

end;

vipinterface CommonFiltr implements ICommonFiltr, ICommonFiltr2
#ifdef ATL51
Licensed (free)
#end
;

#end
