//------------------------------------------------------------------------------
//                                                      (c) корпорация Галактика
// Галактика 8.1 - Заработная плата
// Объект для работы с допаналитиками
//------------------------------------------------------------------------------

#ifndef _EXTRANALYTICSHELPER_VIH_INCLUDED_
#define _EXTRANALYTICSHELPER_VIH_INCLUDED_

#ifdef ComponentVersion
#component "Z_SERVICE"
#end

#doc
<brief>Объект для работы с дополнительными аналитиками</brief>

<p>
Дополнительные аналитики в модуле ЗП хранятся в таблице OtpDop,
которая подсоединяется к основным сущностям зарплаты, как правило,
по полю oldclsch (например, SUMVIDOP.OLDCLSCH == OTPDOP.NREC).
Но при этом не делается различий, в каких случаях мы имеем
агрегацию, а в каких - ассоциацию. То есть может быть такая
ситуация, когда лицевой счет и суммы по видам оплат ссылаются
на одну и ту же запись OtpDop, и при редактировании доп. аналитики
в суммах по видам оплат она может измениться и в лицевом счете.
</p>

<p>
Для того, чтобы разрешить противоречие, был разработан следующий
механизм. Если родительская сущность ссылается на запись OtpDop,
которая существует в единственном экземпляре, и подсоединена
только к данной родительской сущности, то в поле OtpDop.VidOpl
нужно записать код родительской таблицы. Таким образом мы
определяем, нужно ли создавать копию доп. аналитики перед её
редактированием, нужно ли удалять запись доп. аналитики при
удалении родительской сущности.
</p>

<p>
Данный интерфейс разработан для приведения исходников к единообразию,
а также для облегчения поддержки решения (с записью кода таблицы
в OtpDop.VidOpl).
</p>

<p>
Использование объекта <link interface Z_SERVICE::ExtrAnalyticsHelper>ExtrAnalyticsHelper</link>
сводится к следующему. Пусть для примера мы будем обрабатывать редактирование
доп. аналитики к таблице SUMVIDOP.
</p>

<code>
  interface xxxx
<br>  ...
<br>  var EAH: ExtrAnalyticsHelper;
<br>  ...
<br>  // в логической таблице подцепка:
<br>  SUMVIDOP.OLDCLSCH == OTPDOP.NREC
<br>  ...
<br>
<br>  // обработка события cmPick для вычисляемого поля доп. аналитики:
<br>  {
<br>&nbsp&nbsp EAH.BindExtrAnalytics(coSUMVIDOP, SUMVIDOP.OLDCLSCH);
<br>&nbsp&nbsp RunInterface('PickExtrKaU', 0, SUMVIDOP.OLDCLSCH);
<br>&nbsp&nbsp set SUMVIDOP.OLDCLSCH := SUMVIDOP.OLDCLSCH;
<br>  }
<br>  // более продвинутый вариант обработки события cmPick для вычисляемого поля доп. аналитики:
<br>  {
<br>&nbsp&nbsp if (EAH.BindExtrAnalytics(coSUMVIDOP, SUMVIDOP.OLDCLSCH))
<br>&nbsp&nbsp&nbsp&nbsp set SUMVIDOP.OLDCLSCH := SUMVIDOP.OLDCLSCH;
<br>&nbsp&nbsp RunInterface('PickExtrKaU', 0, SUMVIDOP.OLDCLSCH);
<br>&nbsp&nbsp RereadRecord(#OTPDOP);
<br>  }
<br>  ...
<br>  // обработка события cmDelOnProtect для вычисляемого поля доп. аналитики:
<br>  {
<br>&nbsp&nbsp EAH.UnBindExtrAnalytics(coSUMVIDOP, SUMVIDOP.OLDCLSCH);
<br>
<br>&nbsp&nbsp // теперь можно прописать в SUMVIDOP.OLDCLSCH ноль или ссылку
<br>&nbsp&nbsp // на доп. аналитику "по умолчанию"
<br>  }
<br>  ...
<br>  // обработка события cmDeleteRecord для SUMVIDOP:
<br>  {
<br>&nbsp&nbsp EAH.UnBindExtrAnalytics(coSUMVIDOP, SUMVIDOP.OLDCLSCH);
<br>
<br>&nbsp&nbsp // теперь можно удалять родительскую сущность
<br>&nbsp&nbsp delete current SUMVIDOP;
<br>  }
</code>

<p>
Объект с помощью переданного кода таблицы будет контролировать,
нужно ли создавать копию доп. аналитики перед редактированием,
нужно ли удалять запись доп. аналитики при потере ссылки на неё.
</p>
#end
objInterface IExtrAnalyticsHelper;
  #doc
  <brief>Подключить собственную запись доп. аналитики для родительской сущности</brief>

  <p>
  Функция с помощью кода родительской таблицы проверяет, находится ли
  по переданной ссылке "собственная" запись доп. аналитики (OtpDop.VidOpl = parentTableCode).
  Если по переданной ссылке находится "собственная" запись, то ничего не происходит,
  и функция возвращает false. Если запись по переданной ссылке не собственная,
  или же не находится, то создается копия исходной записи доп. аналитики
  (или вовсе новая запись), которая уже будет собственной для родительской сущности.
  Функция в таком случае возвращает true. NRec созданной новой записи записывается
  в параметр otpdopNRec.
  </p>

  <p>
  К сожалению, объект не сможет взвести признак модификации для otpdopNRec при изменении
  значения данного параметра. Поэтому необходимо позаботиться об этом извне.
  </p>

  <p>
  Параметры:
  <ul>
    <li>[in] parentTableCode - код родительской таблицы</li>
    <li>[in-out] otpdopNRec - ссылка на доп. аналитику к родительской сущности</li>
  </ul>
  </p>

  <p>
  Возвращаемое значение: <br>
  Была ли изменена ссылка otpdopNRec (была ли создана новая запись OtpDop).
  </p>
  #end
  function BindExtrAnalytics(parentTableCode: word; var otpdopNRec: comp): boolean;

  #doc
  <brief>Подключить собственную запись доп. аналитики для родительской сущности</brief>

  <p>
  Функция с помощью кода родительской таблицы проверяет, находится ли
  по переданной ссылке "собственная" запись доп. аналитики (OtpDop.VidOpl = parentTableCode).
  Если по переданной ссылке находится "собственная" запись, то ничего не происходит,
  и функция возвращает false. Если запись по переданной ссылке не собственная,
  или же не находится, то создается копия исходной записи доп. аналитики
  (или вовсе новая запись), которая уже будет собственной для родительской сущности.
  Функция в таком случае возвращает true. NRec созданной новой записи записывается
  в параметр otpdopNRec.
  </p>

  <p>
  В случае создания новой записи доп. аналитики, в поле OtpDop.DataN записывается
  дата, составленная следующим образом: Date(1, datanMes, datanYear);
  а в поле OtpDop.cLsch записывается lschetNRec.
  </p>

  <p>
  К сожалению, объект не сможет взвести признак модификации для otpdopNRec при изменении
  значения данного параметра. Поэтому необходимо позаботиться об этом извне.
  </p>

  <p>
  Параметры:
  <ul>
    <li>[in] parentTableCode - код родительской таблицы</li>
    <li>[in-out] otpdopNRec - ссылка на доп. аналитику из родительской сущности</li>
    <li>[in] lschetNRec - ссылка на лицевой счет</li>
    <li>[in] datanMes - месяц</li>
    <li>[in] datanYear - год</li>
  </ul>
  </p>

  <p>
  Возвращаемое значение: <br>
  Была ли изменена ссылка otpdopNRec (была ли создана новая запись OtpDop).
  </p>
  #end
  function BindExtrAnalyticsAdvanced(parentTableCode: word; var otpdopNRec: comp;
                                     lschetNRec: comp; datanMes: byte; datanYear: word): boolean;

  #doc
  <brief>Обрабатывает потерю ссылки на запись доп. аналитики</brief>

  <p>
  Функция с помощью кода родительской таблицы проверяет, находится ли
  по переданной ссылке "собственная" запись доп. аналитики (OtpDop.VidOpl = parentTableCode).
  Если по переданной ссылке находится "собственная" запись, то происходит её удаление
  из БД, и функция возвращает true. <br>
  В остальных случаях ничего не происходит, и возвращается false.
  </p>

  <p>
  Параметры:
  <ul>
    <li>[in] parentTableCode - код родительской таблицы</li>
    <li>[in] otpdopNRec - ссылка на доп. аналитику из родительской сущности</li>
  </ul>
  </p>

  <p>
  Возвращаемое значение: <br>
  Было ли произведено удаление записи OtpDop из БД.
  </p>
  #end
  function UnBindExtrAnalytics(parentTableCode: word; otpdopNRec: comp): boolean;
end;

#doc
  Каноничная реализация интерфейса <link objInterface Z_SERVICE::IExtrAnalyticsHelper>IExtrAnalyticsHelper</link>.
#end
vipInterface ExtrAnalyticsHelper implements IExtrAnalyticsHelper licensed(free);

#endif
