
  Использование транзакций позволяет обеспечить целостность данных в БД при
модификациях. Использовать в качестве механизма ОТКАТА пакетных модификаций
НЕ РЕКОМЕНДУЕТСЯ, поскольку это может значительно снизить конкуррентность.

  Данная библиотека поддерживает вложенные транзакции. Она оформлена в виде
интерфейса, а не VPP-шки, что позволяет отслеживать вложенность вызовов
public-функций с транзакциями между интерфейсами.

  При запуске транзакции можно включить визуализацию. При наличии вложенных
вызовов визуализация включается или запрещается самым верхним вызовом StartTrans.
В ряде случаев это может быть удобно. При этом можно подменить стандартное
сообщение библиотеки собственным при помощи SetVisualHeader, либо изменить тип
визуализации при помощи следующего кода:

  ...
  iTrans.StartTrans( True);
  if ( iTrans.GetVisual) // Могла не включиться, если уровень не верхний
  {
    StopVisual( '', 0);  // Отключить стандартную визуализацию транзакции
    StartNewVisual( vtIndicatorVisual, vfTimer+ vfBreak+ vfConfirm,
      'Идет уникальный процесс ...', 100);
  }
  ...

  Вызовы NextVisual производятся в пользовательском алгоритме.

  Транзакции должны быть по возможности короче, поэтому запрашивать ввод
пользователя внутри транзакции не рекомендуется. Тем более что при вызове
из _try-блока интерфейса с визуальной частью не происходит возврата в
обработчик исключений данного блока при возникновении исключения в обработчике
события вызываемого интерфеса.

  Вынос исключения на верхний уровень вложенности _try-блоков процедурой
RollBack убрал, поскольку нет возможности определить уровень вложенности
текущего _try-блока без навязывания следующих ограничений:
  Нельзя сделать один _try-блок и внутри него несколько раз вложенно стартовать
транзакцию. Каждый вложенный вызов StartTransaction должен быть внутри своего
вложенного _try-блока где в обработчике исключения есть RollBack.
  Кроме того, сложно придумать ОБЩУЮ СХЕМУ ВЛОЖЕННОЙ обработки ИСКЛЮЧЕНИЙ.
В случае использования вложенных _try-блоков программист сам должен обдумать
схему обработки исключений на уровнях вложенности. Ниже предлагается
несколько типовых вариантов организации исходных текстов.

  Исключения циркулируют только внутри VIP-а, поэтому в случае большого количества
Паскаля полезность использования данного подхода сомнительна.


Примерная типовая схема организации исходных текстов:

//=============================================================================
// Библиотека процедур c или без использования транзакций и почти без
// проверки ошибок. Желательно использовать TryGet для GetFirst и GetNext внутри
// логических выражений (подробности в TransGet.vpp). TransGet.vpp можно включать
// сам по себе без использования всего интерфейса библиотеки транзакций.


#include TransLib.vih

...

#include TransLib.var

...

// Если включить, можно использовать TryGet() без префикса iTrans.
#include TransGet.vpp

...

//-----------------------------------------------------------------------------
// Откат того, что не откатывается iTrans.RollBack();

procedure RollBack;
{
  // Если есть вероятность того, что внутри блока используются транзакции - надо
  // вызывать эту процедуру. Если транзакций не окажется - ничего страшного.
  iTrans.RollBack('');

  // Собственный механизм отката некорректно созданных документов
  // ...
}

//-----------------------------------------------------------------------------

// Без транзакций и проверки ошибок модификации - вызывать изнутри _try-блока
procedure CreateRec;
{
  ClearBuffer( #SomeTable);
  Insert Current SomeTable;
}

// Используется Start..Commit - использовать вызывать изнутри _try-блока,
// в обработчике исключения которого есть вызов iTrans.RollBack();
procedure UpdateRec;
{
  iTrans.StartTrans( False);

  iTrans.TryGet( GetFirst SomeTable);
  Update Current SomeTable;

  iTrans.Commit;

  // Эта модификация не требует объединения в транзакции с другими модификациями
  Update Current SomeTable;
}

procedure DoLittleWork; // Есть транзакция и свой Try-блок.
{
  _try
  {
    iTrans.StartTrans( False);
    ...
    _LOOP SomeTable
      CreateRec;
    ...
    iTrans.Commit;
  }

  _except
    on ExUserBreak:
      RollBack( CutExName( ExploreException));

    on ExVip, ExMath, ExDatabase:
    {
      RollBack( ExploreException);

      _ReRaise; // Если так, то требуется охватывающий _try-блок.

      // Иначе нужно возвращать Boolean
      // Если в каждом _try стартуется транзакция, можно анализировать iTrans.GetLevel
    }
}

...

//-----------------------------------------------------------------------------
// Высокоуровневая процедура. Выполняют большую прикладную задачу (возможно пакетную).
// Вызываются из обработчика событий интерфейса, содержит _try-блок.

procedure DoSomethingLarge;
{
  _try // Модификации в транзакции и без
  {
    iTrans.StartTrans( True);

    if ( iTrans.GetVisual) // Может быть False, если _try-блок вложенный
      SetVisualHeader('Работает тоскливый алгоритм ...'#13);

    DoLittleWork;

    iTrans.Commit; // Ниже вне транзакции

    if iTrans.TryGet( GetFirst SomeTable) // Исключение генерируется TryGet только в случае
    do                                    // ошибки, отличной от отсутствия записи
      {
        if iTrans.TryGet( GetFirst SomeTable Where(( ??? )))
          UpdateRec;
        else
          CreateRec;
        ...

        ...         // Куча МОДИФИКАЦИЙ без проверки успешности выполнения
        ...         // Операторы позиционирования внутри TryGet()

        NextVisual; // При прерывании генерируется исключение
      }
    while iTrans.TryGet( GetNext SomeTable)

    Message(''#3'Все хорошо, что хорошо кончается.', Information);
  }

  _except
    on ExUserBreak:
    {
      RollBack('');
      Message(''#3'Выполнение алгоритма прервано'#13#3+
        'нетерпеливым пользователем.', Warning);
    }
    else
      RollBack( ExploreException);

  _finally

    // Только для отладки - убедиться что все транзакции закрыты
    iTrans.TransCompleted;
}

//=============================================================================
// Интерфейс с обработчиками событий-команд пользователя.

...

cmValue1: DoSomethingLarge;

...

//=============================================================================

Ограничения:

  Не стоит смешивать функции из данной библитеки с функциями из транзакционной
библиотеки Володько А.В..
