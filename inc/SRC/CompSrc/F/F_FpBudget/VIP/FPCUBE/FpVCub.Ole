//------------------------------------------------------------------------------
//                                                      (c) корпорация Галактика
// Галактика 9.10 - модуль "Управление бюджетом"
// Визуальный интерфейс : "Куб данных"
//------------------------------------------------------------------------------

//==============================================================================
Const
  VK_CTRL_I = 73;
  VK_CTRL_P = 80;
  VK_CTRL_B = 66;
  VK_CTRL_U = 85;
  VK_ALT_P  = 150;
  VK_ALT_R  = 82;
  VK_ALT_G  = 71;
  VK_ALT_N  = 78;
  VK_ALT_S  = 83;
  VK_ALT_A  = 65;
  VK_ALT_1  = 49;
  VK_ALT_2  = 50;
  VK_ALT_3  = 51;
  VK_ALT_4  = 52;
  VK_ALT_5  = 53;

  VK_PLUS   = 107;
  VK_MINUS  = 109;

  VK_SHIFT_F3 = 114;

  VK_ESCAPE = 27;
  VK_F1     = 112;
end; // case
//******************************************************************************


//==============================================================================
// COMMON
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
// Установить размер шрифта
procedure ViewCube_SetFontSize(
  _Size : LongInt             // размер шрифта
);
{
  OleCall1(pOle, ocProc, 'SetCubeFontSize', _Size);
}
//------------------------------------------------------------------------------
// Установить режим редактирования
procedure ViewCube_SetIsEditingMode(
  _Value : boolean            // признак рерактирования
);
{
  OleCall1(pOle, ocProc, 'SetCubeIsEditingMode', _Value);
}

//------------------------------------------------------------------------------
// Перерисовать данные
procedure ViewCube_ReDraw;
{
  OleCall0(pOle, ocProc, 'CubeReDraw');
}
//------------------------------------------------------------------------------
// Перечитать данные
procedure ViewCube_ReRead;
{
  MyClearCellCash;
  OleCall0(pOle, ocProc, 'CubeReRead');
}
// COMMON
//******************************************************************************


//==============================================================================
// AXIS
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
// Очистить ось
procedure ViewCube_AxisClear(
  _XY : word                  // ID оси
);
{
       if (_XY = AxisXID)   OleCall0(pOle, ocProc, 'AxisXClear');
  else if (_XY = AxisYID)   OleCall0(pOle, ocProc, 'AxisYClear');
}
//------------------------------------------------------------------------------
// Добавить в ось новый элемент
function  ViewCube_AxisAddItem(
  _XY             : word;     // ID оси
  _AxisNodeItemID : TPtr;  // ID вышестоящего элемента
  _Name           : string;   // наименование элемента
  _AttrAxFld      : word      // атрибуты элемента
) : TPtr;                  // ID нового элемента
{
  Result := 0;
       if (_XY = AxisXID)   OleCall4(pOle, ocFunc, 'AxisXAddItem', _AxisNodeItemID, _Name, _AttrAxFld, Result);
  else if (_XY = AxisYID)   OleCall4(pOle, ocFunc, 'AxisYAddItem', _AxisNodeItemID, _Name, _AttrAxFld, Result);
}

//------------------------------------------------------------------------------
// Пересчет индексов элементов оси
procedure ViewCube_AxisReCalcAllIndex(
  _XY : word                  // ID оси
);
{
       if (_XY = AxisXID)   OleCall0(pOle, ocProc, 'AxisXReCalcAllIndex' );
  else if (_XY = AxisYID)   OleCall0(pOle, ocProc, 'AxisYReCalcAllIndex' );
}
//------------------------------------------------------------------------------
// Раскрыт ли заданный элемент оси
function  ViewCube_AxisItemIsExpand(
  _ItemID : TPtr           // ID элемента
) : boolean;
{
  Result := False;
  OleCall2(pOle, ocFunc, 'AxisItemIsExpand', _ItemID, Result);
}

//------------------------------------------------------------------------------
// Получить для текущей ячейки номер колонки
function ViewCube_AxisXGetCurCol : LongInt;
{
  Result := -1;
  OleCall1(pOle, ocFunc, 'CubeGetCurCellCol', Result);
  if (Result = -1)
  {
    sLastError := 'Ошибка определения колонки текущей ячейки...';
    FpLog('ViewCube_AxisXGetCurCol: '+sLastError);
    Exit;
  }
}
//------------------------------------------------------------------------------
// Получить для текущей ячейки номер строки
function ViewCube_AxisYGetCurRow : LongInt;
{
  Result := -1;
  OleCall1(pOle, ocFunc, 'CubeGetCurCellRow', Result);
  if (Result = -1)
  {
    sLastError := 'Ошибка определения строки текущей ячейки...';
    FpLog('ViewCube_AxisYGetCurRow: '+sLastError);
    Exit;
  }
}

//------------------------------------------------------------------------------
// Получить для оси X координату элемента по номеру колонки
function ViewCube_AxisXGetRealItemIndex(
  _Col : LongInt              // номер колонки
) : LongInt;                  // координата элемента
{
  Result := -1;
  OleCall2(pOle, ocFunc, 'AxisXGetRealItemIndex'   , _Col, Result);
}
//------------------------------------------------------------------------------
// Получить для оси Y координату элемента по номеру строки
function ViewCube_AxisYGetRealItemIndex   (
  _Row : LongInt              // номер строки
) : LongInt;                  // координата элемента
{
  Result := -1;
  OleCall2(pOle, ocFunc, 'AxisYGetRealItemIndex'   , _Row, Result);
}

//------------------------------------------------------------------------------
// Раскрыть текущий узел оси X
procedure ViewCube_AxisXExpandCurNode(
  _isRecurse : boolean        // выполнять рекурсивно
);
{
  var Col : LongInt;  Col := ViewCube_AxisXGetCurCol();
  if (Col = -1)
  { Exit; }
  var Ind : LongInt;  Ind := ViewCube_AxisXGetRealItemIndex(Col);
  StartNewVisual(vtRotateVisual, vfTimer+vfScreenBottom, 'Раскрытие узла иерархии...', 1);
  OleCall2(pOle, ocProc, 'AxisXExpandIndItem', Ind, _isRecurse );
  StopVisual('', 0);
}
//------------------------------------------------------------------------------
// Раскрыть текущий узел оси Y
procedure ViewCube_AxisYExpandCurNode(
  _isRecurse : boolean        // выполнять рекурсивно
);
{
  var Row : LongInt;  Row := ViewCube_AxisYGetCurRow();
  if (Row = -1)
  { Exit; }
  var Ind : LongInt;  Ind := ViewCube_AxisYGetRealItemIndex(Row);
  StartNewVisual(vtRotateVisual, vfTimer+vfScreenBottom, 'Раскрытие узла иерархии...', 1);
  OleCall2(pOle, ocProc, 'AxisYExpandIndItem', Ind, _isRecurse );
  StopVisual('', 0);
}
//------------------------------------------------------------------------------
// Закрыть текущий узел оси X
procedure ViewCube_AxisXCollapseCurNode(
  _isRecurse : boolean        // выполнять рекурсивно
);
{
  var Col : LongInt;  Col := ViewCube_AxisXGetCurCol();
  if (Col = -1)
  { Exit; }
  var Ind : LongInt;  Ind := ViewCube_AxisXGetRealItemIndex(Col);
  StartNewVisual(vtRotateVisual, vfTimer+vfScreenBottom, 'Закрытие узла иерархии...', 1);
  OleCall2(pOle, ocProc, 'AxisXCollapseIndItem', Ind, _isRecurse );
  StopVisual('', 0);
}
//------------------------------------------------------------------------------
// Закрыть текущий узел оси Y
procedure ViewCube_AxisYCollapseCurNode(
  _isRecurse : boolean        // выполнять рекурсивно
);
{
  var Row : LongInt;  Row := ViewCube_AxisYGetCurRow();
  if (Row = -1)
  { Exit; }
  var Ind : LongInt;  Ind := ViewCube_AxisYGetRealItemIndex(Row);
  StartNewVisual(vtRotateVisual, vfTimer+vfScreenBottom, 'Закрытие узла иерархии...', 1);
  OleCall2(pOle, ocProc, 'AxisYCollapseIndItem', Ind, _isRecurse );
  StopVisual('', 0);
}

//------------------------------------------------------------------------------
// Раскрыть все элементы оси X
procedure ViewCube_AxisXExpandAll;
{
  StartNewVisual(vtRotateVisual, vfTimer+vfScreenBottom, 'Раскрытие горизонтальной оси...', 1);
  OleCall0(pOle, ocProc, 'AxisXExpandAll' );
  StopVisual('', 0);
}
//------------------------------------------------------------------------------
// Раскрыть все элементы оси Y
procedure ViewCube_AxisYExpandAll;
{
  StartNewVisual(vtRotateVisual, vfTimer+vfScreenBottom, 'Раскрытие вертикальной оси...', 1);
  OleCall0(pOle, ocProc, 'AxisYExpandAll' );
  StopVisual('', 0);
}
//------------------------------------------------------------------------------
// Закрыть все элементы оси X
procedure ViewCube_AxisXCollapseAll;
{
  StartNewVisual(vtRotateVisual, vfTimer+vfScreenBottom, 'Закрытие горизонтальной оси...', 1);
  OleCall0(pOle, ocProc, 'AxisXCollapseAll' );
  StopVisual('', 0);
}
//------------------------------------------------------------------------------
// Закрыть все элементы оси Y
procedure ViewCube_AxisYCollapseAll;
{
  StartNewVisual(vtRotateVisual, vfTimer+vfScreenBottom, 'Закрытие вертикальной оси...', 1);
  OleCall0(pOle, ocProc, 'AxisYCollapseAll' );
  StopVisual('', 0);
}
// AXIS
//******************************************************************************


//==============================================================================
// MEASURE
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
// Очистить список показателей
procedure ViewCube_MeasureClear;
{
  OleCall0(pOle, ocProc, 'MeasureClear');
}
//------------------------------------------------------------------------------
// Добавить новый элемент в список показателей
procedure ViewCube_MeasureAddItem(
  _Name : string              // наименование элемента
);
{
  OleCall1(pOle, ocProc, 'MeasureAddItem', _Name);
}

//------------------------------------------------------------------------------
// Получить для оси M индекс элемента по номеру колонки
function ViewCube_MeasureGetItemIndexByCol(
  _Col : LongInt              // номер колонки
) : LongInt;
{
  Result := -1;
  OleCall2(pOle, ocFunc, 'MeasureGetItemIndexByCol', _Col, Result);
}
// MEASURE
//******************************************************************************


//==============================================================================
// CELLS
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
// Очистить все ячейки
procedure ViewCube_CellsClear;
{
  OleCall0(pOle, ocProc, 'CellsClear');
}
//------------------------------------------------------------------------------
// Установить значение в ячейку (строковое)
procedure ViewCube_SetCellValue(
  _X     : LongInt;           // координата по оси X (горизонтальная)
  _Y     : LongInt;           // координата по оси Y (вертикальная  )
  _M     : LongInt;           // координата по оси M (показатели - Measure)
  _Value : string;            // значение ячейки
  _Attr  : word               // атрибут ячейки
);
{
  OleCall5(pOle, ocProc, 'SetCellValue', _X, _Y, _M, _Value, LongInt(_Attr) );
}
//------------------------------------------------------------------------------
// Установить значение в ячейку (числовое)
procedure ViewCube_SetCellDoValue(
  _X     : LongInt;           // координата по оси X (горизонтальная)
  _Y     : LongInt;           // координата по оси Y (вертикальная  )
  _M     : LongInt;           // координата по оси M (показатели - Measure)
  _Value : double;            // значение ячейки
  _Attr  : word               // атрибут ячейки
);
{
  var sValue : string;  sValue := '';
  if (abs(_Value) > cgFp_MinSumma )
  {
    sValue  := DoubleToStr(_Value, arrColFormats[_M+1]);
  }
  ViewCube_SetCellValue(_X, _Y, _M, sValue, _Attr);
}
//------------------------------------------------------------------------------
// Установить значение в ячейку из процессора куба
procedure ViewCube_SetCellDoValueFromProcCube(
  _X     : LongInt;           // координата по оси X (горизонтальная)
  _Y     : LongInt;           // координата по оси Y (вертикальная  )
  _M     : LongInt            // координата по оси M (показатели - Measure)
);
{
  var IsCanEditCell : boolean;  IsCanEditCell := False;
  var RealM : LongInt;  RealM := MyGetRealMeasureIndex(_M+1);
  var Value : double;   Value := MyCubeGetXYValue(_X+1, _Y+1, RealM, IsCanEditCell);
  var wAttr : word;     wAttr := 0;
  if (MyCubeGetLastMeasureCrt(RealM) )
  {
    wAttr := SetBit(wAttr, lc_CellItemAttr_Crit_Bit, True);
  }
  if (IsCanEditCell)
  {
    wAttr := SetBit(wAttr, lc_CellItemAttr_Edit_Bit, True);
  }

  ViewCube_SetCellDoValue(_X, _Y, _M, Value, wAttr);
}

//------------------------------------------------------------------------------
// Установить значения во все видимые ячейки из процессора куба
procedure ViewCube_SetVisibleCellsDoValueFromProcCube;
{
  var Col1, Row1, Col2, Row2 : LongInt;
  OleCall1(pOle, ocFunc, 'CubeGetCellsCol1', Col1);
  OleCall1(pOle, ocFunc, 'CubeGetCellsCol2', Col2);
  OleCall1(pOle, ocFunc, 'CubeGetCellsRow1', Row1);
  OleCall1(pOle, ocFunc, 'CubeGetCellsRow2', Row2);

  var Col, Row : LongInt;
  for (Row:=Row1; Row<=Row2; Row++)
  {
    for (Col:=Col1; Col<=Col2; Col++)
    {
      var X, Y, M : LongInt;
      X := ViewCube_AxisXGetRealItemIndex   (Col);
      Y := ViewCube_AxisYGetRealItemIndex   (Row);
      M := ViewCube_MeasureGetItemIndexByCol(Col);

      ViewCube_SetCellDoValueFromProcCube(X, Y, M);
    } // for
  } // for
}

//------------------------------------------------------------------------------
// Получить для текущей ячейки ее координаты
function ViewCube_GetCurCellXYM(
var _X   : LongInt;           // координата по оси X (горизонтальная)
var _Y   : LongInt;           // координата по оси Y (вертикальная  )
var _M   : LongInt            // координата по оси M (показатели - Measure)
) : boolean;
{
  Result := False;
  _X := -1;
  _Y := -1;
  _M := -1;

  var Col : LongInt;  Col := ViewCube_AxisXGetCurCol();
  if (Col = -1)
  { Exit; }
  var Row : LongInt;  Row := ViewCube_AxisYGetCurRow();
  if (Row = -1)
  { Exit; }

  _X := ViewCube_AxisXGetRealItemIndex   (Col);
  _Y := ViewCube_AxisYGetRealItemIndex   (Row);
  _M := ViewCube_MeasureGetItemIndexByCol(Col);

  Result := True;
}
//------------------------------------------------------------------------------
// Получить для текущей ячейки ее координаты (в координатах процессора)
function ViewCube_GetCurCellLocalXYM(
var _X   : LongInt;           // координата по оси X (горизонтальная)
var _Y   : LongInt;           // координата по оси Y (вертикальная  )
var _M   : LongInt            // координата по оси M (показатели - Measure)
) : boolean;
{
  Result := ViewCube_GetCurCellXYM(_X, _Y, _M);
  if (not Result)
  { Exit; }
  _X := _X + 1;
  _Y := _Y + 1;
  _M := MyGetRealMeasureIndex(_M+1);
}
// CELLS
//******************************************************************************


//==============================================================================
// ONEVENTS
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
// Обработчик события: КУБУ нужно значение ячейки
procedure OnViewCube_NeedCellValue(
  _X     : LongInt;           // координата по оси X (горизонтальная)
  _Y     : LongInt;           // координата по оси Y (вертикальная  )
  _M     : LongInt            // координата по оси M (показатели - Measure)
);
{
  ViewCube_SetCellDoValueFromProcCube(_X, _Y, _M);
}

//------------------------------------------------------------------------------
// Обработчик события: КУБ хочет сохранить значение ячейки
procedure OnViewCube_SaveCellValue(
  _X     : LongInt;           // координата по оси X (горизонтальная)
  _Y     : LongInt;           // координата по оси Y (вертикальная  )
  _M     : LongInt;           // координата по оси M (показатели - Measure)
  _Value : string             // значение ячейки
);
{
  MyOnViewCubeRun_RaspCellValue(_X+1, _Y+1, MyGetRealMeasureIndex(_M+1), _Value);
}

//------------------------------------------------------------------------------
// Обработчик события: КУБ хочет удалить значение ячейки
procedure OnViewCube_KillCellValue(
  _X     : LongInt;           // координата по оси X (горизонтальная)
  _Y     : LongInt;           // координата по оси Y (вертикальная  )
  _M     : LongInt            // координата по оси M (показатели - Measure)
);
{
  MyOnViewCubeAsk_KillCellValue(_X+1, _Y+1, MyGetRealMeasureIndex(_M+1) );
}

//------------------------------------------------------------------------------
// Обработчик события: КУБУ нужно загрузить данные DrillDown-элемента оси Y
procedure OnViewCube_AxisYNeedDDLeafLoad(
  _ItemID     : LongInt;      // ID элемента
  _IntRecurse : LongInt       // режим рекурсивной загрузки (пока не используется)
);
{
  _IntRecurse := _IntRecurse;
  if (IsNowRun_AxisYNeedDDLeafLoad)
  { Exit; }
  IsNowRun_AxisYNeedDDLeafLoad := True;

  var isHaveData : boolean;
  var isAllOk    : boolean;
  isAllOk := MyLoadOnAxisExpand(AxisYID, _ItemID, isHaveData);

  IsNowRun_AxisYNeedDDLeafLoad := False;
}

//------------------------------------------------------------------------------
// Обработчик события: в КУБЕ нажата комбинация клавиш
procedure OnViewCube_PressCommandKey(
  _Key : LongInt              // ID комбинации клавиш
);
{
       if (_Key = VK_CTRL_P   )  { MyRunPrint(True )             ; }  // Печать отчета
  else if (_Key = VK_ALT_P    )  { MyRunPrint(False)             ; }  // Печать текущего состояния
  else if (_Key = VK_ESCAPE   )  { Event_CloseInterface          ; }  // Выход из инетрфейса

  else if (_Key = VK_CTRL_B   )  { Event_EditCopiesList          ; }  // Cписок копий бюджетов

  else if (_Key = VK_ALT_R    )  { Event_ReReadAllData           ; }  // Перегрузить данные заново
  else if (_Key = VK_ALT_G    )  { Event_LoadNextDDLevelAllStBud ; }  // Загрузить уровни по аналитике

  else if (_Key = VK_ALT_N    )  { Event_RunEditRaspRule         ; }  // Настройка распределения агрегатов
  else if (_Key = VK_ALT_S    )  { Event_BuildHier               ; }  // Настройка иерархии

  else if (_Key = VK_ALT_A    )  { MyOnViewCubeRun_RaspCurCell   ; }  // Вызов распределения агрегата
  else if (_Key = VK_ALT_1    )  { MyOpenCurCellByBudget         ; }  // Раскрытие показателя-агрегата по данным бюджета
  else if (_Key = VK_ALT_2    )  { MyOpenCurCellByOborot         ; }  // Раскрытие показателя-агрегата по данным бюджета
  else if (_Key = VK_ALT_3    )  { MyLoadCurCellByOborot         ; }  // Загрузка показателей из книги финансовых операций

  else if (_Key = VK_CTRL_U   )  { Hier_CloseAxisY;              ; }  // Закрыть все узлы вертикальной оси   (Ctrl+U)

  else if (_Key = VK_SHIFT_F3 )  { Event_PickStBud               ; }  // Статьи для анализа
}
// ONEVENTS
//******************************************************************************
