#include Query.vih
#include ExtAttr.vih
#include GetKau.vih
#include AG_gzrTablGKDogView.vih

#component "F_GOZReport"

alter interface v001_gzrF47Editor;

const
  lc_XMLFieldName_KatStroy: string = 'Заказ';
  lc_AutoPATFltName_KatStroy: string = 'агат_Заказы';
  lc_AutoPATFltName_Dogovor_Cur: string = 'агат_Договор';
  lc_AutoPATFltName_IGK: string = 'агат_ИГК';
end;

overload
  constructor Init;
  function myAddAutoPATFiltersToListForCurQuickIGK: boolean;
  function o$gzrBaseRepEditor.RunExportData : boolean;
  function myReCalcFormulasInContract(
    _wCheckLevel  : word;     // режим расчета (см. cgPatCheckLevel_* в BuhConst.inc):
                              //   cgPatCheckLevel_FullCount - расчет
                              //   cgPatCheckLevel_CheckOnly - проверка
    _isUseGPDF    : boolean;  // использовать ли формулы получения данных ч/з ПАТ
    _sPATFileName : string;   // имя ПАТ файла
    _ItemMID      : TPtr;     // ID списка позиций структуры отчета
    _indContract  : LongInt   // индекс контракта
  ) : boolean;
end;

var
  _mKatStroy: TPtr;
  _myReCalcFormulasInContract_indContract: longint;

#include ExtAttr.var
#include GetKau.var

function getKatStroyFld: string; forward;

create view
as select
  getKatStroyFld()(fieldname=KatStroyFld)
;

function getKatStroyFld: string;
{
  result := '';
  var sPath: string = lc_Path_Kontrakt + GetIter(iter_Kontrakt) + '/' + lc_XMLFieldName_KatStroy;
  var nodeCnt: LongInt = pModiRepStruct.GetNodeCountByPath(sPath);
  var i: integer = 0;
  for (i := 0; i < nodeCnt; i++)
  {
    var sCurPath: string = sPath + GetIter(i);
    var s: string = if(getanykau(1, cgKau_ObjBuild, pModiRepStruct.GetCompValueByPath(sCurPath)), givenanname(1), '');
    result += if(result = '', nodeCnt + ': ', ', ') + SubStr(s, 1, pos(' ', s + ' ') - 1);
  }
}

procedure PickKatStroy;
{
  var selCnt: longint = iGetKau.GetCodeKau(cgiMulti, cgKau_ObjBuild, 0);
  if selCnt  = 0 exit;

  var sPath: string = lc_Path_Kontrakt + GetIter(iter_Kontrakt) + '/' + lc_XMLFieldName_KatStroy;
  var nodeCnt: LongInt = pModiRepStruct.GetNodeCountByPath(sPath);

  //удаляем лишние ноды (в структуре 10 заказов, юзер выбрал 3: с 4 по 10 ноды удаляем)
  var i: integer = 0;
  for(i := selCnt; i < nodeCnt; i++)
    if not pModiRepStruct.DeleteNodeByPath(sPath + GetIter(i))
    {
      sLastError := pModiRepStruct.GetStLastError;
      FpLog(#(__InterfaceName__)+'.PickKatStroy: '+sLastError);
      Exit;
    }

  //Читаем выбранные юзером нреки в маркер
  var m: TPtr = InitMarker(iGetKau.GetMarkerName(cgKau_ObjBuild), 8, 10, 10, true);
  //пишем в ноды нреки заказов, выбранные пользователем
  var c: comp;
  for(i := 0; GetMarker(m, i, c); i++)
  {
    var sCurPath: string = sPath + GetIter(i);
    if not pModiRepStruct.SetCompValueByPath(sCurPath, c)
    {
      FpLog(#(__InterfaceName__)+'.PickKatStroy: '+pModiRepStruct.GetStLastError);
      break;
    }
    pModiRepStruct.SetIsHidenRecByPath(sCurPath, true);
  }
  DoneMarker(m, '');
  RereadRecord;
}

procedure DelOnProtectKatStroy;
{
  var sPath: string = lc_Path_Kontrakt + GetIter(iter_Kontrakt) + '/' + lc_XMLFieldName_KatStroy;
  var nodeCnt: LongInt = pModiRepStruct.GetNodeCountByPath(sPath);
  var i: integer = 0;
  for(i := nodeCnt - 1; i >= 0 ; i--)
    if not pModiRepStruct.DeleteNodeByPath(sPath + GetIter(i))
    {
      sLastError := pModiRepStruct.GetStLastError;
      FpLog(#(__InterfaceName__)+'.PickKatStroy: '+sLastError);
      Exit;
    }
  RereadRecord;
}

constructor Init;
{
  otQuickIGKDog := IgzrTablGKDogView(new(AG_gzrTablGKDogView));
  result := inherited::Init;
}

//==============================================================================
//#region ЭКСПОРТ В XML
//------------------------------------------------------------------------------
// Запустить экспорт в XML
function o$gzrBaseRepEditor.RunExportData : boolean;
{
  Result := False;
  if (not pModiRepStruct.SetDateTimeValueByPath(path_DataFormirovanija, _CurDateTime, lc_ModifyOwner_Alg) )
  {
    sLastError := pModiRepStruct.GetStLastError;
    FpLog(#(__InterfaceName__)+'.RunExportData: '+sLastError);
    Exit;
  }

  var sExportPath: string = '';
  ReadMyDsk(sExportPath, 'v001_gzrF46Editor_sExportPath', false);

  if sExportPath != ''
  {
    if (not pEXMLRepStruct.ExportData(cRepSesID, sExportPath))
    {
      sLastError := pEXMLRepStruct.GetStLastError;
      FpLog(#(__InterfaceName__)+'.RunExportData: '+sLastError);
      Exit;
    }
  }
  else if (not inherited::RunExportData)
  {
    FpLog(#(__InterfaceName__)+'.RunExportData: '+sLastError);
    Exit;
  }
  Result := True;
} // function RunExportData
//#endregion ЭКСПОРТ В XML
//******************************************************************************

sql query qKatStroy =
select t.Nrec
from (select distinct KatStroy.Nrec
      from Dogovor
      join SpDocs on SpDocs.TiDk = Dogovor.TiDk and SpDocs.cDoc = Dogovor.Nrec
      join SpecMtr on SpecMtr.coTable = 1723 and SpecMtr.cSpec = SpDocs.Nrec
      join KatStroy on KatStroy.Nrec = SpecMtr.cObj
      where Dogovor.Nrec = :cDogovor
      union
      select distinct KatStroy.Nrec
      from Dogovor
      join CalPlan on CalPlan.cDogovor = Dogovor.Nrec and CalPlan.DirectMc = Dogovor.Direct and CalPlan.Status <> 3
      join SpDocs on SpDocs.TiDk = 403 and SpDocs.cDoc = CalPlan.Nrec
      join SpecMtr on SpecMtr.coTable = 1723 and SpecMtr.cSpec = SpDocs.Nrec
      join KatStroy on KatStroy.Nrec = SpecMtr.cObj
      where Dogovor.Nrec = :cDogovor
      union
      select distinct KatStroy.Nrec
      from Dogovor
      join SpDocs on SpDocs.TiDk = Dogovor.TiDk and SpDocs.cDoc = Dogovor.Nrec
      join SpecMtr on SpecMtr.coTable = 1723 and SpecMtr.cSpec = SpDocs.Nrec
      join KatStroy on KatStroy.Nrec = SpecMtr.cObj
      where Dogovor.cDogovor = :cDogovor and Dogovor.Status <> 3
      union
      select distinct KatStroy.Nrec
      from Dogovor
      join CalPlan on CalPlan.cDogovor = Dogovor.Nrec and CalPlan.DirectMc = Dogovor.Direct and CalPlan.Status <> 3
      join SpDocs on SpDocs.TiDk = 403 and SpDocs.cDoc = CalPlan.Nrec
      join SpecMtr on SpecMtr.coTable = 1723 and SpecMtr.cSpec = SpDocs.Nrec
      join KatStroy on KatStroy.Nrec = SpecMtr.cObj
      where Dogovor.cDogovor = :cDogovor and Dogovor.Status <> 3
      union
      select KatStroy.Nrec
      from AttrVal
      join KatStroy on KatStroy.Nrec = AttrVal.vComp or (KatStroy.cStroy = AttrVal.vComp and AttrVal.vComp <> #comp(0))
      where AttrVal.wTable = 1707 and AttrVal.cRec = :cDogovor and AttrVal.cAttrNam = :cAttrNam
      union
      select KatStroy.Nrec
      from Dogovor
      join AttrVal on AttrVal.wTable = 1707 and AttrVal.cRec = Dogovor.Nrec and AttrVal.cAttrNam = :cAttrNam
      join KatStroy on KatStroy.Nrec = AttrVal.vComp or (KatStroy.cStroy = AttrVal.vComp and AttrVal.vComp <> #comp(0))
      where Dogovor.cDogovor = :cDogovor and Dogovor.Status <> 3
     ) t
;

//------------------------------------------------------------------------------
// Заполняет маркер m нреками заказов по контракту с индексом contractIndex
function KatStroyToMarker(contractIndex: integer; m: TPtr): boolean;
{
  result := false;
  //Если фильтр по заказам принудительно установлен пользователем и сохранен
  //в структуре отчета - применяем его
  var sPath: string = lc_Path_Kontrakt + GetIter(contractIndex) + '/' + lc_XMLFieldName_KatStroy;
  var nodeCnt: LongInt = pModiRepStruct.GetNodeCountByPath(sPath);
  if nodeCnt > 0
  {
    var i: integer = 0;
    for(i := 0; i < nodeCnt; i++)
      InsertMarker(m, pModiRepStruct.GetCompValueByPath(sPath + GetIter(i)));
  }
  else //иначе - устанавливаем фильтр по заказам по договору
  {
    var cDogovor: comp  = pModiRepStruct.GetCompValueByPath(lc_Path_Kontrakt+getIter(contractIndex)+'/'+lc_XMLFieldName_cDogovor);
    if cDogovor = 0 exit;
    var q: IQuery = queryManager.createQuery(qKatStroy)
                                .setParam('cDogovor', cDogovor)
                                .setParam('cAttrNam', ATTRNAM_NREC_DOGOVOR_ZAKAZ);
    var rs: IResultSet = q.getResultSet;
    if q.errorCode != tsOk
    {
      FpLog(#(__InterfaceName__)+'.SqlQueryError: qKatStroy '+ q.errorCode);
      exit;
    }
    if rs.getFirst = tsOk do
    {
      InsertMarker(m, comp(rs.row.valAt(1)));
    }
    while rs.getNext = tsOk;
  } //if nodeCnt > 0
  result := true;
}
// Заполняет маркер m нреками заказов по контракту с индексом contractIndex
//------------------------------------------------------------------------------


//------------------------------------------------------------------------------
// Добавить авто ПАТ фильтры в список
function myAddAutoPATFiltersToListForCurQuickIGK: boolean;
{
  result := inherited::myAddAutoPATFiltersToListForCurQuickIGK;
  if not result exit;
  var mKatStroy: TPtr = InitMarker('', 8, 10, 10, true);
  var isAllOk : boolean = True;
  do
  {
    //#region фильтр: "Текущий договор"
    do
    {
      if not myAddAutoTblPatFlt(lc_AutoPATFltName_Dogovor_Cur   // наименование фильтра
                              , cgKau_Dogovor                   // код аналитики
                              , False)                          // признак: "исключая номера"
      {
        FpLog(#(__InterfaceName__)+'.myLoadPATFilterListFromFile:'+ sLastError);
        isAllOk := False;
        Break;
      }
      if not myAddAutoTblSpPatFlt(otQuickIGKDog.cDogovor)
      {
        FpLog(#(__InterfaceName__)+'.myLoadPATFilterListFromFile:'+ sLastError);
        isAllOk := False;
        Break;
      }
      FpLog(#(__InterfaceName__)+'.myLoadPATFilterListFromFile: Пат-фильтр "' + lc_AutoPATFltName_Dogovor_Cur + '": ' + ShowKau(cgKau_Dogovor, otQuickIGKDog.cDogovor));
    }
    while False;
    if not isAllOk Break;
    //#endregion фильтр: "Текущий договор"

    //#region фильтр: "Заказы по текущему договору"
    do
    {
      if not myAddAutoTblPatFlt(lc_AutoPATFltName_KatStroy, cgKau_ObjBuild, False)
      {
        FpLog(#(__InterfaceName__)+'.myLoadPATFilterListFromFile:'+ sLastError);
        isAllOk := False;
        Break;
      }

      if not KatStroyToMarker(_myReCalcFormulasInContract_indContract, mKatStroy)
      {
        isAllOk := False;
        Break;
      }
      var i: longint = 0;
      var cKatStroy: comp = 0;
      for(i := 0; GetMarker(mKatStroy, i, cKatStroy); i++)
      {
        if not myAddAutoTblSpPatFlt(cKatStroy)
        {
          FpLog(#(__InterfaceName__)+'.myLoadPATFilterListFromFile:'+ sLastError);
          isAllOk := False;
          Break;
        }
        FpLog(#(__InterfaceName__)+'.myLoadPATFilterListFromFile: Пат-фильтр "' + lc_AutoPATFltName_KatStroy + '": ' + ShowKau(cgKau_ObjBuild, cKatStroy));
      }
    }
    while False;
    if not isAllOk Break;
    //#endregion фильтр: "Заказы по текущему договору"

    //#region фильтр: "ИГК по заказам текущего договора"
    do
    {
      if not myAddAutoTblPatFlt(lc_AutoPATFltName_IGK, KODGRKAU_IGK, False)
      {
        FpLog(#(__InterfaceName__)+'.myLoadPATFilterListFromFile:'+ sLastError);
        isAllOk := False;
        Break;
      }
      var q: IQuery = queryManager.createQuery(qKatStroy)
                                  .setParam('cDogovor', otQuickIGKDog.cDogovor)
                                  .setParam('cAttrNam', ATTRNAM_NREC_DOGOVOR_ZAKAZ);
      if q.execute.errorCode != tsOk
      {
        FpLog(#(__InterfaceName__)+'.SqlQueryError: qKatStroy '+ q.errorCode);
        isAllOk := False;
        Break;
      }
      var mIGK: TPtr = InitMarker('', 8, 10, 10, true);
      while q.fetch.errorCode = tsOk
      {
        var cIGK: comp = oExtAttr.coGetAttrId(coKatStroy, q.row.valAt(1), ATTRNAM_NREC_KATSTROY_IGK);
        if cIGK = 0 continue;
        if foundMarker(mIGK, cIGK) continue;
        InsertMarker(mIGK, cIGK);
        if not myAddAutoTblSpPatFlt(cIGK)
        {
          FpLog(#(__InterfaceName__)+'.myLoadPATFilterListFromFile:'+ sLastError);
          isAllOk := False;
          Break;
        }
        FpLog(#(__InterfaceName__)+'.myLoadPATFilterListFromFile: Пат-фильтр "' + lc_AutoPATFltName_IGK + '": ' + ShowKau(KODGRKAU_IGK, cIGK));
      }
      DoneMarker(mIGK, '');
    }
    while False;
    if not isAllOk Break;
    //#endregion фильтр: "ИГК по заказам текущего договора"
  }
  while False;

  DoneMarker(mKatStroy, '');

  result := isAllOk;
}
//------------------------------------------------------------------------------


//------------------------------------------------------------------------------
// Рассчитать формулы по контракту отчета
function myReCalcFormulasInContract(
  _wCheckLevel  : word;     // режим расчета (см. cgPatCheckLevel_* в BuhConst.inc):
                            //   cgPatCheckLevel_FullCount - расчет
                            //   cgPatCheckLevel_CheckOnly - проверка
  _isUseGPDF    : boolean;  // использовать ли формулы получения данных ч/з ПАТ
  _sPATFileName : string;   // имя ПАТ файла
  _ItemMID      : TPtr;     // ID списка позиций структуры отчета
  _indContract  : LongInt   // индекс контракта
) : boolean;
{
  //при установке пат-фильтров во время расчета формул по контракту - необходимо знать индекс обрабатываемого контракта
  //т.к. этот параметр не передается в функцию установки пат-фильтров myAddAutoPATFiltersToListForCurQuickIGK,
  //сохраняем его в глобальную переменную
  _myReCalcFormulasInContract_indContract := _indContract;
  result := inherited::myReCalcFormulasInContract(_wCheckLevel, _isUseGPDF, _sPATFileName, _ItemMID, _indContract);
}
// Рассчитать формулы по контракту отчета
//------------------------------------------------------------------------------

extendformats scContract;

Screen scContract (,, sci1Esc);
  Table HierNavigator;
  fields
    KatStroyFld: protect, pickButton;
<<
                                                                                                                                      `Заказы`.@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
>>
end; //Screen scContract

TableEvent Table HierNavigator;

  cmPick:
  {
    case CurField of
      #KatStroyFld: PickKatStroy;
      else inherited::handleevent(cmPick);
    end;
  }

  cmDelOnProtect:
  {
    case CurField of
      #KatStroyFld: DelOnProtectKatStroy;
      else inherited::handleevent(cmDelOnProtect);
    end;
  }

end; //TableEvent Table HierNavigator;

handleevent

  cmHotKeys:
  {
    //Загружаем меню из стандартного функционала
    if trim(GetIHotKey) = '' Exit;
    var lMenu: longint = MenuMaker::LoadDynMenu(GetIHotKey);

    //Добавляем дополнительные пункты меню ячейки
    //Пункты меню должны быть прописаны в дочерних элементах с именем "Меню" к текущей ячейке
    //В значении элемента должно быть установлено выполняемое выражение (параметр ф-ции expression)

    var arrRun: array[65000..65049] of string;
    do {
      //Определяем путь до подчиненных элементов текущей ячейки
      var sPath: string = GetCurFieldPath;
      if (sPath = '') break;
      sPath += '/Меню';

      //Добавляем доп. пункты меню, записываем в массив описания, что надо выполнить
      //при срабатывании доп пунктов меню arrRun
      var nodeCnt: LongInt = pModiRepStruct.GetNodeCountByPath(sPath);
      var i: longint = 0;
      for (i := 0; i < nodeCnt; i++)
      {
        var buf: Type$p_MTRepStruct;
        if not pModiRepStruct.GetBuffByPath(sPath + GetIter(i), buf, false) break;
        if trim(buf.sValue) = '' continue;
        AddMenuItem(lMenu, if(buf.Note = '', 'Дополнительный пункт меню ' + i, buf.Note), word(65000 + i));
        arrRun[65000 + i] := buf.sValue;
      }
    } while false;

    //Запускаем меню. Если выбран один из дополнительных пунктов, выполняем его в соответствии с arrRun
    //иначе запускаем стандартный обработчик команды.
    var wCmd: word = RunLoadMenu(lMenu);
    if wCmd >= 65000 and wCmd <= 65049
    {
      SaveMyDSK(FpPeriod.dBeg, 'AG_GOZ_DBeg');
      SaveMyDSK(FpPeriod.dEnd, 'AG_GOZ_DEnd');
      var m: TPtr = InitMarker('', 8, 10, 10, true);
      KatStroyToMarker(iter_Kontrakt, m);
      DoneMarker(m, 'AG_GOZ_mKatStroy');
      var sErr: string = '';
      expression(arrRun[wCmd], sErr);
      if sErr != '' message('Ошибка выполнения дополнительного пункта меню:' + chr(13) + sErr, error);
    }
    else if wCmd != cmCancel
      PutCommand(wCmd);
  }

end; //handleevent

end.
