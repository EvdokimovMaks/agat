#include Cleverence.vih
#include Logger.vih
#include Extattr.vih
#include Query.vih
#include Userreport.vih

#component "AGAT"

interface SyncCleverence 'Обмен данными с сервером ТСД', escclose;
show (,,118,15);
#include SyncCleverenceQueries.inc

table struct tdocs (
  kind     : word,
  nrec     : comp,
  startDate: date,
  name     : string
) with index (
  i01 = kind + nrec
);

table struct tSpDocs (
  kind     : word,
  docNrec  : comp,
  spDocNrec: comp,
  cRec     : comp,
  placePlan: string,
  placeFact: string,
  kolPlan  : double,
  kolFact  : double
) with index (
  i01 = kind + docNrec
);

const
  KIND_OS = 1;
  KIND_MBP = 2;
  DOCTYPE_INV = 'Инвентаризация';
end;

type tspkau = record as table spkau;

var
  _logger: UTILS::Logger new;
  _curLogger: UTILS::Logger noauto;
  _extAttr: IExtAttr;
  _writer: Cleverence::IWriter;

create view
as select *
from spkau spkCells, tdocs, tSpDocs, spkau, mbpinv, mbpin, spinvtab, kaureff
where ((
  KODGRKAU_PLACE == spkCells.kodgrkau
));

create view vExp
var
  dateFrom: date;
as select *
from invtab, spinvtab
where ((
  15          == invtab.tipdoc and (invtab.dinv >= vExp.dateFrom) and
  invtab.nrec == spinvtab.cinvtab
));

embedded scLog interface _logger.wLog;
show(,3,,);
end;

screen scMain;
show (,,,2) fixed_y;
buttons
  cmDoSync, default;
<<
<.                                                  Синхронизация                                                  .>
>>
end;

//#region Logger

procedure SetCurLogger(aLogger: UTILS::Logger);
{
  _curLogger := aLogger;
}
procedure RefreshLog;
{
  rescanpanel(scLog);
}
procedure LogError  (indent: byte; s: string);
{
  _curLogger.LogError(indent, s);
  RefreshLog;
  SetVisualHeader(s);
}
procedure LogWarning(indent: byte; s: string);
{
  _curLogger.LogWarning(indent, s);
  RefreshLog;
  SetVisualHeader(s);
}
procedure LogSuccess(indent: byte; s: string);
{
  _curLogger.LogSuccess(indent, s);
  RefreshLog;
  SetVisualHeader(s);
}
procedure LogInfo   (indent: byte; s: string);
{
  _curLogger.LogInfo(indent, s);
  RefreshLog;
  SetVisualHeader(s);
}
//#endregion

//#region SyncCatalogs

function SyncCatalogs: boolean;
{
  result := false;

  LogInfo(0, 'Экспорт справочников ОС и МБП');

  var q: IQuery;
  q := queryManager.CreateQuery(qOSMBP);
  q.setParam('anMBPBarcode', ATTRNAME_MBP_BARCODE);
  q.setParam('anMBPPlace', ATTRNAME_MBP_PLACE);

  var rs: IResultSet;
  rs := q.getResultSet;

  if (rs = nullref)
  {
    LogError(1, 'Ошибка выполнения запроса. Код ошибки:' + q.errorCode);
    exit;
  }

  var fname: string;
  fname := translatepath(sgettune('AGAT.BARCODE.EXPORTPATH')+'Номенклатура.csv');
  if not _writer.Open(fname)
  {
    LogError(1, 'Ошибка формирования файла '+fname);
    LogError(1, 'Проверьте доступ на запись');
    exit;
  }

  _writer.ClearBuffer;
  _writer.SetValue(0, 'Идентификатор');
  _writer.SetValue(1, 'Штрихкод');
  _writer.SetValue(2, 'Наименование');
  _writer.SetValue(3, 'МОЛ');
  _writer.SetValue(4, 'Подразделение');
  _writer.SetValue(5, 'ДатаВводаВЭксплуатацию');
  _writer.SetValue(6, 'АдресМестонахождения');
  _writer.SetValue(7, 'ИнвентарныйНомер');
  _writer.WriteBuffer;

  if (rs.getFirst = tsOk) do
  {
    _writer.SetValue(0, string(rs.row.Val('kind'))+string(rs.row.Val('nrec')));
    _writer.SetValue(1, rs.row.Val('barcode'));
    _writer.SetValue(2, rs.row.Val('name'));
    _writer.SetValue(3, rs.row.Val('MOL'));
    _writer.SetValue(4, rs.row.Val('Podr'));
    _writer.SetValue(5, rs.row.Val('datek'));
    _writer.SetValue(6, rs.row.Val('place'));
    _writer.SetValue(7, rs.row.Val('innum'));
    _writer.WriteBuffer;
  } while (rs.getNext = tsOk);

  _writer.close;

  result := true;
}

//#endregion

//#region SyncCells

function SyncCells: boolean;
{
  result := false;
  result := true;
}

//#endregion

//#region SyncDocs

function SyncDocs: boolean;
var
  q : IQuery;
  rs: IResultSet;
  i : longint;
{
  result := false;

  LogInfo(0, 'Синхронизация документов');

  //готовим временную таблицу с документами инвентаризации
  sqlDropTmpTable('tDocs');
  var sqlstr: longint; sqlstr := 0;
  sqlAddStr(sqlstr, 'table tDocs(kind: word, nrec: comp, startdate: date, name: string);');
  sqlCreateTmpTable(sqlstr, ctmNormal);

  var docsDateFrom: date;
  docsDateFrom := dGetTune('AGAT.BARCODE.DOCSTARTDATE');

  //заполняем временную таблицу документов инвентаризациями ОС
  q := queryManager.createQuery(qDocs1);
  q.setParam('date', docsDateFrom);
  if q.Execute.errorCode != 0
  {
    LogError(1, 'Ошибка выполнения запроса получения инвентаризаций ОС '+q.errorCode);
    exit;
  }

  //заполняем временную таблицу документов инвентаризациями МБП
  q := queryManager.createQuery(qDocs2);
  q.setParam('date', docsDateFrom);
  if q.Execute.errorCode != 0
  {
    LogError(1, 'Ошибка выполнения запроса получения инвентаризаций МБП '+q.errorCode);
    exit;
  }

  //заполняем локальную таблицу документами
  q := queryManager.createQuery('select kind, nrec, startdate, name from tDocs');
  rs := q.getResultSet;
  if rs = nullref
  {
    LogError(1, 'Ошибка выполнения запроса получения документов '+q.errorCode);
    exit;
  }
  delete all tdocs;
  sqlCopyInto(rs, #tdocs, false);

  //заполняем локальную таблицу спецификаций документов
  q := queryManager.createQuery(qSpDocs);
  q.setParam('anPlacePlan', ATTRNAME_INVOS_PLACE_PLAN);
  q.setParam('anPlaceFact', ATTRNAME_INVOS_PLACE_FACT);
  rs := q.getResultSet;
  if rs = nullref
  {
    LogError(1, 'Ошибка выполнения запроса получения спецификаций документов '+q.errorCode);
    exit;
  }
  delete all tspdocs;
  sqlCopyInto(rs, #tspdocs, false);

}

//#endregion
handleevent

cmDoSync:
{
  startnewvisual(vtRotateVisual, vfThread+vfTimer, '', 0);
  if not SyncCatalogs
    message('Ошибка синхронизации справочников', error)
  //else if not SyncCells
  //  message('Ошибка синхронизации мест хранения', error)
  //else if not SyncDocs
  //  message('Ошибка синхронизации документов', error)
  ;
  stopvisual('',0)
}

cmInit:
{
  if not getvipref(_writer, 'CLEVERENCE::CSVFileWriter')
  {
    message('Ошибка инициализации', error);
    abort;
    exit;
  }

  SetCurLogger(_logger);
}

end;

end.

VipInterface UserReport_SyncCleverence Implements IUserReport licensed(free);
Interface UserReport_SyncCleverence;
  create view dummy;
  procedure Run;
  begin
    runinterfacenomodal(AGAT::SyncCleverence);
  end;

  function GetReportName: String;
  begin
    GetReportName := '0100 Обмен данными с сервером ТСД (2015)';
  end;

  function GetGroupName (Level : Word) : String;
  begin
    if (Level = 1)
      GetGroupName := 'Штрих-код'
    else
      GetGroupName := '';
  end;

  function GetPriority : Integer;
  begin
    GetPriority := 0;
  end;

  function VisibleInModule(Ind : Byte) : String;
  begin
    VisibleInModule := '';
    case Ind of
      1 : VisibleInModule := 'B_OSN';
      2 : VisibleInModule := 'MBP';
    end;
  end;
end.
