#include Cleverence.vih
#include Logger.vih
#include Extattr.vih
#include Query.vih
#include Userreport.vih

#component "AGAT"

interface SyncCleverence 'Обмен данными с сервером ТСД', escclose;
show (,,118,15);
#include SyncCleverenceQueries.inc

table struct tCats (
  kind: word,
  nrec: comp,
  name: string,
  barcode: string[50],
  mol: string,
  podr: string,
  datek: date,
  place: string,
  innum: string[50]
) with index (
  i01 = kind + nrec (unique)
);

table struct tdocs (
  Year     : word,
  Month    : word,
  PodrNrec : comp,
  MOLNrec  : comp
) with index (
  i01 = Year + Month + PodrNrec + MOLNrec
);

table struct tSpDocs (
  Year     : word,
  Month    : word,
  PodrNrec : comp,
  MOLNrec  : comp,
  Kind     : word,
  cRec     : comp,
  placePlan: string,
  placeFact: string,
  kolPlan  : double,
  kolFact  : double
) with index (
  i01 = Year + Month + PodrNrec + MOLNrec + Kind
);

table struct tcells (
  barcode: string[50],
  name: string
) with index (
  i01 = barcode (unique)
);

const
  KIND_OS = 1;
  KIND_MBP = 2;
  DOCTYPE_INV = 'Инвентаризация';
end;

type tspkau = record as table spkau;

var
  _logger   : UTILS::Logger new;
  _curLogger: UTILS::Logger noauto;
  _extAttr  : IExtAttr;
  _writer   : Cleverence::IWriter;
  _reader   : Cleverence::IReader;
  _docReader: Cleverence::DocumentReader new;

create view
as select *
from spkau spkCells, tCats, tdocs, tSpDocs, tcells, spkau, invtab, spinvtab, mbpmove, mbpinv,
     mbpin, kaureff, katpodr, katmbp
where ((
  KODGRKAU_PLACE == spkCells.kodgrkau
));

create view vExp
var
  dateFrom: date;
as select *
from invtab, spinvtab
where ((
  15          == invtab.tipdoc and (invtab.dinv >= vExp.dateFrom) and
  invtab.nrec == spinvtab.cinvtab
));

embedded scLog interface _logger.wLog;
show(,3,,);
end;

screen scMain;
show (,,,2) fixed_y;
buttons
  cmDoSync, default;
<<
 <.                                                 Синхронизация                                                 .>
>>
end;

//#region Logger

procedure SetCurLogger(aLogger: UTILS::Logger);
{
  _curLogger := aLogger;
}
procedure RefreshLog;
{
  rescanpanel(scLog);
}
procedure LogError  (indent: byte; s: string);
{
  _curLogger.LogError(indent, s);
  RefreshLog;
  SetVisualHeader(s);
}
procedure LogWarning(indent: byte; s: string);
{
  _curLogger.LogWarning(indent, s);
  RefreshLog;
  SetVisualHeader(s);
}
procedure LogSuccess(indent: byte; s: string);
{
  _curLogger.LogSuccess(indent, s);
  RefreshLog;
  SetVisualHeader(s);
}
procedure LogInfo   (indent: byte; s: string);
{
  _curLogger.LogInfo(indent, s);
  RefreshLog;
  SetVisualHeader(s);
}
//#endregion

//#region SyncCatalogs

function ExportCatalogs: boolean;
{
  result := false;

  LogInfo(0, 'Экспорт справочников ОС и МБП');

  var q: IQuery;
  q := queryManager.CreateQuery(qOSMBP);
  q.setParam('anMBPBarcode', ATTRNAME_MBP_BARCODE);
  q.setParam('anMBPPlace', ATTRNAME_MBP_PLACE);

  var rs: IResultSet;
  rs := q.getResultSet;

  if (rs = nullref)
  {
    LogError(1, 'Ошибка выполнения запроса. Код ошибки:' + q.errorCode);
    exit;
  }
  delete all tCats;
  sqlCopyInto(rs, #tCats, false);

  var fname: string;
  fname := translatepath(sgettune('AGAT.BARCODE.EXPORTPATH')+'Номенклатура.csv');
  if not _writer.Open(fname)
  {
    LogError(1, 'Ошибка формирования файла '+fname);
    LogError(1, 'Проверьте доступ на запись');
    exit;
  }

  _writer.ClearBuffer;
  _writer.SetValue(0, 'Идентификатор');
  _writer.SetValue(1, 'Штрихкод');
  _writer.SetValue(2, 'Наименование');
  _writer.SetValue(3, 'МОЛ');
  _writer.SetValue(4, 'Подразделение');
  _writer.SetValue(5, 'ДатаВводаВЭксплуатацию');
  _writer.SetValue(6, 'АдресМестонахождения');
  _writer.SetValue(7, 'ИнвентарныйНомер');
  _writer.WriteBuffer;

  if (rs.getFirst = tsOk) do
  {
    _writer.SetValue(0, string(rs.row.Val('kind'))+string(rs.row.Val('nrec'),0,0));
    _writer.SetValue(1, rs.row.Val('barcode'));
    _writer.SetValue(2, rs.row.Val('name'));
    _writer.SetValue(3, rs.row.Val('MOL'));
    _writer.SetValue(4, rs.row.Val('Podr'));
    _writer.SetValue(5, datetostr(rs.row.Val('datek'),'DD.MM.YYYY'));
    _writer.SetValue(6, rs.row.Val('place'));
    _writer.SetValue(7, rs.row.Val('innum'));
    _writer.WriteBuffer;
  } while (rs.getNext = tsOk);

  _writer.close;

  LogSuccess(1, 'Экспорт справочников ОС и МБП завершен успешно');
  result := true;
}

//#endregion

//#region SyncCells

function ExportCells: boolean;
{
  result := false;
  LogInfo(0, 'Экспорт мест хранения');

  var fname: string;
  fname := translatepath(sgettune('AGAT.BARCODE.EXPORTPATH')+'Места хранения.csv');
  if not _writer.Open(fname)
  {
    LogError(1, 'Ошибка формирования файла '+fname);
    LogError(1, 'Проверьте доступ на запись');
    exit;
  }

  _writer.ClearBuffer;
  _writer.SetValue(0, 'Штрихкод');
  _writer.SetValue(1, 'Наименование');
  _writer.WriteBuffer;

  delete all tCells;

  _loop spkCells
  {
    if getfirst tCells where ((spkCells.Code == tCells.barcode)) != tsOk
    {
      _writer.SetValue(0, spkCells.Code);
      _writer.SetValue(1, spkCells.Name);
      _writer.WriteBuffer;
      insert tCells set tCells.barcode := spkCells.Code, tCells.name := spkCells.Name;
    }
  }

  _writer.close;

  LogSuccess(1, 'Экспорт мест хранения завершен успешно');
  result := true;
}

//#endregion

//#region SyncDocs

function ExportDocs: boolean;
var
  q : IQuery;
  rs: IResultSet;
{
  result := true;

  LogInfo(0, 'Экспорт документов инвентаризаций');

  var docsDateFrom: date;
  docsDateFrom := dGetTune('AGAT.BARCODE.DOCSTARTDATE');

  //заполняем временную таблицу спецификаций документов
  q := queryManager.createQuery(qSpDocs);
  q.setParam('date', docsDateFrom);
  q.setParam('anPlacePlan', ATTRNAME_INVOS_PLACE_PLAN);
  q.setParam('anPlaceFact', ATTRNAME_INVOS_PLACE_FACT);

  rs := q.getResultSet;
  if (rs = nullref)
  {
    LogError(1, 'Ошибка выполнения запроса'+q.errorCode);
    result := false;
    exit;
  }
  delete all tspdocs;
  sqlCopyInto(rs, #tspdocs, true);

  //заполняем временную таблицу документов
  delete all tdocs;
  _loop tspdocs
  {
    if getfirst tdocs where ((tspdocs.Year == tdocs.Year and tspdocs.Month == tdocs.Month and tspdocs.PodrNrec == tdocs.PodrNrec and tspdocs.MOLNrec == tdocs.MOLNrec)) != tsOk
    {
      clearbuffer(#tdocs);
      tdocs.Year     := tspdocs.Year;
      tdocs.Month    := tspdocs.Month;
      tdocs.PodrNrec := tspdocs.PodrNrec;
      tdocs.MOLNrec  := tspdocs.MOLNrec;
      insert current tdocs;
    }
  }

  var fname: string;

  //формируем файлы документов
  _loop tdocs
  {
    fname := translatepath(sgettune('AGAT.BARCODE.EXPORTPATH')+'Инвентаризация №');
    fname += tdocs.Year+tdocs.Month+string(tdocs.PodrNrec,0,0)+string(tdocs.MOLNrec,0,0)+'.csv';
    if not _writer.Open(fname)
    {
      LogError(1, 'Ошибка формирования файла '+fname);
      result := false;
      continue;
    }
    _writer.ClearBuffer;
    _writer.SetValue(0, '#{Document}');
    _writer.WriteBuffer;

    _writer.ClearBuffer;
    _writer.SetValue(0, 'Name');
    _writer.SetValue(1, 'Year');
    _writer.SetValue(2, 'Month');
    _writer.SetValue(3, 'PodrNrec');
    _writer.SetValue(4, 'MOLNrec');
    _writer.WriteBuffer;

    _writer.ClearBuffer;
    _writer.SetValue(0, tdocs.Month+'.'+tdocs.year+' '+
                        if(getanykau(1,60, tdocs.MOLNrec),givenanname(1),'') + ' ' +
                        if(getfirst katpodr where ((tdocs.PodrNrec == katpodr.nrec)) = tsOk, katpodr.kod, ''));
    _writer.SetValue(1, tdocs.year);
    _writer.SetValue(2, tdocs.Month);
    _writer.SetValue(3, string(tdocs.PodrNrec,0,0));
    _writer.SetValue(4, string(tdocs.MOLNrec,0,0));
    _writer.WriteBuffer;

    _writer.ClearBuffer;
    _writer.SetValue(0, '#{Document.DeclaredItems}');
    _writer.WriteBuffer;

    _writer.ClearBuffer;
    _writer.SetValue(0, 'Штрихкод');
    _writer.SetValue(1, 'План');
    _writer.SetValue(2, 'Факт');
    _writer.SetValue(3, 'Место хранения');
    _writer.WriteBuffer;

    _loop tspdocs where ((tdocs.Year == tspdocs.Year and tdocs.Month == tspdocs.Month and tdocs.PodrNrec == tspdocs.PodrNrec and tdocs.MOLNrec == tspdocs.MOLNrec))
    {
      if getfirst tCats where ((tspdocs.kind == tCats.kind and tspdocs.cRec == tCats.nrec)) != tsOk continue;
      if (tspdocs.KolPlan > 0 and tspdocs.placePlan <> '')
      {
        _writer.SetValue(0, tcats.barcode);
        _writer.SetValue(1, doubletostr(tspdocs.kolPlan, '[|-]3666,88'));
        _writer.SetValue(2, '0');
        _writer.SetValue(3, tspdocs.placePlan);
        _writer.WriteBuffer;
      }
      if (tspdocs.KolFact > 0 and tspdocs.placeFact <> '')
      {
        _writer.SetValue(0, tcats.barcode);
        _writer.SetValue(1, '0');
        _writer.SetValue(2, doubletostr(tspdocs.kolFact, '[|-]3666,88'));
        _writer.SetValue(3, tspdocs.placeFact);
        _writer.WriteBuffer;
      }
    }
    _writer.close;
  }

  if result
    LogSuccess(1, 'Экспорт документов инвентаризаций завершен успешно');
  else
    LogError(1, 'Экспорт документов инвентаризаций завершен с ошибками');
}

function GetPlaceByCode(placeCode: string): tspkau;
{
  var rslt: tspkau;
  if getfirst spkau where ((KODGRKAU_PLACE == spkau.kodgrkau and placeCode == spkau.code)) = tsOk
    rslt := tspkau(spkau.buffer)
  else
    clearadvrecord(rslt);
  result := rslt;
}

procedure SetOSInvItem(invtabNrec: comp; item:CLEVERENCE::IDocumentItem);
{
  var katosNrec: comp;
  katosNrec := comp(substr(item.ProductId,2,255));

  var place: tspkau;
  place := GetPlaceByCode(item.Place);

  if getfirst spinvtab where ((invtabNrec == spinvtab.cinvtab and katosNrec == spinvtab.cmc)) != tsOk
  {
    clearbuffer(#spinvtab);
    spinvtab.cinvtab := invtabNrec;
    spinvtab.cmc     := katosNrec;
    insert current spinvtab;
    if getfirst kaureff where (( 3000           == kaureff.cotable and
                                 spinvtab.cmc   == kaureff.crec and
                                 KODGRKAU_PLACE == kaureff.wkau )) = tsOk
    {
      _extattr.coSetAttr(1124, spinvtab.nrec, ATTRNAME_INVOS_PLACE_PLAN, kaureff.ckau, if(getanykau(1,KODGRKAU_PLACE, kaureff.ckau), givenanname(1), '' ));
    }
  }
  update current spinvtab set spinvtab.kol := item.FactQty;
  _extattr.coSetAttr(1124, spinvtab.nrec, ATTRNAME_INVOS_PLACE_FACT, place.nrec, place.name);
}

procedure SetMBPInvItem(mbpmoveNrec: comp; item:CLEVERENCE::IDocumentItem);
{

  var mbpinNrec: comp;
  mbpinNrec := comp(substr(item.ProductId,2,255));

  var place: tspkau;
  place := GetPlaceByCode(item.Place);

  if getfirst mbpinv where ((mbpmoveNrec == mbpinv.cmove and (mbpinv.crecs[1] = mbpinNrec) )) != tsOk
  {
    clearbuffer(#mbpinv);
    mbpinv.cmove := mbpmoveNrec;
    mbpinv.crecs[1] := mbpinNrec;
    mbpinv.crecs[2] := _extattr.coGetAttr(2001, mbpinNrec, ATTRNAME_MBP_PLACE);
    if getfirst mbpin where (( mbpinNrec == mbpin.nrec )) = tsOk
    {
      mbpinv.ckatmbp := mbpin.cmbp;
      mbpinv.price := mbpin.price;
      mbpinv.dinv := mbpin.din;
      if getfirst katmbp where ((mbpin.cmbp == katmbp.nrec)) = tsOk
      {
        mbpinv.kod  := katmbp.name;
        mbpinv.name := katmbp.nnumber;
      }
    }
    insert current mbpinv;
  }
  update current mbpinv set mbpinv.crecs[3] := place.nrec, mbpinv.fctkol := item.FactQty;
}

function ImportDoc(d: CLEVERENCE::IDocument): boolean;
{

  LogInfo(1, 'Импорт документа '+d.name);

  var d1, d2: date;
  d1 := date(1, d.Month, d.Year);
  d2 := date(last_day(d1), d.Month, d.Year);

  //определяем нрек инвентаризации ОС с подразделением и молом из документа
  var invtabNrec: comp;
  var invtabEditable: boolean;
  if getfirst invtab where ((15           == invtab.tipdoc and
                             d.PodrNrec   == invtab.cSklad and
                             d1          <<= invtab.dinv and
                             (invtab.dinv <= d2 and invtab.cMol = d.MOLNrec) )) = tsOk
  {
    invtabNrec := invtab.nrec;
    invtabEditable := invtab.dinvend = 0;
  }
  else
  {
    invtabNrec := 0;
    invtabEditable := false;
  }

  //определяем нрек инвентаризации спецоснастки с подразделением и молом из документа
  var mbpmoveNrec: comp;
  var mbpmoveEditable: boolean;
  if getfirst mbpmove where (( 11         == mbpmove.status and
                               d.PodrNrec == mbpmove.cpodrf and
                               d1        <<= mbpmove.dmove and
                               (d.MOLNrec = mbpmove.cmolf and d2 >= mbpmove.dmove) )) = tsOk
  {
    mbpmoveNrec := mbpmove.nrec;
    mbpmoveEditable := mbpmove.cvalold = 0;
  }
  else
  {
    mbpmoveNrec := 0;
    mbpmoveEditable := false;
  }

  var i, productKind: word;
  var productNrec: comp;
  var item: CLEVERENCE::IDocumentItem;
  for(i:=0; i < d.ItemCount; ++i)
  {
    item := d.GetItem(i);
    if item = nullref continue;
    if item.FactQty = 0 continue;
    productKind := substr(item.ProductId,1,1);
    case productKind of
      KIND_OS : if (invtabEditable)  SetOSInvItem(invtabNrec, item);
      KIND_MBP: if (mbpmoveEditable) SetMBPInvItem(mbpmoveNrec, item);
    end;
  }
}

function ImportDocs: boolean;
{
  result := true;

  LogInfo(0, 'Импорт документов инвентаризаций');

  var docsDateFrom: date;
  docsDateFrom := dGetTune('AGAT.BARCODE.DOCSTARTDATE');

  var d: CLEVERENCE::IDocument;

  var fname: string;
  fname := GetFirstFile(sGetTune('AGAT.BARCODE.IMPORTPATH'), 'Инвентаризация №*.csv');
  while (fname != '')
  {
    d := _docReader.Load(fname);
    if (d != nullref)
    {
      ImportDoc(d);
      FreeVipInterface(d);
    }
    DeleteFile(fname);
    fname := GetNextFile;
  }
}

//#endregion

//#region SyncUtil

function RunSyncUtilExport: boolean;
{
  LogInfo(0, 'Выгрузка данных на ТСД');

  var appPath: string;
  appPath := sGetTune('AGAT.BARCODE.SYNCCONPATH');

  var rslt: integer;
  ExecProgram(appPath, 'upload close closeerr tray', 'Выгрузка данных на ТСД', pfSilent, rslt);

  if rslt = 0
  {
    LogSuccess(1, 'Выгрузка данных на ТСД завершена успешно');
    result := true;
  }
  else
  {
    LogError(1, 'Выгрузка данных на ТСД завершена с ошибкой: '+rslt);
    result := false;
  }
}

function RunSyncUtilImport: boolean;
{
  LogInfo(0, 'Загрузка данных из ТСД');

  var appPath: string;
  appPath := sGetTune('AGAT.BARCODE.SYNCCONPATH');

  var rslt: integer;
  ExecProgram(appPath, 'download close closeerr tray', 'Загрузка данных из ТСД', pfSilent, rslt);

  if rslt = 0
  {
    LogSuccess(1, 'Загрузка данных из ТСД завершена успешно');
    result := true;
  }
  else
  {
    LogError(1, 'Загрузка данных из ТСД завершена с ошибкой: '+rslt);
    result := false;
  }
}

//#endregion


handleevent

cmDoSync:
{
  startnewvisual(vtRotateVisual, vfTimer, '', 0);
  //RunSyncUtilImport;
  ImportDocs;
  //if not ExportCatalogs
  //  message('Ошибка экспорта справочников МБП и ОС', error)
  //else if not ExportCells
  //  message('Ошибка экспорта мест хранения', error)
  //else if not ExportDocs
  //  message('Ошибка экспорта документов', error);
  //else RunSyncUtilExport;
  stopvisual('',0)
}

cmInit:
{
  if not getvipref(_writer, 'CLEVERENCE::CSVFileWriter')
  {
    message('Ошибка инициализации', error);
    abort;
    exit;
  }
  if not getvipref(_reader, 'CLEVERENCE::CSVFileReader')
  {
    message('Ошибка инициализации', error);
    abort;
    exit;
  }
  _docReader.IReaderSet(_reader);

  SetCurLogger(_logger);
}

end;

end.

VipInterface UserReport_SyncCleverence Implements IUserReport licensed(free);
Interface UserReport_SyncCleverence;
  create view dummy;
  procedure Run;
  begin
    runinterfacenomodal(AGAT::SyncCleverence);
  end;

  function GetReportName: String;
  begin
    GetReportName := '0100 Обмен данными с сервером ТСД (2015)';
  end;

  function GetGroupName (Level : Word) : String;
  begin
    if (Level = 1)
      GetGroupName := 'Штрих-код'
    else
      GetGroupName := '';
  end;

  function GetPriority : Integer;
  begin
    GetPriority := 0;
  end;

  function VisibleInModule(Ind : Byte) : String;
  begin
    VisibleInModule := '';
    case Ind of
      1 : VisibleInModule := 'B_OSN';
      2 : VisibleInModule := 'MBP';
    end;
  end;
end.
