#include Cleverence.vih
#include Logger.vih
#include Extattr.vih
#include Query.vih
#include Userreport.vih

#component "AGAT"

interface SyncCleverence 'Обмен данными с сервером ТСД', escclose;
show (,,118,15);
#include SyncCleverenceQueries.inc

table struct tCats (
  kind: word,
  nrec: comp,
  name: string,
  barcode: string[50],
  mol: string,
  podr: string,
  datek: date,
  place: string,
  innum: string[50]
) with index (
  i01 = kind + nrec (unique)
);

table struct tdocs (
  Year     : word,
  Month    : word,
  PodrNrec : comp,
  MOLNrec  : comp
) with index (
  i01 = Year + Month + PodrNrec + MOLNrec
);

table struct tSpDocs (
  Year     : word,
  Month    : word,
  PodrNrec : comp,
  MOLNrec  : comp,
  Kind     : word,
  cRec     : comp,
  placePlan: string,
  placeFact: string,
  kolPlan  : double,
  kolFact  : double
) with index (
  i01 = Year + Month + PodrNrec + MOLNrec + Kind
);

table struct tcells (
  barcode: string[50],
  name: string
) with index (
  i01 = barcode (unique)
);

const
  KIND_OS = 1;
  KIND_MBP = 2;
  DOCTYPE_INV = 'Инвентаризация';
end;

type tspkau = record as table spkau;

var
  _logger: UTILS::Logger new;
  _curLogger: UTILS::Logger noauto;
  _extAttr: IExtAttr;
  _writer: Cleverence::IWriter;

create view
as select *
from spkau spkCells, tCats, tdocs, tSpDocs, tcells, spkau, mbpinv, mbpin, spinvtab, kaureff, katpodr
where ((
  KODGRKAU_PLACE == spkCells.kodgrkau
));

create view vExp
var
  dateFrom: date;
as select *
from invtab, spinvtab
where ((
  15          == invtab.tipdoc and (invtab.dinv >= vExp.dateFrom) and
  invtab.nrec == spinvtab.cinvtab
));

embedded scLog interface _logger.wLog;
show(,3,,);
end;

screen scMain;
show (,,,2) fixed_y;
buttons
  cmDoSync, default;
<<
 <.                                                 Синхронизация                                                 .>
>>
end;

//#region Logger

procedure SetCurLogger(aLogger: UTILS::Logger);
{
  _curLogger := aLogger;
}
procedure RefreshLog;
{
  rescanpanel(scLog);
}
procedure LogError  (indent: byte; s: string);
{
  _curLogger.LogError(indent, s);
  RefreshLog;
  SetVisualHeader(s);
}
procedure LogWarning(indent: byte; s: string);
{
  _curLogger.LogWarning(indent, s);
  RefreshLog;
  SetVisualHeader(s);
}
procedure LogSuccess(indent: byte; s: string);
{
  _curLogger.LogSuccess(indent, s);
  RefreshLog;
  SetVisualHeader(s);
}
procedure LogInfo   (indent: byte; s: string);
{
  _curLogger.LogInfo(indent, s);
  RefreshLog;
  SetVisualHeader(s);
}
//#endregion

//#region SyncCatalogs

function ExportCatalogs: boolean;
{
  result := false;

  LogInfo(0, 'Экспорт справочников ОС и МБП');

  var q: IQuery;
  q := queryManager.CreateQuery(qOSMBP);
  q.setParam('anMBPBarcode', ATTRNAME_MBP_BARCODE);
  q.setParam('anMBPPlace', ATTRNAME_MBP_PLACE);

  var rs: IResultSet;
  rs := q.getResultSet;

  if (rs = nullref)
  {
    LogError(1, 'Ошибка выполнения запроса. Код ошибки:' + q.errorCode);
    exit;
  }
  delete all tCats;
  sqlCopyInto(rs, #tCats, false);

  var fname: string;
  fname := translatepath(sgettune('AGAT.BARCODE.EXPORTPATH')+'Номенклатура.csv');
  if not _writer.Open(fname)
  {
    LogError(1, 'Ошибка формирования файла '+fname);
    LogError(1, 'Проверьте доступ на запись');
    exit;
  }

  _writer.ClearBuffer;
  _writer.SetValue(0, 'Идентификатор');
  _writer.SetValue(1, 'Штрихкод');
  _writer.SetValue(2, 'Наименование');
  _writer.SetValue(3, 'МОЛ');
  _writer.SetValue(4, 'Подразделение');
  _writer.SetValue(5, 'ДатаВводаВЭксплуатацию');
  _writer.SetValue(6, 'АдресМестонахождения');
  _writer.SetValue(7, 'ИнвентарныйНомер');
  _writer.WriteBuffer;

  if (rs.getFirst = tsOk) do
  {
    _writer.SetValue(0, string(rs.row.Val('kind'))+string(rs.row.Val('nrec'),0,0));
    _writer.SetValue(1, rs.row.Val('barcode'));
    _writer.SetValue(2, rs.row.Val('name'));
    _writer.SetValue(3, rs.row.Val('MOL'));
    _writer.SetValue(4, rs.row.Val('Podr'));
    _writer.SetValue(5, rs.row.Val('datek'));
    _writer.SetValue(6, rs.row.Val('place'));
    _writer.SetValue(7, rs.row.Val('innum'));
    _writer.WriteBuffer;
  } while (rs.getNext = tsOk);

  _writer.close;

  LogSuccess(1, 'Экспорт справочников ОС и МБП завершен успешно');
  result := true;
}

//#endregion

//#region SyncCells

function ExportCells: boolean;
{
  result := false;
  LogInfo(0, 'Экспорт мест хранения');

  var fname: string;
  fname := translatepath(sgettune('AGAT.BARCODE.EXPORTPATH')+'Места хранения.csv');
  if not _writer.Open(fname)
  {
    LogError(1, 'Ошибка формирования файла '+fname);
    LogError(1, 'Проверьте доступ на запись');
    exit;
  }

  _writer.ClearBuffer;
  _writer.SetValue(0, 'Штрихкод');
  _writer.SetValue(1, 'Наименование');
  _writer.WriteBuffer;

  delete all tCells;

  _loop spkCells
  {
    if getfirst tCells where ((spkCells.Code == tCells.barcode)) != tsOk
    {
      _writer.SetValue(0, spkCells.Code);
      _writer.SetValue(1, spkCells.Name);
      _writer.WriteBuffer;
      insert tCells set tCells.barcode := spkCells.Code, tCells.name := spkCells.Name;
    }
  }

  _writer.close;

  LogSuccess(1, 'Экспорт мест хранения завершен успешно');
  result := true;
}

//#endregion

//#region SyncDocs

function ExportDocs: boolean;
var
  q : IQuery;
  rs: IResultSet;
{
  result := true;

  LogInfo(0, 'Экспорт документов инвентаризаций');

  var docsDateFrom: date;
  docsDateFrom := dGetTune('AGAT.BARCODE.DOCSTARTDATE');

  //заполняем временную таблицу спецификаций документов
  q := queryManager.createQuery(qSpDocs);
  q.setParam('date', docsDateFrom);
  q.setParam('anPlacePlan', ATTRNAME_INVOS_PLACE_PLAN);
  q.setParam('anPlaceFact', ATTRNAME_INVOS_PLACE_FACT);

  rs := q.getResultSet;
  if (rs = nullref)
  {
    LogError(1, 'Ошибка выполнения запроса'+q.errorCode);
    result := false;
    exit;
  }
  delete all tspdocs;
  sqlCopyInto(rs, #tspdocs, true);

  //заполняем временную таблицу документов
  delete all tdocs;
  _loop tspdocs
  {
    if getfirst tdocs where ((tspdocs.Year == tdocs.Year and tspdocs.Month == tdocs.Month and tspdocs.PodrNrec == tdocs.PodrNrec and tspdocs.MOLNrec == tdocs.MOLNrec)) != tsOk
    {
      clearbuffer(#tdocs);
      tdocs.Year     := tspdocs.Year;
      tdocs.Month    := tspdocs.Month;
      tdocs.PodrNrec := tspdocs.PodrNrec;
      tdocs.MOLNrec  := tspdocs.MOLNrec;
      insert current tdocs;
    }
  }

  var fname: string;

  //формируем файлы документов
  _loop tdocs
  {
    fname := translatepath(sgettune('AGAT.BARCODE.EXPORTPATH')+'Инвентаризация №');
    fname += tdocs.Year+tdocs.Month+string(tdocs.PodrNrec,0,0)+string(tdocs.MOLNrec,0,0)+'.csv';
    if not _writer.Open(fname)
    {
      LogError(1, 'Ошибка формирования файла '+fname);
      result := false;
      continue;
    }
    _writer.ClearBuffer;
    _writer.SetValue(0, '#{Document}');
    _writer.WriteBuffer;

    _writer.ClearBuffer;
    _writer.SetValue(0, 'Name');
    _writer.SetValue(1, 'Year');
    _writer.SetValue(2, 'Month');
    _writer.SetValue(3, 'PodrNrec');
    _writer.SetValue(4, 'MOLNrec');
    _writer.WriteBuffer;

    _writer.ClearBuffer;
    _writer.SetValue(0, tdocs.Month+'.'+tdocs.year+' '+
                        if(getanykau(1,60, tdocs.MOLNrec),givenanname(1),'') + ' ' +
                        if(getfirst katpodr where ((tdocs.PodrNrec == katpodr.nrec)) = tsOk, katpodr.kod, ''));
    _writer.SetValue(1, tdocs.year);
    _writer.SetValue(2, tdocs.Month);
    _writer.SetValue(3, if(getfirst katpodr where ((tdocs.PodrNrec == katpodr.nrec)) = tsOk, katpodr.kod, ''));
    _writer.SetValue(4, if(getanykau(1,60, tdocs.MOLNrec),givenanname(1),''));
    _writer.WriteBuffer;

    _writer.ClearBuffer;
    _writer.SetValue(0, '#{Document.DeclaredItems}');
    _writer.WriteBuffer;

    _writer.ClearBuffer;
    _writer.SetValue(0, 'Штрихкод');
    _writer.SetValue(1, 'План');
    _writer.SetValue(2, 'Факт');
    _writer.SetValue(3, 'Место хранения');
    _writer.WriteBuffer;

    _loop tspdocs where ((tdocs.Year == tspdocs.Year and tdocs.Month == tspdocs.Month and tdocs.PodrNrec == tspdocs.PodrNrec and tdocs.MOLNrec == tspdocs.MOLNrec))
    {
      if getfirst tCats where ((tspdocs.kind == tCats.kind and tspdocs.cRec == tCats.nrec)) = tsOk
        _writer.SetValue(0, tcats.barcode);
      else
        continue;
      _writer.SetValue(1, doubletostr(tspdocs.kolPlan, '[|-]3666,88'));
      _writer.SetValue(2, doubletostr(tspdocs.kolFact, '[|-]3666,88'));
      _writer.SetValue(3, tspdocs.placePlan);
      _writer.WriteBuffer;
    }
    _writer.close;
  }

  if result
    LogSuccess(1, 'Экспорт документов инвентаризаций завершен успешно');
  else
    LogError(1, 'Экспорт документов инвентаризаций завершен с ошибками');
}

//#endregion

//#region SyncUtil

function RunSyncUtilExport: boolean;
{
  LogInfo(0, 'Выгрузка данных на ТСД');

  var appPath: string;
  appPath := sGetTune('AGAT.BARCODE.SYNCCONPATH');

  var rslt: integer;
  ExecProgram(appPath, 'upload close closeerr tray', 'Выгрузка данных на ТСД', pfSilent, rslt);

  if rslt = 0 or rslt = 1
  {
    LogSuccess(1, 'Выгрузка данных на ТСД завершена успешно');
    result := true;
  }
  else
  {
    LogError(1, 'Выгрузка данных на ТСД завершена с ошибкой: '+rslt);
    result := false;
  }
}

//#endregion


handleevent

cmDoSync:
{
  startnewvisual(vtRotateVisual, vfTimer, '', 0);
  if not ExportCatalogs
    message('Ошибка экспорта справочников МБП и ОС', error)
  else if not ExportCells
    message('Ошибка экспорта мест хранения', error)
  else if not ExportDocs
    message('Ошибка экспорта документов', error)
  else if not RunSyncUtilExport
    message('Ошибка выгрузки данных на ТСД', error);
  stopvisual('',0)
}

cmInit:
{
  if not getvipref(_writer, 'CLEVERENCE::CSVFileWriter')
  {
    message('Ошибка инициализации', error);
    abort;
    exit;
  }

  SetCurLogger(_logger);
}

end;

end.

VipInterface UserReport_SyncCleverence Implements IUserReport licensed(free);
Interface UserReport_SyncCleverence;
  create view dummy;
  procedure Run;
  begin
    runinterfacenomodal(AGAT::SyncCleverence);
  end;

  function GetReportName: String;
  begin
    GetReportName := '0100 Обмен данными с сервером ТСД (2015)';
  end;

  function GetGroupName (Level : Word) : String;
  begin
    if (Level = 1)
      GetGroupName := 'Штрих-код'
    else
      GetGroupName := '';
  end;

  function GetPriority : Integer;
  begin
    GetPriority := 0;
  end;

  function VisibleInModule(Ind : Byte) : String;
  begin
    VisibleInModule := '';
    case Ind of
      1 : VisibleInModule := 'B_OSN';
      2 : VisibleInModule := 'MBP';
    end;
  end;
end.
