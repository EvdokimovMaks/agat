#include Explosion.vih                             //TODO: Удалять узловые позиции, если под ними ничего нет
#include ExplosionQueryStr.vih
#include Query.vih

#component "M_MnPlan"
VipInterface Algoritm_5104 Implements oAlgoritm_Sys;
Interface Algoritm_5104 '' (,hcNoContext,) EscClose, Cyan;

//Запрос для заполнения tObj матценностями для разузлования из входящих планов к текущему с разбивкой по периодам
sql query qObj =
select spm.cIzd as KatmcNrec,
       spm.cAnval1 as HdrpsNrec,
       sum(vsp.kol) as Qty
from objacct oa
join mnplan mp on oa.cobject = mp.nrec and :SrcWayaccouNrec = mp.cwayaccou
join spmnplan spm on mp.nrec = spm.cmnplan
join spmnpl spl on spm.nrec = spl.cspmnplan and :SrcVid = spl.wkolan and 28 = spl.wkodgr4 and mp.nrec = spl.canval4 and 0 = spl.wkodgr5 and #comp(0) = spl.canval5
join valspmnp vsp on spl.nrec = vsp.cspmnpl
where oa.typeown = 4 and oa.cowner = :MnplanNrec and oa.typeobj = 4
group by spm.cizd, spm.canval1
;

table struct tObj ( //таблица с объектами для разузлования
  KatmcNrec   : comp,       //Матценность
  HdrpsNrec   : comp,       //Производственная спецификация
  Qty         : double      //Количество
);

var
  _formplNrec: comp;       //Нрек настроек интерфейса
  _srcWayaccouNrec: comp;  //Нрек шаблона документа - источника
  _srcVid: word;           //Системный номер представления документа-источника, из которого берутся количества
  _typeObjFlags: word;     //Флаги включения видов объектов в результат: 1 бит - МЦ, 2 бит - услуги
  _mnplanNrec: comp;       //Нрек документа, для которого выполняется алгоритм
  _wkodgr1: word;          //Код 1 аналитики строки плана (по шаблону)
  _wkodgr2: word;          //Код 2 аналитики строки плана (по шаблону)
  _wkodgr3: word;          //Код 3 аналитики строки плана (по шаблону)
  _crolean1: comp;         //Роль 1 аналитики строки плана (по шаблону)
  _crolean2: comp;         //Роль 2 аналитики строки плана (по шаблону)
  _crolean3: comp;         //Роль 3 аналитики строки плана (по шаблону)
  _e: AGAT::oExplosion;    //Объект, выполняющий разузлование

  _explosionQuery           : UTILS::iExplosionQueryStr new;               //Базовый запрос разузлования
  _resultQuery              : UTILS::iExplosionResultQueryStr new;         //Базовый запрос выборки результата
  _resultQueryCostitemFilter: UTILS::iExplosionQueryStr_KauFilter new;     //Фильтр на результат по статье
  _resultQueryDeliverFilter : UTILS::iExplosionQueryStr_KauFilter new;     //Фильтр на результат по поставщику
  _resultQueryTypemcFilter  : UTILS::iExplosionQueryStr_KauFilter new;     //Фильтр на результат по типу мц
  _resultQueryGroupmcFilter : UTILS::iExplosionQueryStr_GroupmcFilter new; //Фильтр на результат по группе мц
  _resultQueryObjtypeFilter : UTILS::iExplosionQueryStr_ObjtypeFilter new; //Фильтр на результат по виду объекта - МЦ/Услуга

create view
as select *
from formpl, mnplan, tobj, tExplosion, Spwayac, Mnanal, Spmnplan, Spmnpl, Valspmnp
where ((
  _formplNrec == formpl.nrec and
  _mnplanNrec == mnplan.nrec
));

create view voe
var
  _otpedNrec: comp;
  _prmc: word;
  _cmcusl: comp;
as select * from katotped oe, katotped oe1
where ((
  _otpedNrec == oe.nrec and
  _prmc      == oe1.prmc and
  _cmcusl    == oe1.cmcusl and
  1          == oe1.akt
));

//Процедура заполнения таблицы tObj объектами для разузлования
procedure FillObjects;
{
  var q: IQuery;
  q := queryManager.CreateQuery(qObj);
  q.setParam('SrcWayaccouNrec', _srcWayaccouNrec);
  q.setParam('SrcVid', _srcVid);
  q.setParam('MnplanNrec', _mnplanNrec);
  sqlCopyInto(q.getResultSet, #tObj, false);
}

//вспомогательная функция. возвращает нрек кау по коду из текущей записи tExplosion. Если кау с таким кодом нет - возвращает 0
function GetExplKauByCode(aKauCode: word): comp;
{
  result := if(aKauCode = tExplosion.KauCode1, tExplosion.KauNrec1,
               if(aKauCode = tExplosion.KauCode2, tExplosion.KauNrec2,
                  if(aKauCode = tExplosion.KauCode3, tExplosion.KauNrec3, 0)));
}

function GetOtpEdNrec(aMCNrec: comp; aOtpEdNrec: comp): comp;
{
  voe._otpedNrec := aOtpEdNrec;
  if voe.getfirst oe = tsOk
    result := voe.oe.nrec;
  else
  {
    voe._prmc := 1;
    voe._cmcusl := aMCNrec;
    if voe.getfirst oe1 = tsOk
      result := voe.oe1.nrec
    else
      result := 0;
  }
}

function RemoveExplosion(aParentNrec: longint): boolean;
{
  result := false;
  var l: longint;
  l := initmarker('',4,100,100,false);
  if getfirst tExplosion where ((aParentNrec == tExplosion.ParentNrec)) = tsOk do
  {
    if tExplosion.HdrpsNrec = 0
    {
      result := true;
      continue;
    }
    else
    {
      var rslt: boolean;
      pushpos(#tExplosion);
      rslt := RemoveExplosion(tExplosion.Nrec);
      result := result or rslt;
      poppos(#tExplosion);
      if not rslt insertmarker(l, tExplosion.Nrec);
    }
  } while getnext tExplosion where ((aParentNrec == tExplosion.ParentNrec)) = tsOk
  delete all tExplosion where foundmarker(l, tExplosion.Nrec);
}

procedure FillChildRecords(aExplNrec: longint; aSpmnplanNrec: comp; aParentQty: double);
{
  if (aParentQty = 0) aParentQty := 1;

  _loop tExplosion where ((aExplNrec == tExplosion.ParentNrec))
  {
    // определяем тип позиции (услуга / мц)
    var curTypeIzd: word;
    case tExplosion.Type of
      4: curTypeIzd := 1;
      5: curTypeIzd := 2;
    else
      curTypeIzd := 0;
    end;

    //находим ссылки в аналитиках 1,2,3 строк плана, соответствующие аналитикам в результатах разузлования
    var can1, can2, can3: comp;
    can1 := GetExplKauByCode(_wkodgr1);
    can2 := GetExplKauByCode(_wkodgr2);
    can3 := GetExplKauByCode(_wkodgr3);

    //определяем строку плана по ссылке на заголовок плана, тип позиции и ссылки на позицию
    if getfirst spmnplan where ((curTypeIzd      == spmnplan.typeizd and
                                 tExplosion.cRec == spmnplan.cIzd and
                                 mnplan.nrec     == spmnplan.cmnplan and
                                 _wkodgr1        == spmnplan.wkodgr1 and
                                 can1            == spmnplan.canval1 and
                                 _wkodgr2        == spmnplan.wkodgr2 and
                                 can2            == spmnplan.canval2 and
                                 _wkodgr3        == spmnplan.wkodgr3 and
                                 can3            == spmnplan.canval3 and (spmnplan.cspmnplan = aSpmnplanNrec) )) != tsOk
    {
      clearbuffer(#spmnplan);
      spmnplan.cmnplan  := mnplan.nrec;
      spmnplan.croleizd := coGetTune('SYSTEMANALIT.ROLEIZD'); //Системная роль аналитик "Изделия <Матценность, Услуга>"
      spmnplan.typeizd  := curTypeIzd;
      spmnplan.cIzd     := tExplosion.cRec;
      spmnplan.cOtpEd   := GetOtpEdNrec(spmnplan.cIzd, tExplosion.OtpedNrec);
      spmnplan.wkodgr1  := _wkodgr1;
      spmnplan.crolean1 := _crolean1;
      spmnplan.canval1  := can1;
      spmnplan.wkodgr2  := _wkodgr2;
      spmnplan.crolean2 := _crolean2;
      spmnplan.canval2  := can2;
      spmnplan.wkodgr3  := _wkodgr3;
      spmnplan.crolean3 := _crolean3;
      spmnplan.canval3  := can3;
      spmnplan.csloj    := mnplan.csloj;
      spmnplan.cspmnplan:= aSpmnplanNrec;
      insert current spmnplan;

      //insert tier set tier.ExplNrec := tExplosion.Nrec, tier.ExplParentNrec := tExplosion.ParentNrec, tier.SpmnplanNrec := spmnplan.nrec;
    }
    //определяем ячейку представления по строке, номеру представления и периоду
    if getfirst spmnpl where ((spmnplan.nrec == spmnpl.cspmnplan and
                               _srcVid       == spmnpl.wkolan and
                               28            == spmnpl.wkodgr4 and
                               mnplan.nrec   == spmnpl.cAnVal4 and
                               0             == spmnpl.wkodgr5 and
                               0             == spmnpl.cAnVal5)) != tsOk
    {
      clearbuffer(#spmnpl);
      spmnpl.cspmnplan := spmnplan.nrec;
      spmnpl.wkolan    := _srcVid;
      spmnpl.cRoleAn4  := coGetTune('SYSTEMANALIT.ROLEPRODUCTPLAN'); //Системная роль аналитик "Период планирования"
      spmnpl.wKodGr4   := 28;
      spmnpl.cAnVal4   := mnplan.nrec;
      spmnpl.cRoleAn1  := spmnplan.cRoleAn1;
      spmnpl.wKodGr1   := spmnplan.wKodGr1;
      spmnpl.cAnVal1   := spmnplan.cAnVal1;
      spmnpl.cRoleAn2  := spmnplan.cRoleAn2;
      spmnpl.wKodGr2   := spmnplan.wKodGr2;
      spmnpl.cAnVal2   := spmnplan.cAnVal2;
      spmnpl.cRoleAn3  := spmnplan.cRoleAn3;
      spmnpl.wKodGr3   := spmnplan.wKodGr3;
      spmnpl.cAnVal3   := spmnplan.cAnVal3;
      spmnpl.wKodGr8   := spmnplan.wKodGr4;
      spmnpl.cAnVal8   := spmnplan.cAnVal4;
      spmnpl.typeizd   := spmnplan.TypeIzd;
      spmnpl.cRoleIzd  := spmnplan.cRoleIzd;
      spmnpl.cIzd      := spmnplan.cIzd;
      spmnpl.cOtpEd    := spmnplan.cOtpEd;
      spmnpl.NumSort   := spmnplan.NumSort;
      spmnpl.Number    := spmnplan.Number;
      spmnpl.cSloj     := spmnplan.cSloj;
      spmnpl.cMnPlan   := spmnplan.cmnplan;
      spmnpl.cMnAnal   := mnanal.nrec;
      insert current spmnpl;
    }
    if getfirst valspmnp where ((spmnpl.nrec == valspmnp.cspmnpl)) != tsOk
    {
      clearbuffer(#valspmnp);
      ValSpMnP.cSpMnPl := SpMnPl.nRec;
      ValSpMnP.Num     := 1;
      ValSpMnP.cOtpEd  := SpMnPl.cOtpEd;
      ValSpMnP.EdTime  := SpMnPl.EdTime;
      ValSpMnP.kol     := tExplosion.Qty / aParentQty;
      ValSpMnP.price   := aParentQty;
      ValSpMnP.vprice  := tExplosion.Qty;
      ValSpMnP.summa   := 1;
      insert current valspmnp;
    }
    else
    {
      ValSpMnP.kol     := tExplosion.Qty / aParentQty;
      ValSpMnP.price   := aParentQty;
      ValSpMnP.vprice  := tExplosion.Qty;
      ValSpMnP.summa   := if(ValSpMnP.summa = 0, 1, ValSpMnP.summa);
      update current ValSpMnP;
    }
    pushpos(#tExplosion);
    FillChildRecords(tExplosion.Nrec, Spmnplan.Nrec, tExplosion.Qty);
    poppos(#tExplosion);
  }
}

//Процедура заполнения плана результатами разузлования. Запись происходит в представление Период с нреком PeriodNrec
procedure FillDocument;
{
  //определяем набор аналитик представления по периоду (понадобится при формировании spmnpl)
  if getfirst mnanal where ((mnplan.csloj == mnanal.csloj and
                             0            == mnanal.cblock and
                             0            == mnanal.FldAn1 and
                             mnplan.nrec  == mnanal.FldAn2 and
                             0            == mnanal.FldAn3 )) != tsOk
  {
    clearbuffer(#MnAnal);
    MnAnal.cSloj  := MnPlan.cSloj;
    MnAnal.cBlock := 0;
    MnAnal.FldAn2 := mnplan.nrec;
    insert current MnAnal;
  }
  //проходим в цикле по результатам разузлования и добавляем строки и количества

  FillChildRecords(0,0,1);

}

//Реализация функций объектного интерфейса--------------------------------------------------------------------
Function RunInter(wflag: word; var pt: TRecAcc): boolean;
{
  RunInter := false;
  wflag := wflag; pt.Position := pt.Position;
  //заполняем таблицу объектами для разузлования
  delete all tObj;
  FillObjects;
  //очищаем таблицу с результатами разузлования
  delete all tExplosion;
  //в объекте разузлования очищаем коллекцию объектов для разузлования
  _e.ClearItemsForExplosion;
  //в объект разузлования передаем срез мц для разузлования по периоду из tper
  _loop tObj
  {
    _e.AddItemForExplosion(tObj.KatmcNrec, tObj.HdrpsNrec, tObj.Qty);
  }
  //запускаем разузлование. при этом происходит заполнение таблицы tExplosion
  _e.Explosion;
  //_e.ShowResultTable;
  //удаляем узлы без мц
  RemoveExplosion(0);
  //заполняем документ результатами разузлования
  FillDocument;
  RunInter := true;
}

function InitInter(var pt: TRecAcc): boolean;
{
  result := true;

  //Находим в БД настройки алгоритма
  _formplNrec := pt.cFormPl;
  if (getfirst formpl != tsOk)
  {
    message('Не найдены настройки алгоритма (pt.cFormPl='+pt.cFormPl+')', error);
    result := false;
  }
  else
  {
    _srcWayaccouNrec := formpl.rescomp[1];
    _srcVid := formpl.resword[2];
    _typeObjFlags := formpl.resword[1];
  }

  //Находим в БД текущий документ
  _mnplanNrec := pt.cMnPlan;
  if (getfirst mnplan != tsOk)
  {
    message('Не найден текущий документ (pt.cpNrec='+pt.cpNrec+')', error);
    result := false;
  }
  else
  {
    //определяем коды и роли аналитик строк плана по шаблону
    if getfirst spwayac where ((mnplan.cwayaccou == spwayac.cwayacmain and 16 == spwayac.code)) = tsOk
    {
      _wkodgr1  := spwayac.wvalres[7];
      _wkodgr2  := spwayac.wvalres[8];
      _wkodgr3  := spwayac.wvalres[9];
      _crolean1 := spwayac.cvalres[7];
      _crolean2 := spwayac.cvalres[8];
      _crolean3 := spwayac.cvalres[9];
    }
    else
    {
      message('Ошибка определения кодов и ролей аналитик строк плана по шаблону', error);
      result := false;
    }
  }

  //Инициализируем объект разузлования
  if not LoadVipRef(_e, 'AGAT::iExplosion')
  {
    message('Ошибка инициализации объекта разузлования', error);
    result := false;
  }
  else
  {
    //Инициализируем запросы

    _e.ExplosionQueryStr                  := UTILS::oQueryStr(_explosionQuery);

    _explosionQuery.AddFilter(oQueryStr(_resultQueryCostitemFilter));
    _explosionQuery.AddFilter(oQueryStr(_resultQueryDeliverFilter));
    _explosionQuery.AddFilter(oQueryStr(_resultQueryTypemcFilter));
    _explosionQuery.AddFilter(oQueryStr(_resultQueryGroupmcFilter));
    _explosionQuery.AddFilter(oQueryStr(_resultQueryObjtypeFilter));

    _resultQueryCostitemFilter.FormplNrec := _formplNrec;
    _resultQueryCostitemFilter.Typerec    := 2;
    _resultQueryCostitemFilter.KodgrKAU   := 10016;

    _resultQueryDeliverFilter.FormplNrec  := _formplNrec;
    _resultQueryDeliverFilter.Typerec     := 3;
    _resultQueryDeliverFilter.KodgrKAU    := 1;

    _resultQueryTypemcFilter.FormplNrec   := _formplNrec;
    _resultQueryTypemcFilter.Typerec      := 4;
    _resultQueryTypemcFilter.KodgrKAU     := 5008;

    _resultQueryGroupmcFilter.FormplNrec  := _formplNrec;
    _resultQueryGroupmcFilter.Typerec     := 1;

    _resultQueryObjtypeFilter.Flag        := _typeObjFlags;

    _e.ResultQueryStr                     := UTILS::oQueryStr(_resultQuery);

  }
}

Function DoneInter(var pt: TRecAcc): boolean;
{
  pt.Position := pt.Position;
  DoneInter := true;
}

function GetNum: word;
{
  GetNum := 5104;
}

function GetName: string; {
  GetName := 'АГАТ. Расчет состава изделия для РКМ';
}

function GetMemo (st:oSteckCommonString): boolean; {
  GetMemo := true;
  st.push(string(''));
}

function GetNameInter: string; {
  GetNameInter := 'Algoritm_5104' ;
}

function GetNameInterPr: string; {
  GetNameInterPr := 'AlgoritmSetup_5104' ;
}
end.
