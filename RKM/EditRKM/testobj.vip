#include imodify.vih

objinterface itestobj;
  property nrec: comp;
  property name: string;
  index i01 = nrec;
end;

vipinterface testobj implements itestobj, imodify;

interface testobj;
table struct tt (nrec: comp, name: string) with index (i01 = nrec);
create view as select * from tt;
Function doInsert: word; { result := insert current tt; }
Function doUpdate: word; { result := update current tt; }
implementation IModify.doFlush abstract;
Function doDelete: word; { result := delete current tt; }
property Nrec: comp absolute tt.nrec;
property Name: string absolute tt.name;
index i01 auto;
end.

vipinterface testobjiterator;
public:
  procedure SetTestObj(aTestObj: itestobj);
  procedure setName(aNrec: comp; aName: string);
end;

interface testobjiterator;
var obj: itestobj(testobj);
create view
as select * from obj where (( 1 == obj.nrec ));
procedure SetTestObj(aTestObj: itestobj); { obj := aTestObj; }
procedure setName(aNrec: comp; aName: string);
{
  if getfirst obj where ((aNrec == obj.nrec)) = tsOk
  {
    update current obj set obj.name := aName;
    message(aname);
  }
}
end.

interface testtestobj;
var
  obj: itestobj(testobj) new;
  iterator: testobjiterator new;

create view
as select *
from obj where (( 2 == obj.nrec ));

screen sc1;
show(,,,4);
buttons
  cmValue1;
  cmValue2;
<<
  <. 1 .> <. 2 .>
>>
end;
browse br1;
  show(,5,,);
  table obj;
  fields
    obj.nrec: protect;
end;

handleevent
cmValue1:
{
  iterator.settestobj(obj);
  rereadrecord;
}
cmValue2:
{
  iterator.setName(2, 'asdf');
  rereadrecord;
}
cminit:
{
  insert obj set nrec := 1;
  insert obj set nrec := 2;
  insert obj set nrec := 3;
  insert obj set nrec := 4;
  insert obj set nrec := 5;
}
end;

end.
