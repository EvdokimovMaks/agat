#include GlobalGoods.vih
#include ExternalQuery.vih
#include GlobalMatchManager.vih
#include Query.vih

#component "AGAT"

interface GoodsMatch;

const
  MatchDirection_SearchGlobal = 1;
  MatchDirection_SearchGalaxy = 2;
  MatchDirection_DontSearch   = 0;
end;

table struct tMatches (
  katmcNrec   : comp,
  groupmcNrec : comp,
  typemcNrec  : comp,
  katmcName   : string,
  katmcBarcode: string[30],
  goodsId     : comp,
  goodsName   : string,
  measureId   : comp,
  measureName : string,
  matchesFound: longint,
  direction   : byte,
  colored     : word,  // new field for clever coloring (id of color)
  GalColored  : boolean, // if true - окрасить ячейку "Галактика МЦ"
  GlobColored : boolean  // if true - окрасить ячейку "Глобал МЦ"
) with index (
  i01 = katmcNrec + goodsId,
  i02 = katmcName,
  i03 = goodsName
);

table struct tFoundedMC (
  Nrec : comp,
  Name : string
) with index (
  i01 = nrec,
  i02 = Name
);

type tMatchesBuffer = record as table tMatches;

var
  _externalQueryTextFactory: IExternalQueryTextFactory;
  _externalQuery           : IExternalQuery;
  _ei                      : L_MCU::EdIzm;
  _gmm                     : GlobalMatchManager;
  _globalGoodsSelector     : GlobalGoodsSelector;
  _searcher                : IGlobalMatchSearcher;

create view
as select *
from tMatches, tMatches brMatches(i03), tFoundedMC
;

create view vAdd
var
  _katmcNrec: comp;
  _goodsId: comp;
as select *
from tMatches, katmc
where ((
  _katmcNrec == tMatches.katmcNrec and
  _goodsId   == tMatches.goodsId and
  _katmcNrec == katmc.nrec
));

procedure ReDrawAll(katmcnrec: comp);  // процедура для редактирования brMatches
{
  var curmc, curgood: comp;
  curmc := brMatches.katmcNrec;
  curgood := brMatches.goodsId;

  vAdd._katmcNrec := katmcnrec;
  if vAdd.getfirst katmc != tsOk { message('Ошибка! МЦ не выбрана или такой не существует', error); exit; };

  var gdsid: comp;
  if getfirst brMatches where ((vAdd.katmc.nrec == brMatches.katmcNrec)) = tsOk gdsid := brMatches.goodsId;

  if getfirst brMatches where ((vAdd.katmc.nrec == brMatches.katmcNrec and gdsid == brMatches.goodsId)) = tsOk
  { // удаляем катмц
    brMatches.katmcNrec := 0;
    brMatches.katmcName := '';
    brMatches.matchesFound--;
    update current brMatches;
  }

  if getfirst brMatches where ((curmc == brMatches.katmcNrec and curgood == brMatches.goodsId)) = tsOk
  {
    brMatches.matchesFound++;
    if brMatches.matchesFound = 1 then brMatches.colored := 3; // green, if it's first match
    brMatches.katmcNrec := katmcnrec;
    brMatches.katmcName := vAdd.katmc.name;
    brMatches.GalColored := true;
    update current brMatches;
  }
  ReReadRecord(#brMatches);
}

window wFounded 'Найденные сопоставления', escclose, doaccept;
  browse bro;
  table tFoundedMC;
  fields
    tFoundedMC.Name 'Наименование МЦ' : [40], protect;
  end;
end;

window wMatches 'Установка соответствий МЦ Галактика ERP и Global ERP', escclose, doaccept;
browse brmain;
  table brMatches;
  fields
    brMatches.KatmcName                   'Галактика МЦ' : [50], protect, PickButton, {font = {BackColor = if(brMatches.GalColored, brMatches.colored, 0)}};
    brMatches.matchesFound           'Кол-во'#13'соотв.' : [5], protect, PickButton;
    _ei.GetAktOtpEdAbbr(brMatches.katmcNrec,1) 'Ед.изм.' : [10], protect;
    brMatches.GoodsName                      'Global МЦ' : [50], protect, PickButton, {font = {BackColor = if(brMatches.GlobColored, brMatches.colored, 0)}};
    brMatches.MeasureName                      'Ед.изм.' : [10], protect;
end;
handleevent
cmInit:
{
  _loop brMatches
  {
    if brMatches.matchesFound > 1
    {
      brMatches.colored := 12; // yellow
      brMatches.GalColored := true;
      update current brMatches;
    }
  }
  RedrawPanel(#brMatches);
}
cmPick:
{
  if CurField = #brMatches.KatmcName then // [...] Галактика МЦ
  {
    if brMatches.KatmcName != '' and brMatches.matchesFound = 1 and not brMatches.GalColored then // нельзя выбирать, если есть однозначное сопоставление
    {
      message('Сопоставление этой МЦ уже произведено! Нельзя менять значение!', error);
      exit;
    }
    var M: longint;
    var instring: string;
    M := 0;
    instring := brMatches.GoodsName;
    if RunInterface(AGAT::GalGoods, instring, M, false) = cmDefault then // false это единичный выбор МЦ
    {
      var cmp: comp;
      cmp := 0;
      GetMarker(M, 0, cmp);
      vAdd._katmcNrec := cmp;
      if vAdd.getfirst katmc != tsOk { message('Ошибка! МЦ не выбрана или такой не существует', error); exit; };

      if _gmm.SetMatch(cmp, string(brMatches.goodsId)) then ReDrawAll(cmp);
    }
  }
  if CurField = #brMatches.GoodsName then // [...] Глобал МЦ
  {
    if brMatches.GoodsName != '' and not brMatches.GlobColored then
    {
      message('Сопоставление этой МЦ уже произведено! Нельзя менять значение!', error);
      exit;
    }
    if _globalGoodsSelector.ShowUI = cmDefault then
    {
//      _gmm.SetMatch(cmp, string(brMatches.goodsId)); // ему на вход, то что вернёт _globalGoodsSelector
      brMatches.goodsId := _globalGoodsSelector.SelectedGoods.GoodsId;
      brMatches.goodsName := _globalGoodsSelector.SelectedGoods.GoodsName;
      brMatches.colored := 3; // green
      brMatches.GlobColored := true;
      update current brMatches;
      RedrawPanel(#brMatches);
    }
  }
  if CurField = #brMatches.matchesFound then // [...] в matchesFounded
  {
    var rs: IResultSet;
    var i: integer;
    delete all tFoundedMC;
    case brMatches.direction of
     MatchDirection_SearchGalaxy: {  // SearchGalaxy
         vAdd._goodsId := brMatches.goodsId;
         if vAdd.getfirst tMatches = tsOk { };
         rs := _gmm.FindByRefObjId(brMatches.goodsId);
         if rs.getfirst = tsOk then do
         {
           ClearBuffer(#tFoundedMC);
           tFoundedMC.Name := rs.row.Val('katmcName');
           insert current tFoundedMC;
         }
         while rs.getNext = tsOk;

         if getfirst tFoundedMC where ((brMatches.KatmcName == tFoundedMC.Name and (brMatches.KatmcName != ''))) != tsOk
         {
           tFoundedMC.Name := brMatches.KatmcName;
           insert current tFoundedMC;
         }
         else
         {
           delete tFoundedMC where ((brMatches.KatmcName == tFoundedMC.Name));
         }

         if RunWindowModal(wFounded) = cmDefault then
         {
           brMatches.katmcName := tFoundedMC.Name;
           update current brMatches;
         }
       }
     MatchDirection_SearchGlobal: {   // SearchGlobal
         vAdd._katmcNrec := brMatches.katmcNrec;
         if vAdd.getfirst tMatches = tsOk { };
         rs := _gmm.FindByExternalObjId(brMatches.katmcNrec);
         for (i := 0; i < rs.Count; i++)
         {
           ClearBuffer(#tFoundedMC);
           tFoundedMC.Name := rs.row.Val('goodsName');
           insert current tFoundedMC;
         }

         if getfirst tFoundedMC where ((brMatches.GoodsName == tFoundedMC.Name and (brMatches.GoodsName != ''))) != tsOk
         {
           tFoundedMC.Name := brMatches.GoodsName;
           insert current tFoundedMC;
         }

         if RunWindowModal(wFounded) = cmDefault then
         {
           brMatches.goodsName := tFoundedMC.Name;
           update current brMatches;
         }
       }
    end;
    ReReadRecord(#tFoundedMC);
  }
}
end;
end;

constructor Init;
{
  result := loadvipref(_externalQueryTextFactory, 'AGAT::ExternalQueryTextFactory') and
            loadvipref(_externalQuery, 'AGAT::ExternalQuery') and
            loadvipref(_searcher, 'AGAT::GoodsByKatmcMatchSearcher');
}

function getLinkedServerName: string;
{
  result := 'USELECT';
}

function getMatchesDirection(aKatmcNrec: comp; aGoodsId: comp): byte;
{
  if aKatmcNrec = 0 and aGoodsId != 0
    result := MatchDirection_SearchGalaxy
  else if aKatmcNrec != 0 and aGoodsId = 0
    result := MatchDirection_SearchGlobal
  else
    result := MatchDirection_DontSearch;
}

function SearchGalaxy(buf: tMatchesBuffer): tMatchesBuffer;
{
  var rs: IResultSet;
  rs := _gmm.FindByRefObjId(buf.goodsId);
  buf.matchesFound := rs.Count;
  if rs.getFirst = tsOk
  {
    buf.katmcNrec    := rs.row.Val('katmcNrec');
    buf.groupmcNrec  := rs.row.Val('groupmcNrec');
    buf.typemcNrec   := rs.row.Val('typemcNrec');
    buf.katmcName    := rs.row.Val('katmcName');
    buf.katmcBarcode := rs.row.Val('katmcBarcode');
  }
  result := buf;
}

function SearchGlobal(buf: tMatchesBuffer): tMatchesBuffer;
{
  var rs: IResultSet;
  rs := _gmm.FindByExternalObjId(buf.katmcNrec);
  buf.matchesFound := rs.Count;
  if rs.getFirst = tsOk
  {
    buf.goodsId     := rs.row.Val('goodsId');
    buf.goodsName   := rs.row.Val('goodsName');
    buf.measureId   := rs.row.Val('measureId');
    buf.measureName := rs.row.Val('measureName');
  }
  result := buf;
}

function SearchMatches(aGlobalGoodsCollection: IGlobalGoodsCollection): boolean;
{

  delete all tMatches;

  result := true;

  if (aGlobalGoodsCollection.GetFirst = tsOk) do
  {
    if (aGlobalGoodsCollection.katmcNrec=0 and aGlobalGoodsCollection.goodsId=0) continue;

    vAdd._katmcNrec := aGlobalGoodsCollection.katmcNrec;
    vAdd._goodsId   := aGlobalGoodsCollection.goodsId;
    if vAdd.getfirst tMatches != tsOk
    {
      vAdd.clearbuffer(#vAdd.tMatches);
      if vAdd.getfirst katmc = tsOk
      {
        vAdd.tMatches.katmcNrec    := vAdd.katmc.nrec;
        vAdd.tMatches.groupmcNrec  := vAdd.katmc.cgroupmc;
        vAdd.tMatches.typemcNrec   := vAdd.katmc.ctype;
        vAdd.tMatches.katmcName    := vAdd.katmc.name;
        vAdd.tMatches.katmcBarcode := vAdd.katmc.barkod;
      }
      vAdd.tMatches.goodsId      := aGlobalGoodsCollection.GoodsId;
      vAdd.tMatches.goodsName    := aGlobalGoodsCollection.GoodsName;
      vAdd.tMatches.measureId    := aGlobalGoodsCollection.MeasureId;
      vAdd.tMatches.measureName  := aGlobalGoodsCollection.MeasureName;
      vAdd.tMatches.direction    := getMatchesDirection(vAdd._katmcNrec, vAdd._goodsId);

      if (vAdd.tMatches.goodsId = 0 or vAdd.tMatches.katmcNrec = 0) result := false;

      vAdd.insert current tMatches;
    }
  } while (aGlobalGoodsCollection.GetNext = tsOk);

  var rs: IResultSet;
  _loop tMatches       // поиск соответствий
  {
    case tMatches.direction of
      MatchDirection_SearchGalaxy: {
        rs := _gmm.FindByRefObjId(tMatches.goodsId);
        tMatches.matchesFound := rs.Count;
        if rs.getFirst = tsOk
        {
          tMatches.katmcNrec    := rs.row.Val('katmcNrec');
          tMatches.groupmcNrec  := rs.row.Val('groupmcNrec');
          tMatches.typemcNrec   := rs.row.Val('typemcNrec');
          tMatches.katmcName    := rs.row.Val('katmcName');
          tMatches.katmcBarcode := rs.row.Val('katmcBarcode');
        }
      }
      MatchDirection_SearchGlobal: {
        rs := _gmm.FindByExternalObjId(tMatches.katmcNrec);
        tMatches.matchesFound := rs.Count;
        if rs.getFirst = tsOk
        {
          tMatches.goodsId     := rs.row.Val('goodsId');
          tMatches.goodsName   := rs.row.Val('goodsName');
          tMatches.measureId   := rs.row.Val('measureId');
          tMatches.measureName := rs.row.Val('measureName');
        }
      }
    end;
    update current tMatches;
  }
}

function ShowUI: longint;
{
  result := runwindowmodal(wMatches);
}
end.
