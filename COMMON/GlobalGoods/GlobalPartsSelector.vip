#include GlobalGoods.vih
#include ExternalQuery.vih
#include Marker.vih

#component "AGAT"

interface GlobalPartsSelector;

table struct tDocs (
  DocId      : comp,
  DocName    : string,
  VersionId  : comp,
  VersionName: string,
  GoodsId    : comp,
  GoodsName  : string
) with index (
  i00 = DocId,
  i01 = GoodsName
);

table struct tParts (
  DocId      : comp,
  ParentId   : comp,
  SpecId     : comp,
  GoodsId    : comp,
  GoodsName  : string,
  MeasureId  : comp,
  MeasureName: string[20],
  ParentQty  : double,
  NormQty    : double,
  FullQty    : double,
  VersionId  : comp
) with index (
  i00 = DocId + SpecId,
  i01 = DocId + ParentId + GoodsName
);

var
  _options                 : IGlobalPartsSelectorOptions;
  _externalQueryTextFactory: IExternalQueryTextFactory;
  _externalQuery           : IExternalQuery;
  _selectQty               : double;
  _brpartsMarker           : longint;

create view
var
  _parentId: comp;
(
  brPartsMarked
)
as select foundmarker(_brPartsMarker, brParts.SpecId), *
from tDocs, tParts,
     tDocs brDocs (i01), tParts brParts, tParts brChildParts
where ((
  brDocs.DocId   == brParts.DocId and
  _parentId      == brParts.ParentId and
  brParts.DocId  == brChildParts.DocId and
  brParts.SpecId == brChildParts.ParentId
));

create view vMarkParts
var
  _docId: comp;
  _specId: comp;
as select *
from tParts curParts, tParts childParts
where ((
  _docId  == curParts.DocId and
  _specId == curParts.SpecId and
  _docId  == childParts.DocId and
  _specId == childParts.ParentId
));

function getLinkedServerName: string;
{
  result := if(_options!=nullref, _options.LinkedServerName, '');
}

procedure FillParts(aDocId: comp; aParentId: comp; aVersionId: comp; aParentQty: double = 1; isRecursive: boolean = false);     //aParentId: comp;
{
  var t: IExternalQueryText;
  t := _externalQueryTextFactory.
       CreateText('select dbo.toComp('+string(aDocId)+') as DocId,').
       AddString ('       dbo.toComp('+string(aParentId)+') as ParentId,').
       AddString ('       dbo.toComp(SpecId) as SpecId,').
       AddString ('       dbo.toComp(GoodsId) as GoodsId,').
       AddString ('       GoodsName,').
       AddString ('       dbo.toComp(MeasureId) as MeasureId,').
       AddString ('       MeasureName,').
       AddString ('       cast('+string(aParentQty,0,6)+' as Float) as ParentQty,').
       AddString ('       cast(NormQty as float) as NormQty,').
       AddString ('       cast(NormQty as float) * '+string(aParentQty,0,6)+' as FullQty,').
       AddString ('       dbo.toComp(VersionId) as VersionId').
       AddString ('from openquery ('+getLinkedServerName+', ''').
       AddString ('select spec.Id as SpecId, goods.id as GoodsId, goods.sheadline# as GoodsName, v.Id as VersionId,').
       AddString ('       spec.IdMeasureItem as MeasureId, measure.sShortName as MeasureName, spec.nQuantity as NormQty').
       AddString ('  from BTK.TD_SPECPOSLIST spec').
       AddString ('  join BTK.BS_GOODS goods on goods.id = spec.IdGoods').
       AddString ('  left join BTK.MSR_MEASUREITEMMAP measure on measure.idboobj#=spec.IdMeasureItem').
       AddString ('  left join (select doc.IdGoods, max(version.Id) as Id').
       AddString ('             from BTK.TD_CONSTRSPECIFICATION doc').
       AddString ('             join BTK.TD_SPECIFICATION version on version.idspecification=doc.id and version.idstate_mc=200').
       AddString ('             group by doc.IdGoods').
       AddString ('            ) v on v.IdGoods = goods.Id').
       AddString ('  where spec.idSpecification = '+string(aVersionId)).
       AddString (''')');

  var rs: IResultSet;
  rs := _externalQuery.GetResultSet(t);
  if isRecursive
  {
    if rs.getFirst = tsOk do
    {
      if comp(rs.row.Val('VersionId')) != comp(0)
        FillParts(aDocId, rs.row.Val('SpecId'), rs.row.Val('VersionId'), rs.row.Val('FullQty'), true);
    } while rs.getNext = tsOk;
  }
  sqlCopyInto(rs, #tParts, false);

  /*
  var i: integer;
  for (i:= 1;i<10;i++)
    insert tParts set tParts.DocId       := 1,
                      tParts.ParentId    := 0,
                      tParts.SpecId      := i,
                      tParts.GoodsId     := 1,
                      tParts.GoodsName   := 'GoodsName' + i,
                      tParts.MeasureId   := 1,
                      tParts.MeasureName := 'MeasureName',
                      tParts.ParentQty   := 1,
                      tParts.NormQty     := i,
                      tParts.FullQty     := i,
                      tParts.VersionId   := 0;  */
}

procedure MarkParts(pickMarker: longint; aDocId: comp; mSpecs: longint; aValue: boolean; markHierarhically: boolean = true);
{
  var i: longint; i := 0;
  var c: comp; c := 0;
  vMarkParts._docId := aDocId;
  while getmarker(mSpecs, i, c)
  {
    vMarkParts._specId := c;
    if vMarkParts.getFirst curParts = tsOk
    {
      if aValue
        insertmarker(pickMarker, vMarkParts.curParts.SpecId);
      else
        deletemarker(pickMarker, vMarkParts.curParts.SpecId);

      if markHierarhically and vMarkParts.curParts.VersionId != 0
      {
        if vMarkParts.getFirst fastfirstrow childParts != tsOk
          FillParts(vMarkParts.curParts.DocId, vMarkParts.curParts.SpecId, vMarkParts.curParts.VersionId, vMarkParts.curParts.FullQty, true);
        vMarkParts._loop childParts { insertmarker(mSpecs, vMarkParts.childParts.SpecId); }
      }
    }
    i++;
  }
}

constructor Init;
{
  _brPartsMarker := initmarker('',8,100,100);
  result := loadvipref(_options, 'AGAT::GlobalPartsSelectorOptions') and
            loadvipref(_externalQueryTextFactory, 'AGAT::ExternalQueryTextFactory') and
            loadvipref(_externalQuery, 'AGAT::ExternalQuery');
}

destructor Done;
{
  doneMarker(_brPartsMarker,'');
}

function replaceSymbols(s: string; srcSymbols: string; dstSymbols: string): string;
{
  var i: integer;
  for(i:=1; i<=length(srcSymbols); i++)
    s := replace(s, srcSymbols[i], dstSymbols[i]);
  result := s;
}

function getNameFilter: string;
{
  if _options != nullref
  {
    var s: string;
    s := '%'+replaceSymbols(_options.NameFilter, '`#~!@#$^&*()-+_=,.;:/|\ "''','%%%%%%%%%%%%%%%%%%%%%%%%%%')+'%';
    while pos('%%', s) > 0 do s := replace(s,'%%','%');
    result := s;
  }
  else
    result := '';
}

procedure RefreshDocsTable;
{
  var nf: string;
  nf := ''''''+upcase(getNameFilter)+'''''';
  delete all tDocs;

  var t: IExternalQueryText;
  t := _externalQueryTextFactory.
       CreateText('select dbo.toComp(DocId) as DocId, DocName,').
       AddString ('       dbo.toComp(VersionId) as VersionId, VersionName,').
       AddString ('       dbo.toComp(GoodsId) as GoodsId, GoodsName').
       AddString ('from openquery ('+getLinkedServerName+', ''').
       AddString ('  select doc.Id as DocID, doc.sheadline# as DocName,').
       AddString ('         version.Id as VersionId, version.sheadline# as VersionName,').
       AddString ('         goods.Id as GoodsId, goods.sheadline# as GoodsName').
       AddString ('  from BTK.TD_CONSTRSPECIFICATION doc').
       AddString ('  join BTK.TD_SPECIFICATION version on version.idspecification=doc.id and version.idstate_mc=200').
       AddString ('  join BTK.BS_GOODS goods on goods.id = doc.idgoods').
       AddString ('WHERE UPPER(doc.sheadline#) like '+nf).
       AddString (  ' or UPPER(goods.sheadline#) like '+nf).
       AddString (''')');

  sqlCopyInto(_externalQuery.GetResultSet(t), #tDocs, false);

  /*
  insert tdocs set tdocs.DocId      := 1,
                   tdocs.DocName    := 'DocName',
                   tdocs.VersionId  := 1,
                   tdocs.VersionName:= 'VersionName',
                   tdocs.GoodsId    := 1,
                   tdocs.GoodsName  := 'GoodsName';   */

}

window wSelectGlobalGoods 'Выбор МЦ из состава изделий Global ERP', escclose;
  screen sc1 (,,Sci1EnEsc);
    show(,,,3) fixed_y;
    fields
      [OptionsNameFilter] _options.NameFilter: noprotect;
      _selectQty: noprotect;
<<

`Фильтр:`.@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ `Количество`.@@@@@@@@
>>
  end;
  browse browseDocs (,,Sci1EnEsc);
    show(,4,50,);
    table brDocs;
    fields
      brDocs.GoodsName 'Наименование Изделия': [20], protect;
      brDocs.DocName   'Наименование спецификации': [10], protect;
  end;
  tree 1 treeParts (,,Sci1EscTreeI);
    show(51,4,,);
    table brParts;
    recMarker : if (brPartsMarked,'bmTest1', '' );
    fields
      brParts.GoodsName 'Наименование МЦ': [30], protect;
      brParts.MeasureName 'Ед.Изм.': [5], protect;
      (brParts.ParentQty * _selectQty) 'Кол-во': [8,3], protect;
      brParts.NormQty 'По норме': [8,3], protect;
      (brParts.FullQty * _selectQty) 'Всего': [8,3], protect;
  end;
  procedure CurDocChanged;
  {
    clearmarker(_brPartsMarker);
    _parentId := 0;
    if getfirst brParts != tsOk
      FillParts(brDocs.DocId, 0, brDocs.VersionId, 1);
    if getfirst brParts = tsOk
      TreeJumpToRecord(treeParts, brParts.SpecId);
    rereadrecord(#brParts);
  }
  tableevent table brParts;
    cmTreeTop      : { _parentId := 0; }
    cmTreeUp       : { _parentId := brParts.ParentId;}
    cmTreeDown     : { _parentId := brParts.SpecId;}
    cmTreeNeedOwner: { TreeJumpToRecord(treeParts, brParts.ParentId); }
    cmTreeNodeType : if (brParts.VersionId=0) TreeSetNodeType(treeParts, ntfText);
  end;
  tableevent table brDocs;
    cmPositionChanged: CurDocChanged;
  end;
  handleevent
    cmDoMarkUnmark :
    {
      var mSpecs: longint;
      mSpecs := initmarker('', 8, 1, 100, false);
      insertmarker(mSpecs, brParts.SpecId);
      MarkParts(_brpartsMarker, brParts.DocId, mSpecs, not brPartsMarked);
      donemarker(mSpecs,'');
      redrawcurrentandgo(treeParts, true);
      rescanpanel(#brParts);
    }
    cmSelAll:
    {
      var mSpecs: longint;
      mSpecs := initmarker('', 8, 100, 100, false);
      _loop tParts where ((brDocs.DocId == tParts.DocId and 0 == tParts.ParentId))
        insertmarker(mSpecs, tParts.SpecId);
      MarkParts(_brpartsMarker, brParts.DocId, mSpecs, not brPartsMarked);
      donemarker(mSpecs,'');
      rescanpanel(#brParts);
    }
    cmUnSelAll:
    {
      clearmarker(_brPartsMarker);
      rescanpanel(#brParts);
    }
    cmTreeOpenNode :
    {
      if brParts.VersionId != 0
      {
        if getfirst fastfirstrow brChildParts != tsOk
          FillParts(brParts.DocId, brParts.SpecId, brParts.VersionId, brParts.FullQty);
        rereadrecord(#brParts);
      }
    }
    cmDefault:
    {
      case curfield of
        #OptionsNameFilter:
        {
          RefreshDocsTable;
          rereadrecord(#brDocs);
          if getfirst brDocs = tsOk
          {
            SelectFormat(browseDocs);
            SelectField(#brDocs.GoodsName);
            CurDocChanged;
          }
        }
        #brDocs.GoodsName, #brDocs.DocName:
        {
          SelectFormat(treeParts);
          SelectField(#BRPARTS.GOODSNAME);
        }
        #_selectQty: rereadrecord(#brParts);
      else
        closewindowex(wSelectGlobalGoods, cmDefault);
      end;
    }
    cmInit: clearmarker(_brPartsMarker);
    cmAlt1: { SelectFormat(sc1);        SelectField(#OptionsNameFilter); }
    cmAlt2: { SelectFormat(browseDocs); SelectField(#brDocs.GoodsName);  }
    cmAlt3: { SelectFormat(treeParts);  SelectField(#brParts.GoodsName); }
  end;
end;

handleevent
  cmCheckField:
  {
    if curfield = #_selectQty rereadrecord(#brParts);
  }
end;

function ShowUI: longint;
{
  _selectQty := 1;
  result := runwindowmodal(wSelectGlobalGoods);
}

procedure SetOptions(aOptions: IGlobalPartsSelectorOptions);
{
  _options := aOptions;
}

function Options: IGlobalPartsSelectorOptions;
{
  result := _options;
}

function SelectedGoods: IGlobalGoodsCollection;
{
  var c: IGlobalGoodsCollection;
  c := IGlobalGoodsCollection(new(GlobalGoodsCollection));

  _loop tParts where ((brDocs.DocId == tParts.DocId)) and foundmarker(_brPartsMarker, tParts.SpecId)
  {
    c.ClearCurrent;
    c.GoodsId     := tParts.GoodsId;
    c.GoodsName   := tParts.GoodsName;
    c.MeasureId   := tParts.MeasureId;
    c.MeasureName := tParts.MeasureName;
    c.KatmcNrec   := 0;
    c.OtpedNrec   := 0;
    c.GoodsTopId  := brDocs.GoodsId;
    c.GoodsTopName:= brDocs.GoodsName;
    c.KatmcTopNrec:= 0;
    c.Qty         := tParts.FullQty;
    c.doInsert;
  }

  result := c;
}

end.
