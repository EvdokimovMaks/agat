#component "AGAT"

const
  cmInsertCurrentLevel  = 9931;
  cmInsertChildLevel    = 9932;
  cmDistributeCByPerson = 9933;
  cmDistributeCAll      = 9934;
  cmDistributeZByPerson = 9935;
  cmDistributeZAll      = 9936;
  cmDistributePByPerson = 9937;
  cmDistributePAll      = 9938;
  cmDistributeDByPerson = 9939;
  cmDistributeDAll      = 9940;
  cmDistributeNormHours = 9941;
  cmDistributeNormHoursAll = 9942;
  cmShowDopInfoWindow   = 9943;
  cmOpenAllGroups       = 9944;
  cmCloseAllGroups      = 9945;
  cmSortRows            = 9946;
end;

interface iMWMainController;

table struct tDopInfoGr (
  nRec : comp,
  Summa: double,
  Hours: double,
  PersCnt: word
) with index (
  i01 = nRec (unique)
);

table struct tDopInfo (
  cPerson: comp,
  cKatStroy: comp,
  Summa: double,
  Hours: double
) with index (
  i01 = cKatStroy + cPerson
);

table struct tSort (
  name: array [1..6] of string,
  cRow: comp
) with index (
  i01 = name[1] + name[2] + name[3] + name[4] + name[5] + name[6]
);

var
  MWRow: oMWRow(iMWRow) new;
  MWVal: oMWVal(iMWVal) new;
  SetupFormPl  : TFormPl;
  FullFOT, FullFOTD, BalHours: double;
  EnableEditDocWithAnotherDescr, EnableEditOforml, EnableEditProv, EnableEditUtv: boolean;
  UserDesgr: string[80];

create view
var
  TreeParentRow: comp;
  cCurMnPlan   : comp;
  cSetupFormPl : comp;
as select *
from MnPlan, MWRow, FormPl, tDopInfo, tDopInfoGr, tDopInfoGr brDIGr, tDopInfo brDI, tSort, fpperiod, r_users, r_workplace
where ((
  cCurMnPlan    == MnPlan.nRec and
  TreeParentRow == MWRow.cParent and
  brDIGr.nRec   == brDI.cKatStroy
));

panel pnTabs show(,,,1);
tabbedsheet tsTabs;
screen scGr1 'Трудоемкость' show () fixed_y;
<<
>>
end;
screen scGr2 'Начисл. всего, отраб. время, общие начисления' show () fixed_y;
<<
>>
end;
//screen scGr3 'Начисления общие без заказов, отработанное время' show () fixed_y;
//<<
//>>
//end;
screen scGr3 'Начисления за работы при нахождении на объекте' show () fixed_y;
<<
>>
end;
screen scGr4 'Начисления премиальные' show () fixed_y;
<<
>>
end;
screen scGr5 'Дополнительная заработная плата' show () fixed_y;
<<
>>
end;
end; //tabbedsheet
end; //panel

tree trMain (,,sci1378EscTree)  show(,2,,) excelColumns;
table MWRow;
fields
  {font={bold=not TreeIsTerminal(trMain);}};
  [trMainGr] '' 'Груп-'#13'пировка': [10], noautosize, protect;
  [fld1] MWRow.GetField(1) : [10], protect, pickbutton;
  [fld2] MWRow.GetField(2) : [10], protect, pickbutton;
  [fld3] MWRow.GetField(3) : [10], protect, pickbutton;
  [fld4] MWRow.GetField(4) : [10], protect, pickbutton;
  [fld5] MWRow.GetField(5) : [10], protect, pickbutton;
  [fld6] MWRow.GetField(6) : [10], protect, pickbutton;
//  [MoveLeft] '<' '<'                                 : [3] , noautosize, protect, skip;
  [Val1]  MWVal.GetShowedFieldValue(1 , MWRow)  : [20], noprotect, {font={backcolor=MWVal.GetShowedFieldFontBackColor(1 , MWRow);}};
  [Val2]  MWVal.GetShowedFieldValue(2 , MWRow)  : [20], noprotect, {font={backcolor=MWVal.GetShowedFieldFontBackColor(2 , MWRow);}};
  [Val3]  MWVal.GetShowedFieldValue(3 , MWRow)  : [20], noprotect, {font={backcolor=MWVal.GetShowedFieldFontBackColor(3 , MWRow);}};
  [Val4]  MWVal.GetShowedFieldValue(4 , MWRow)  : [20], noprotect, {font={backcolor=MWVal.GetShowedFieldFontBackColor(4 , MWRow);}};
  [Val5]  MWVal.GetShowedFieldValue(5 , MWRow)  : [20], noprotect, {font={backcolor=MWVal.GetShowedFieldFontBackColor(5 , MWRow);}};
  [Val6]  MWVal.GetShowedFieldValue(6 , MWRow)  : [20], noprotect, {font={backcolor=MWVal.GetShowedFieldFontBackColor(6 , MWRow);}};
  [Val7]  MWVal.GetShowedFieldValue(7 , MWRow)  : [20], noprotect, {font={backcolor=MWVal.GetShowedFieldFontBackColor(7 , MWRow);}};
  [Val8]  MWVal.GetShowedFieldValue(8 , MWRow)  : [20], noprotect, {font={backcolor=MWVal.GetShowedFieldFontBackColor(8 , MWRow);}};
  [Val9]  MWVal.GetShowedFieldValue(9 , MWRow)  : [20], noprotect, {font={backcolor=MWVal.GetShowedFieldFontBackColor(9 , MWRow);}};
  [Val10] MWVal.GetShowedFieldValue(10, MWRow)  : [20], noprotect, {font={backcolor=MWVal.GetShowedFieldFontBackColor(10, MWRow);}};
//  [MoveRight] '>' '>'                                : [3] , noautosize, protect, skip;
end;

procedure FillTDopInfo(_cParent: comp);
{
  var OldTreeParentRow: comp;
  OldTreeParentRow := TreeParentRow;
  TreeParentRow := _cParent;
  _loop MWRow
  {
    if MWRow.IsLeaf
    {
      if MWRow.cKatStroy <> 0
      {
        var _v, _h: double;
        var newperson: boolean;
        MWVal.ActiveGroupIndex := 2;
        _v := MWVal.GetShowedFieldValue(2, MWRow);
        _h := MWVal.GetShowedFieldValue(1, MWRow);
        MWVal.ActiveGroupIndex := 3;
        _h += MWVal.GetShowedFieldValue(1, MWRow);
        FullFOT  += _v;
        if getfirst tDopInfo where ((MWRow.cKatStroy == tDopInfo.cKatStroy and MWRow.cPerson == tDopInfo.cPerson)) <> tsOk
        {
          insert tDopInfo set tDopInfo.cPerson := MWRow.cPerson,
                              tDopInfo.cKatStroy := MWRow.cKatStroy,
                              tDopInfo.Summa := _v,
                              tDopInfo.Hours := _h;
          newperson := true;
        }
        else
        {
          update current tDopInfo set tDopInfo.Summa := tDopInfo.Summa + _v,
                                      tDopInfo.Hours := tDopInfo.Hours + _h;
          newperson := false;
        }
        if getfirst tDopInfoGr where ((MWRow.cKatStroy == tDopInfoGr.nRec)) <> tsOk
        {
          insert tDopInfoGr set tDopInfoGr.nRec := MWRow.cKatStroy,
                                tDopInfoGr.Summa := _v,
                                tDopInfoGr.Hours := _h,
                                tDopInfoGr.PersCnt := 1;
        }
        else
        {
          update current tDopInfoGr set tDopInfoGr.Summa := tDopInfoGr.Summa + _v,
                                        tDopInfoGr.Hours := tDopInfoGr.Hours + _h,
                                        tDopInfoGr.PersCnt := tDopInfoGr.PersCnt + if(newperson,1,0);
        }
      }
    }
    else
    {
      MWVal.ActiveGroupIndex := 2;
      FullFOTD += MWVal.GetShowedFieldDistribute(2, MWRow);
      pushpos(#MWRow);
      FillTDopInfo(MWRow.nRec);
      poppos(#MWRow);
    }
  }
  TreeParentRow := OldTreeParentRow;
}

procedure RefreshDopInfo;
{
  if (getfirst mnplan where ((cCurMnPlan == mnplan.nrec)) = tsOk)
  if (getfirst fpperiod where ((mnplan.canval1 == fpperiod.nrec)) = tsOk)
    BalHours := BalBwDates(11, fpperiod.dbeg,fpperiod.dend,1);
  var _GroupIndex: byte;
  _GroupIndex := MWVal.ActiveGroupIndex;
  FullFOT  := 0;
  FullFOTD := 0;
  delete all tDopInfo;
  delete all tDopInfoGr;
  pushpos(#MWRow);
  FillTDopInfo(0);
  poppos(#MWRow);
  MWVal.ActiveGroupIndex := _GroupIndex;
}

window wDopInfo 'Дополнительная информация' escClose;
screen scDI1 show (,,,4);
  fields
    FullFOTD: ['[|-]366`666`666`666`666.88'],  protect;
    FullFOT : ['[|-]366`666`666`666`666.88'],  protect;
  buttons
    cmRefreshDopInfo, default;
<<

      Для распределения     Распределенный             <. Обновить .>
 ФОТ: .@@@@@@@@@@@@@@@@     .@@@@@@@@@@@@@@@@
>>
end;
tree trDI1 show (,5,,) excelColumns;
fields
  if(TreeGetNodeTable(trDI1) = #BrDIGr, if(getanykau(0, 40, BrDIGr.nRec),givenanname(1),''), if(getanykau(0, 3, BrDI.cPerson),givenanname(1),'')) 'Заказ/Сотрудник': [60], protect;
  if(TreeGetNodeTable(trDI1) = #BrDI  , BrDI.Summa, BrDIGr.Summa) 'Распределенный ФОТ по заказу': [,'[|-]366`666`666`666`666.88'], protect;
  if(TreeGetNodeTable(trDI1) = #BrDI  , BrDI.Hours, BrDIGr.Hours) 'Часы, отработанные по заказу': [,'[|-]366`666`666`666`666.88'], protect;
  if(TreeGetNodeTable(trDI1) = #BrDIGr, BrDIGr.Summa / (BrDIGr.Hours / BalHours), '') 'Средняя з/п по заказу': [,'[|-]366`666`666`666`666.88'], protect;
end;
handleEvent
cmRefreshDopInfo:
{
  RefreshDopInfo;
  rereadrecord;
}
cmInit:
{
  TreeGetFirst(trDI1);
  TreeCloseAllOpenedNode(trDI1);
}
end;
end;

procedure SetColumnProtected(aField: longint; _isProtected: boolean);
{
  if _isProtected
    SetFieldOption(aField, ofProtected)
  else
    ClearFieldOption(aField, ofProtected);
}

procedure RefreshRowColumns;
{
  SetColumnTitle(trMain, #fld1, MWRow.GetFieldTitle(1));
  SetColumnWidth(trMain, #fld1, MWRow.GetFieldWidth(1));
  SetColumnProtected    (#fld1, MWRow.GetFieldProtectedOption(1));
  SetColumnTitle(trMain, #fld2, MWRow.GetFieldTitle(2));
  SetColumnWidth(trMain, #fld2, MWRow.GetFieldWidth(2));
  SetColumnProtected    (#fld2, MWRow.GetFieldProtectedOption(2));
  SetColumnTitle(trMain, #fld3, MWRow.GetFieldTitle(3));
  SetColumnWidth(trMain, #fld3, MWRow.GetFieldWidth(3));
  SetColumnProtected    (#fld3, MWRow.GetFieldProtectedOption(3));
  SetColumnTitle(trMain, #fld4, MWRow.GetFieldTitle(4));
  SetColumnWidth(trMain, #fld4, MWRow.GetFieldWidth(4));
  SetColumnProtected    (#fld4, MWRow.GetFieldProtectedOption(4));
  SetColumnTitle(trMain, #fld5, MWRow.GetFieldTitle(5));
  SetColumnWidth(trMain, #fld5, MWRow.GetFieldWidth(5));
  SetColumnProtected    (#fld5, MWRow.GetFieldProtectedOption(5));
  SetColumnTitle(trMain, #fld6, MWRow.GetFieldTitle(6));
  SetColumnWidth(trMain, #fld6, MWRow.GetFieldWidth(6));
  SetColumnProtected    (#fld6, MWRow.GetFieldProtectedOption(6));
}

Procedure LoadChildRowValues(_TreeParentRow: comp);
{
  var OldTreeParentRow: comp;
  OldTreeParentRow := TreeParentRow;
  TreeParentRow := _TreeParentRow;
  _loop MWRow
  {
    MWVal.LoadRowValues(MWRow);
    pushpos(#MWRow);
    LoadChildRowValues(MWRow.NRec);
    poppos(#MWRow);
  }
  TreeParentRow := OldTreeParentRow;
}

procedure DeleteChildRowValues(_TreeParentRow: comp);
{
  var OldTreeParentRow: comp;
  OldTreeParentRow := TreeParentRow;
  TreeParentRow := _TreeParentRow;
  _loop MWRow
  {
    pushpos(#MWRow);
    DeleteChildRowValues(MWRow.NRec);
    poppos(#MWRow);
    MWVal.DeleteRowValues(MWRow);
  }
  TreeParentRow := OldTreeParentRow;
}

procedure ReloadRowValues;
{
  TreePushPos(trMain);
  while MWRow.cParent <> 0
  {
    TreeJumpToRecord(trMain, MWRow.cParent);
  }
  pushpos(#MWRow);
  DeleteChildRowValues(MWRow.nRec);
  poppos(#MWRow);
  MWVal.DeleteRowValues(MWRow);
  pushpos(#MWRow);
  LoadChildRowValues(MWRow.nRec);
  poppos(#MWRow);
  MWVal.LoadRowValues(MWRow);
  TreePopPos(trMain);
}

procedure DistributeAccrual(_cParent: comp; _HoursFull: double; _AccrualFull: double; _GroupIndex: byte; _FieldIndex: byte);
{
  var OldTreeParentRow: comp;
  var _Hours: double;
  var Distributed: double;
  var _d: double;

  OldTreeParentRow := TreeParentRow;
  pushpos(#MWRow);
  TreeParentRow := _cParent;
  Distributed := 0;
  _loop MWRow
  {
    if MWRow.IsLeaf
    {
      MWVal.ActiveGroupIndex := 2;
      _Hours := double(MWVal.GetShowedFieldValue(1, MWRow));
      _d := _Hours / _HoursFull * _AccrualFull;
      if (_d > trunc(_d,2)) _d := trunc(_d,2) + 0.01;
      MWVal.ActiveGroupIndex := _GroupIndex;
      Distributed += _d;
      if (Distributed > _AccrualFull)
      {
        _d += _AccrualFull - Distributed;
        Distributed := _AccrualFull;
      }
      MWVal.SetShowedFieldValue(_FieldIndex, MWRow, _d);
    }
    else
      DistributeAccrual(MWRow.nRec, _HoursFull, _AccrualFull, _GroupIndex, _FieldIndex);
  }
  TreeParentRow := OldTreeParentRow;
  poppos(#MWRow);
}

procedure DistributeCommonAccruals(_cParent: comp; _cPerson: comp);
{
  var OldTreeParentRow: comp;
  var RowNRec: comp;
  var HoursFull: double;
  var i, _cnt: byte;

  OldTreeParentRow := TreeParentRow;
  pushpos(#MWRow);
  TreeParentRow := _cParent;
  _loop MWRow
  {
    if (MWRow.IsPersonLevel)  and (MWRow.cPerson = _cPerson or _cPerson = 0)
    {
      RowNRec := MWRow.nRec;
      HoursFull := MWVal.GetShowedFieldDistribute(1, MWRow);
      if HoursFull > 0
      {
        _cnt := MWVal.NumberOfFieldsInActiveGroup;
        for (i := 3; i <= _cnt; i += 1)
        {
          DistributeAccrual(MWRow.nRec, HoursFull, MWVal.GetShowedFieldDistribute(i, MWRow), 2, i);
        }
      }
    }
    else
    {
      DistributeCommonAccruals(MWRow.nRec, _cPerson);
    }
  }
  TreeParentRow := OldTreeParentRow;
  poppos(#MWRow);
}

procedure DistributeObjAccrual(_cParent: comp; _HoursFull: double; _AccrualFull: double; _FieldIndex: byte);
{
  var OldTreeParentRow: comp;
  var _Hours: double;
  var Distributed: double;
  var _d: double;

  OldTreeParentRow := TreeParentRow;
  pushpos(#MWRow);
  TreeParentRow := _cParent;
  Distributed := 0;
  _loop MWRow
  {
    if MWRow.IsLeaf
    {
      MWVal.ActiveGroupIndex := 3;
      _Hours := double(MWVal.GetShowedFieldValue(1, MWRow));
      _d := _Hours / _HoursFull * _AccrualFull;
      if (_d > trunc(_d,2)) _d := trunc(_d,2) + 0.01;
      Distributed += _d;
      if (Distributed > _AccrualFull)
      {
        _d += _AccrualFull - Distributed;
        Distributed := _AccrualFull;
      }
      MWVal.SetShowedFieldValue(_FieldIndex, MWRow, _d);
    }
    else
      DistributeObjAccrual(MWRow.nRec, _HoursFull, _AccrualFull, _FieldIndex);
  }
  TreeParentRow := OldTreeParentRow;
  poppos(#MWRow);
}

procedure DistributeObjAccruals(_cParent: comp; _cPerson: comp);
{
  var OldTreeParentRow: comp;
  var RowNRec: comp;
  var HoursFull: double;
  var i, _cnt: byte;

  OldTreeParentRow := TreeParentRow;
  pushpos(#MWRow);
  TreeParentRow := _cParent;
  _loop MWRow
  {
    if (MWRow.IsPersonLevel)  and (MWRow.cPerson = _cPerson or _cPerson = 0)
    {
      MWVal.ActiveGroupIndex := 3;
      RowNRec := MWRow.nRec;
      HoursFull := MWVal.GetShowedFieldDistribute(1, MWRow);
      if HoursFull > 0
      {
        _cnt := MWVal.NumberOfFieldsInActiveGroup;
        for (i := 2; i <= _cnt; i += 1)
        {
          DistributeObjAccrual(MWRow.nRec, HoursFull, MWVal.GetShowedFieldDistribute(i, MWRow), i);
        }
      }
    }
    else
    {
      DistributeObjAccruals(MWRow.nRec, _cPerson);
    }
  }
  TreeParentRow := OldTreeParentRow;
  poppos(#MWRow);
}

procedure DistributeAccruals(_cParent: comp; _cPerson: comp; _GroupIndex: byte);
{
  var OldTreeParentRow: comp;
  var RowNRec: comp;
  var HoursFull: double;
  var i, _cnt: byte;

  OldTreeParentRow := TreeParentRow;
  pushpos(#MWRow);
  TreeParentRow := _cParent;
  _loop MWRow
  {
    if (MWRow.IsPersonLevel)  and (MWRow.cPerson = _cPerson or _cPerson = 0)
    {
      RowNRec := MWRow.nRec;
      MWVal.ActiveGroupIndex := 2;
      HoursFull := MWVal.GetShowedFieldDistribute(1, MWRow);
      if HoursFull > 0
      {
        MWVal.ActiveGroupIndex := _GroupIndex;
        _cnt := MWVal.NumberOfFieldsInActiveGroup;
        for (i := 1; i <= _cnt; i += 1)
        {
          DistributeAccrual(MWRow.nRec, HoursFull, MWVal.GetShowedFieldDistribute(i, MWRow), _GroupIndex, i);
        }
      }
    }
    else
    {
      DistributeAccruals(MWRow.nRec, _cPerson, _GroupIndex);
    }
  }
  TreeParentRow := OldTreeParentRow;
  poppos(#MWRow);
}

procedure DistributeNormWorkHours(_cParent: comp; _cPerson: comp);
{
  var OldTreeParentRow: comp;
  var HoursFact, HoursPlan: double;
  var i, _cnt: byte;

  OldTreeParentRow := TreeParentRow;
  pushpos(#MWRow);
  TreeParentRow := _cParent;
  _loop MWRow
  {
    if (MWRow.IsPersonLevel)  and (MWRow.cPerson = _cPerson or _cPerson = 0)
    {
      DistributeNormWorkHours(MWRow.nRec, _cPerson);
    }
    else if (MWRow.IsLeaf)
    {
      MWVal.ActiveGroupIndex := 2;
      HoursFact := MWVal.GetShowedFieldValue(1, MWRow);
      MWVal.ActiveGroupIndex := 1;
      HoursPlan := MWVal.GetShowedFieldValue(1, MWRow);
      if HoursFact > 0  and HoursPlan > 0
      {
        MWVal.SetShowedFieldValue(2, MWRow, round(HoursFact / HoursPlan * 100,3));
      }
    }
  }
  TreeParentRow := OldTreeParentRow;
  poppos(#MWRow);
}

procedure DistributeAll(_GroupIndex: byte);
{
  var OldGroupIndex: byte;
  OldGroupIndex := MWVal.ActiveGroupIndex;
  pushpos(#MWRow);
  if (_GroupIndex = 3)
    DistributeObjAccruals(0, 0)
  else
    DistributeAccruals(0, 0, _GroupIndex);
  poppos(#MWRow);
  MWVal.ActiveGroupIndex := OldGroupIndex;
  rereadrecord;
}

procedure DistributePerson(_GroupIndex: byte);
{
  var OldGroupIndex: byte;
  OldGroupIndex := MWVal.ActiveGroupIndex;
  if (MWRow.cPerson = 0)
  {
    message('Не определен сотрудник, по которому необходимо выполнить распределение');
    MWVal.ActiveGroupIndex := OldGroupIndex;
    exit;
  }
  pushpos(#MWRow);
  if (_GroupIndex = 3)
    DistributeObjAccruals(0, MWRow.cPerson)
  else
    DistributeAccruals(0, MWRow.cPerson, _GroupIndex);
  poppos(#MWRow);
  MWVal.ActiveGroupIndex := OldGroupIndex;
  rereadrecord;
}

procedure SortRows;
{
  delete all tSort;
  TreePushPos(trMain);
  TreeGetFirst(trMain);
  do
  {
    clearbuffer(#tSort);
    tSort.name[1] := MWRow.GetField(1);
    tSort.name[2] := MWRow.GetField(2);
    tSort.name[3] := MWRow.GetField(3);
    tSort.name[4] := MWRow.GetField(4);
    tSort.name[5] := MWRow.GetField(5);
    tSort.name[6] := MWRow.GetField(6);
    tSort.cRow    := MWRow.nRec;
    insert current tSort;
  } while TreeGetNext(trMain);
  var i: word;
  i := 0;
  _loop tSort
  {
    MWRow.SetSort(tSort.cRow, i);
    i++;
  }
  TreePopPos(trMain);
  rereadrecord;
}

function EnableEdit: boolean;
{
  result := false;
  if (pr_CurUserAdmin)
    result := true
  else
    if getfirst MnPlan = tsOk
      result := ((UserDesgr = MnPlan.Desgr) or EnableEditDocWithAnotherDescr) and
                if (MnPlan.cStatus = 00010000000000E1h, EnableEditOforml,
                if (MnPlan.cStatus = 00010000000000E4h, EnableEditProv,
                if (MnPlan.cStatus = 00010000000000E2h, EnableEditUtv, false)));
}

tableevent table MWRow;
  cmHotkeys:
  {
    var m: longint;
    if (EnableEdit)
      m := LoadMenu('mnuAGAT_MNF_DISTRIBUTE');
    else
      m := CreateMenu;
    ConcatMenu(m, LoadMenu('mnuAGAT_MNF_UTILS'));
    PutHotCommand(RunLoadMenu(m));
  }
  cmDistributeZAll: DistributeAll(3);
  cmDistributeZByPerson: DistributePerson(3)
  cmDistributePAll: DistributeAll(4);
  cmDistributePByPerson: DistributePerson(4)
  cmDistributeDAll: DistributeAll(5);
  cmDistributeDByPerson: DistributePerson(5)

  cmShowDopInfoWindow:
  {
    RefreshDopInfo;
    runwindow(wDopInfo);
  }
  cmDistributeCByPerson:
  {
    var OldGroupIndex: byte;
    OldGroupIndex := MWVal.ActiveGroupIndex;
    MWVal.ActiveGroupIndex := 2;
    if (MWRow.cPerson = 0)
    {
      message('Не определен сотрудник, по которому необходимо выполнить распределение');
      MWVal.ActiveGroupIndex := OldGroupIndex;
      exit;
    }
    pushpos(#MWRow);
    DistributeCommonAccruals(0, MWRow.cPerson);
    poppos(#MWRow);
    MWVal.ActiveGroupIndex := OldGroupIndex;
    rereadrecord;
  }
  cmDistributeCAll:
  {
    var OldGroupIndex: byte;
    OldGroupIndex := MWVal.ActiveGroupIndex;
    MWVal.ActiveGroupIndex := 2;
    pushpos(#MWRow);
    DistributeCommonAccruals(0, 0);
    poppos(#MWRow);
    MWVal.ActiveGroupIndex := OldGroupIndex;
    rereadrecord;
  }
  cmDistributeNormHoursAll:
  {
    var OldGroupIndex: byte;
    OldGroupIndex := MWVal.ActiveGroupIndex;
    pushpos(#MWRow);
    DistributeNormWorkHours(0, 0);
    poppos(#MWRow);
    MWVal.ActiveGroupIndex := OldGroupIndex;
    rereadrecord;
  }
  cmDistributeNormHours:
  {
    var OldGroupIndex: byte;
    OldGroupIndex := MWVal.ActiveGroupIndex;
    if (MWRow.cPerson = 0)
    {
      message('Не определен сотрудник, по которому необходимо выполнить распределение');
      exit;
    }
    pushpos(#MWRow);
    DistributeNormWorkHours(0, MWRow.cPerson);
    poppos(#MWRow);
    MWVal.ActiveGroupIndex := OldGroupIndex;
    rereadrecord;
  }
  cmPick:
  {
    if (not EnableEdit) exit;
    case curfield of
      #fld1: MWRow.PickField(1);
      #fld2: MWRow.PickField(2);
      #fld3: MWRow.PickField(3);
      #fld4: MWRow.PickField(4);
      #fld5: MWRow.PickField(5);
      #fld6: MWRow.PickField(6);
    end;
    ReloadRowValues;
    rereadrecord(#MWRow);
  }
  cmInsert:
  {
    if (not EnableEdit)
    {
      Abort;
      exit;
    }
    if (isvalidall(#MWRow) and MWRow.Level < MWRow.LevelsCount)
      PutHotCommand(RunMenu('mnuAGAT_MNF_INSERT'))
    else
      PutCommand(cmInsertCurrentLevel);
    Abort;
  }
  cmUpdateRecord      :
  {
    if (not EnableEdit) exit;
    MWRow.UpdateRecord;
    ReloadRowValues;
    rereadrecord(#MWRow);
  }
  cmInsertCurrentLevel:
  {
    MWRow.InsertRecordInCurrentLevel;
    TreeJumpToRecord(trMain, MWRow.nRec);
    MWVal.LoadRowValues(MWRow);
    rereadrecord(#MWRow);
  }
  cmInsertChildLevel  :
  {
    MWRow.InsertRecordInChildLevel;
    TreeJumpToRecord(trMain, MWRow.nRec);
    MWVal.LoadRowValues(MWRow);
    rereadrecord(#MWRow);
  }
  cmDeleteRecord      :
  {
    if (not EnableEdit) exit;
    PushPos(#MWRow);
    DeleteChildRowValues(MWRow.nRec);
    PopPos(#MWRow);
    MWVal.DeleteRowValues(MWRow);
    MWRow.DeleteRecord;
  }
  cmTreeTop           : TreeParentRow := 0;
  cmTreeDown          : TreeParentRow := MWRow.NRec;
  cmTreeUp            : TreeParentRow := MWRow.cParent;
  cmTreeNodeType      : if (TreeIsTerminal(trMain)) TreeSetNodeType(trMain, ntfText);
  cmTreeNeedOwner     : TreeJumpToRecord(trMain, MWRow.cParent);

  cminit:
  {
    cfsSetProp ('wDopInfo', 'SDIWindow', true);
  }
end;

procedure RefreshValColumnsTitles;
{
  SetColumnTitle(trMain, #Val1 , MWVal.GetShowedFieldTitle(1 ));
  SetColumnTitle(trMain, #Val2 , MWVal.GetShowedFieldTitle(2 ));
  SetColumnTitle(trMain, #Val3 , MWVal.GetShowedFieldTitle(3 ));
  SetColumnTitle(trMain, #Val4 , MWVal.GetShowedFieldTitle(4 ));
  SetColumnTitle(trMain, #Val5 , MWVal.GetShowedFieldTitle(5 ));
  SetColumnTitle(trMain, #Val6 , MWVal.GetShowedFieldTitle(6 ));
  SetColumnTitle(trMain, #Val7 , MWVal.GetShowedFieldTitle(7 ));
  SetColumnTitle(trMain, #Val8 , MWVal.GetShowedFieldTitle(8 ));
  SetColumnTitle(trMain, #Val9 , MWVal.GetShowedFieldTitle(9 ));
  SetColumnTitle(trMain, #Val10, MWVal.GetShowedFieldTitle(10));
}

procedure RefreshValColumnsVisiblity;
{
  var _cnt: byte;
  _cnt := MWVal.NumberOfFieldsInActiveGroup;
  if (_cnt > MWVal.NumberOfShowedFields)
    _cnt := MWVal.NumberOfShowedFields;
  if (_cnt >= 1 ) SetFieldState(#Val1 , sfVisible) else ClearFieldState(#Val1 , sfVisible);
  if (_cnt >= 2 ) SetFieldState(#Val2 , sfVisible) else ClearFieldState(#Val2 , sfVisible);
  if (_cnt >= 3 ) SetFieldState(#Val3 , sfVisible) else ClearFieldState(#Val3 , sfVisible);
  if (_cnt >= 4 ) SetFieldState(#Val4 , sfVisible) else ClearFieldState(#Val4 , sfVisible);
  if (_cnt >= 5 ) SetFieldState(#Val5 , sfVisible) else ClearFieldState(#Val5 , sfVisible);
  if (_cnt >= 6 ) SetFieldState(#Val6 , sfVisible) else ClearFieldState(#Val6 , sfVisible);
  if (_cnt >= 7 ) SetFieldState(#Val7 , sfVisible) else ClearFieldState(#Val7 , sfVisible);
  if (_cnt >= 8 ) SetFieldState(#Val8 , sfVisible) else ClearFieldState(#Val8 , sfVisible);
  if (_cnt >= 9 ) SetFieldState(#Val9 , sfVisible) else ClearFieldState(#Val9 , sfVisible);
  if (_cnt >= 10) SetFieldState(#Val10, sfVisible) else ClearFieldState(#Val10, sfVisible);
}

function ValFieldIndex(aField: longint): byte;
{
  case aField of
    #Val1 : result := 1 ;
    #Val2 : result := 2 ;
    #Val3 : result := 3 ;
    #Val4 : result := 4 ;
    #Val5 : result := 5 ;
    #Val6 : result := 6 ;
    #Val7 : result := 7 ;
    #Val8 : result := 8 ;
    #Val9 : result := 9 ;
    #Val10: result := 10;
  else
    result := 0
  end;
}

handleevent
  cmTreeTop : TreeSetNodeTable(trDI1, #BrDIGr);
  cmTreeUp  : TreeSetNodeTable(trDI1, #BrDIGr);
  cmTreeDown: TreeSetNodeTable(trDI1, #BrDI);
  cmTreeNeedOwner:
  {
    case TreeGetNodeTable(trDI1) of
      #BrDIGr: TreeJumpToRecord(trDI1, 0);
      #BrDI  : TreeJumpToRecordEx(trDI1, #BrDIGr, BrDI.cKatStroy);
    end;
  }
  cmTreeNodeType:
  {
   case TreeGetNodeTable(trDI1) of
     #BrDIGr: TreeSetNodeType(trDI1, ntfCurrent);
     #BrDI  : TreeSetNodeType(trDI1, ntfText);
   end;
  }
  cmExprFieldChanged:
  {
    if (not EnableEdit) exit;
    case curfield of
      #fld1: MWRow.SetFieldValueString(1, ExprFieldValue);
      #fld2: MWRow.SetFieldValueString(2, ExprFieldValue);
      #fld3: MWRow.SetFieldValueString(3, ExprFieldValue);
      #fld4: MWRow.SetFieldValueString(4, ExprFieldValue);
      #fld5: MWRow.SetFieldValueString(5, ExprFieldValue);
      #fld6: MWRow.SetFieldValueString(6, ExprFieldValue);
    else
    {
      var i: byte;
      i := ValFieldIndex(curfield);
      var _v: double;
      _v := double(ExprFieldValue);
      if (i > 0)
        if MWVal.ShowedFieldValueIsCorrect(i, MWRow, _v)
        {
          MWVal.SetShowedFieldValue(i, MWRow, _v);
          rereadrecord;
        }
    }
    end;
  }
  cmChangeTabbedSheetFormat:
  {
    var NewGroupIndex: byte;
    case target of
      scGr1: NewGroupIndex := 1;
      scGr2: NewGroupIndex := 2;
      scGr3: NewGroupIndex := 3;
      scGr4: NewGroupIndex := 4;
      scGr5: NewGroupIndex := 5;
      //scGr6: NewGroupIndex := 6;
    else
      NewGroupIndex := 0;
    end;
    if NewGroupIndex > 0
    {
      MWVal.ActiveGroupIndex := NewGroupIndex;
      RefreshValColumnsVisiblity;
      RefreshValColumnsTitles;
    }
  }
  cmOpenAllGroups:
  {
    TreePushPos(trMain);
    TreeGetFirst(trMain);
    do {
      TreeOpenNode(trMain);
    } while TreeGetNext(trMain);
    TreePopPos(trMain);
    rereadrecord;
  }
  cmCloseAllGroups:
  {
    TreeCloseAllOpenedNode(trMain);
    rereadrecord;
  }
  cmSortRows:
  {
    SortRows;
    rereadrecord;
  }
end;

procedure SetCurMnPlan(_cMnPlan: comp);
{
  cCurMnPlan := _cMnPlan;
  if (GetFirst MnPlan <> tsOk)
    message('Не найден документ, nRec='+string(cCurMnPlan,0,0));
  TreeParentRow :=  0;
  MWRow.CurrentMnPlan := cCurMnPlan;
  //MWRow.LoadData;
  //MWVal.LoadData;

  EnableEditDocWithAnotherDescr := false;
  if getfirst r_users where ((UserId == r_users.cxusers)) = tsOk
  {
    EnableEditDocWithAnotherDescr := getfirst r_workplace where ((r_users.nrec == r_workplace.cusers and 0001000000000008h == r_workplace.crole)) = tsOk;
    EnableEditOforml := getfirst r_workplace where ((r_users.nrec == r_workplace.cusers and 0001000000000002h == r_workplace.crole)) = tsOk;
    EnableEditProv := getfirst r_workplace where ((r_users.nrec == r_workplace.cusers and 0001000000000003h == r_workplace.crole)) = tsOk;
    EnableEditUtv := getfirst r_workplace where ((r_users.nrec == r_workplace.cusers and 0001000000000009h == r_workplace.crole)) = tsOk;
  }
  UserDesgr := sGetTune('USER.DESGR');

  rereadrecord;
}

Procedure SetSetupFormPl(_cFormPl: comp);
{
  if getfirst FormPl where ((_cFormPl == FormPl.nRec)) = tsOk
  {
    startnewvisual(vtRotateVisual, vfTimer, 'Загрузка', 0);
    cSetupFormPl := _cFormPl;
    SetupFormPl  := TFormPl(FormPl.Buffer);
    MWRow.InitFields(SetupFormPl);
    MWRow.LoadData;
    RefreshRowColumns;
    MWVal.NumberOfShowedFields := 10;
    MWVal.InitFields(SetupFormPl, cCurMnPlan);
    LoadChildRowValues(0);
    MWVal.ActiveGroupIndex := 1;
    RefreshValColumnsTitles;
    RefreshValColumnsVisiblity;
    rereadrecord;
    SelectFormat(scGr1);
    StopVisual('',0)
  }
}

property CurrentMnPlan     : comp read cCurMnPlan   write SetCurMnPlan(result);
property CurrentSetupFormPl: comp read cSetupFormPl write SetSetupFormPl(result);
end.

mnuAGAT_MNF_INSERT Menu
{
- 'Добавить на текущий уровень', cmInsertCurrentLevel, , , , , sci1Esc;
- 'Добавить на подчиненный уровень'   , cmInsertChildLevel  , , , , , sci1Esc;
}
mnuAGAT_MNF_DISTRIBUTE Menu
{
= 'Рассчитать процент выполнения';
{
- 'по текущему сотруднику', cmDistributeNormHours, , , , , sci1Esc;
- 'по всем сотрудникам', cmDistributeNormHoursAll, , , , , sci1Esc;
}
= 'Распределить общие начисления';
{
- 'по текущему сотруднику', cmDistributeCByPerson, , , , , sci1Esc;
- 'по всем сотрудникам', cmDistributeCAll, , , , , sci1Esc;
}
= 'Распределить начисления за нахождение на объекте';
{
- 'по текущему сотруднику', cmDistributeZByPerson, , , , , sci1Esc;
- 'по всем сотрудникам', cmDistributeZAll, , , , , sci1Esc;
}
= 'Распределить премиальные начисления';
{
- 'по текущему сотруднику', cmDistributePByPerson, , , , , sci1Esc;
- 'по всем сотрудникам', cmDistributePAll, , , , , sci1Esc;
}
= 'Распределить дополнительные начисления';
{
- 'по текущему сотруднику', cmDistributeDByPerson, , , , , sci1Esc;
- 'по всем сотрудникам', cmDistributeDAll, , , , , sci1Esc;
}
}
mnuAGAT_MNF_UTILS Menu
{
- 'Дополнительная информация', cmShowDopInfoWindow, , , , , sci1Esc;
- 'Сортировка', cmSortRows, , , , , sci1Esc;
- 'Раскрыть все папки', cmOpenAllGroups, , , , , sci1Esc;
- 'Свернуть все папки', cmCloseAllGroups, , , , , sci1Esc;
}
