#include AtlProtocol.vih
#include Query.vih
#include Settlements.vih

#component "AGAT"

interface Settlements;

table struct TmpSettl (
  Nrec      : comp,
  cOborot   : comp,
  TiDkGal   : word,
  cBaseDoc  : comp,
  cKatStroy : comp,
  cPaymentKS: comp,
  wGroup    : word,
  dOper     : date,
  SchetO    : string[21],
  Shipment  : double,
  ShipSetOff: double,
  Payment   : double,
  Advance   : double,
  PostPay   : double,
  AdvSetOff : double
) with index (
  i01 = Nrec (unique, surrogate)
 ,i02 = cKatStroy + cBaseDoc + dOper + Nrec
);

var
  _mKatStroy: TPtr;
  _cKatStroy: comp;
  _dDate    : date;
  _cBaseDoc : comp;
create view
as select
  TmpSettl.Nrec
from
  TmpSettl
 ,TmpSettl TmpSettlKS
 ,TmpSettl TmpSettlBD
 ,TmpSettl TmpSettlBDPrev
 ,TmpSettl TmpSettlBDOther
 ,TmpSettl TmpSettlBDShip
where ((
      _cKatStroy == TmpSettlKS.cKatStroy

  and _cKatStroy == TmpSettlBD.cKatStroy
  and _cBaseDoc  == TmpSettlBD.cBaseDoc

  and _cKatStroy        == TmpSettlBDPrev.cKatStroy
  and _cBaseDoc         == TmpSettlBDPrev.cBaseDoc
  and TmpSettlBD.dOper >>= TmpSettlBDPrev.dOper
  and (TmpSettlBD.Nrec  != TmpSettlBDPrev.Nrec)

  and _cKatStroy        == TmpSettlBDOther.cKatStroy
  and _cBaseDoc         == TmpSettlBDOther.cBaseDoc
  and (TmpSettlBD.Nrec  != TmpSettlBDOther.Nrec)

  and _cKatStroy        == TmpSettlBDShip.cKatStroy
  and _cBaseDoc         == TmpSettlBDShip.cBaseDoc
  and (TmpSettlBDShip.Shipment != 0
  and  TmpSettlBDShip.Shipment - TmpSettlBDShip.ShipSetOff > 0)
))
condition TmpSettlBD_Storno = TmpSettlBD.Payment < 0
condition TmpSettlBD_Payment = TmpSettlBD.Payment > 0
condition TmpSettlBD_AktD91 = TmpSettlBD.Shipment > 0 and TmpSettlBD.SchetO = '891'
;

//------------------------------------------------------------------------------
//#region Protocol
var _protocol: IAtlProtocol(AtlProtocol) new;

function isProtocol: boolean;
{
  result := _protocol != NullRef;
}

function myLogLine(aType: byte; aStr: string): longint;
{
  result := if(isProtocol, _protocol.LogLine(aType, aStr), 0);
}

function myLogErrLine(aStr: string): longint;
{
  result := myLogLine(APE_ERROR, aStr);
}

function myLogMsgLine(aStr: string): longint;
{
  result := myLogLine(APE_MESSAGE, aStr);
}
//#endregion Protocol
//------------------------------------------------------------------------------

function MarkerToSqlTmpTable(m: TPtr; sTable: string; sField: string): boolean;
{
  result := false;
  var q: IQuery = queryManager.createQuery('insert into ' + sTable + ' (' + sField + ') values (:cRec)');
  var i: longint = 0;
  var c: comp = 0;
  for(i := 0; GetMarker(m, i, c); i++)
  {
    q.setParam('cRec', c).execute;
    if q.errorCode != tsOk
    {
      myLogErrLine('Settlements.MarkerToSqlTmpTable -> q.errorCode = ' + q.errorCode);
      exit;
    }
  }
  result := true;
}

//Проходит в цикле по записям TmpSettl, сторнирующих платежи, ограниченных текущим заказом и ДО
//Закрывает их на сумму предыдущих и последующих обычных платежей
procedure CompensateTmpSettlStorno;
{
  //Идем в цикле по записям TmpSettl, ограниченных текущим заказом и ДО, с суммой платежа < 0
  PushConditionForLeave(tcTmpSettlBD_Storno, #TmpSettlBD);
  _loop TmpSettlBD
  {
    //Закрываем сторнирующую сумму на суммы предыдущих и последующих обычных платежей
    _loop TmpSettlBDOther
    {
      if TmpSettlBDOther.Payment = 0 continue;
      if abs(TmpSettlBD.Payment) > TmpSettlBDOther.Payment
      {
        TmpSettlBD.Payment += TmpSettlBDOther.Payment;
        TmpSettlBDOther.Payment := 0;
        update current TmpSettlBDOther;
      }
      else
      {
        TmpSettlBDOther.Payment += TmpSettlBD.Payment;
        update current TmpSettlBDOther;
        TmpSettlBD.Payment := 0;
        break;
      }
    }
    update current TmpSettlBD;
  }
  PopConditionForLeave(tcTmpSettlBD_Storno, #TmpSettlBD);
}

//Проходит в цикле по записям TmpSettl, являющимися поставками по Д91.
//Уменьшает суммы предыдущих и последующих платежей на сумму поставки.
//Поставку удаляет.
//Т.к. поставки по 91 счету и их оплаты не должны отражаться во взаиморасчетах
procedure CompensateTmpSettlAktD91;
{
  PushConditionForLeave(tcTmpSettlBD_AktD91, #TmpSettlBD);
  while getfirst TmpSettlBD = tsOk
  {
    _loop TmpSettlBDOther
    {
      if TmpSettlBDOther.Payment = 0 continue;
      if TmpSettlBD.Shipment > TmpSettlBDOther.Payment
      {
        TmpSettlBD.Shipment -= TmpSettlBDOther.Payment;
        TmpSettlBDOther.Payment := 0;
        update current TmpSettlBDOther;
      }
      else
      {
        TmpSettlBDOther.Payment -= TmpSettlBD.Shipment;
        update current TmpSettlBDOther;
        TmpSettlBD.Shipment := 0;
        break;
      }
    }
    delete current TmpSettlBD;
  }
  PopConditionForLeave(tcTmpSettlBD_AktD91, #TmpSettlBD);
}

procedure CalcTmpSettlForKatStroy(ccKatStroy: comp);
{
  //Устанавливаем во вьюхе текущий заказ
  _cKatStroy := ccKatStroy;
  //Устанавливаем во вьюхе текущее ДО - заведомо несуществующее
  _cBaseDoc  := comp(-1);

  //Идем в цикле по записям TmpSettl, ограниченных текущим заказом
  _loop TmpSettlKS
  {
    //Если текущая запись TmpSettlKS с тем же ДО, что и текущее ДО - пропускаем запись
    if _cBaseDoc = TmpSettlKS.cBaseDoc continue;

    //Если наткнулись на новое ДО - делаем его текущим
    _cBaseDoc := TmpSettlKS.cBaseDoc;

    //Избавляемся от сторнирующих платежей по ДО - закрываем их на предыдущие и последующие обычные платежи
    CompensateTmpSettlStorno;

    //Избавляемся от поставок на Д91 счета и платежей по ним
    CompensateTmpSettlAktD91;

    //Идем в цикле по платежным записям TmpSettl, ограниченных текущим заказом и ДО
    //Зачитываем сумму платежа по отгрузкам
    PushConditionForLeave(tcTmpSettlBD_Payment, #TmpSettlBD);
    _loop TmpSettlBD
    {
      //Сумма платежа для зачета на отгрузки
      var dSumPay: double = TmpSettlBD.Payment;
      //Зачитываем сумму платежа на отгрузки. По дате зачитываемой отгрузки определяем сумму аванса/постоплаты
      //Цикл по не до конца оплаченным отгрузкам
      _loop TmpSettlBDShip
      {
        //Остаток суммы к зачету по текущей отгрузке
        var dShipSetOffSald: double = TmpSettlBDShip.Shipment - TmpSettlBDShip.ShipSetOff;
        //Зачитываемая сумма текущего платежа по текущей поставке
        var dPaySetOff: double = if(dSumPay > dShipSetOffSald, dShipSetOffSald, dSumPay);
        //Записываем зачитываемую сумму платежа в запись поставки - в зачтенную сумму поставки
        TmpSettlBDShip.ShipSetOff += dPaySetOff;
        update current TmpSettlBDShip;
        //Если дата отгрузки, на которую произошел зачет текущего платежа <= дате платежа,
        //или если зачет платежа происходит на ПКО
        //или если платежом является авансовый отчет,
        //то записываем зачтенную сумму в постоплату платежной записи, иначе - в зачет аванса
        if (   TmpSettlBDShip.dOper  <= TmpSettlBD.dOper
            or TmpSettlBDShip.TiDkGal = cgDoc_0007 //ПКО
            or TmpSettlBD.TiDkGal     = cgDoc_0009) //АО
        {
          TmpSettlBD.PostPay += dPaySetOff;
        }
        else
        {
          TmpSettlBD.AdvSetOff += dPaySetOff;
        }
        //Уменьшаем сумму оставшегося для зачета платежа
        dSumPay -= dPaySetOff;
        //Если зачли всю сумму - прерываем цикл по отгрузкам
        if dSumPay = 0 break;
      }
      TmpSettlBD.Advance := TmpSettlBD.Payment - TmpSettlBD.PostPay;
      update current TmpSettlBD;
    }
    PopConditionForLeave(tcTmpSettlBD_Payment, #TmpSettlBD);

  } //_loop TmpSettlKS
}

sql query qData =
select
  t.cBasedoc
 ,t.cOborot
 ,t.TiDkGal
 ,o.SchetO
 ,t.cKatStroy
 ,t.cPaymentKS
 ,t.dOper
 ,t.Payment
 ,t.Shipment
 ,case
    when t.Shipment > 0 then 1
    when o.SchetK = '851' and t.cPaymentKS in (select TmpKatStroy.Nrec from TmpKatStroy) then 1
    when o.SchetK = '851' and t.cPaymentKS not in (select TmpKatStroy.Nrec from TmpKatStroy
                                                   union all
                                                   select ksEtc.Nrec
                                                   from KatStroy ksEtc
                                                   left join AttrVal avIGKEtc on avIGKEtc.wTable = 2101 and avIGKEtc.cRec = ksEtc.Nrec and avIGKEtc.cAttrNam = #comp(00010000000004CCh)
                                                   where coalesce(avIGKEtc.vComp,#comp(0)) = #comp(0)
                                                   union all
                                                   select #comp(0)
                                                  ) then 2
    else 3
  end as wGroup
from (
  select
    bd.Nrec    as cBaseDoc,
    o.Nrec     as cOborot,
    o.TiDkGal  as TiDkGal,
    o.DatOb    as dOper,
    o.SumOb    as Payment,
    0          as Shipment: double,
    o.KauOs[4] as cKatStroy,
    case when o.SchetK = '851' and o.TblKs[4] = 40 then o.KauKs[4] else #comp(0) end as cPaymentKS: comp
  from Oborot o
  left join BaseDoc bd1 on bd1.Nrec = o.KauOs[3]
  left join SoprHoz sh on sh.Nrec = o.cSoprHoz
  left join StepDoc sd on sd.Nrec = sh.cStepDoc
  left join BaseDoc bd2 on bd2.Nrec = sd.cBaseDoc
  left join BaseDoc bd on bd.Nrec = coalesce(bd1.Nrec, bd2.Nrec)
  where
      o.SchetO = '860'
  and o.DatOb between 1 and :dEnd
  and o.KauOs[4] in (select TmpKatStroy.Nrec from TmpKatStroy)

  union all

  select bd.Nrec, o.Nrec, o.TiDkGal, o.DatOb,
         case when o.TiDkGal = 2 then -o.SumOb else 0 end, //возврат платежа от поставщика
         case when o.TiDkGal = 2 then 0 else o.SumOb end,
         o.KauKs[4], #comp(0)
  from Oborot o
  left join BaseDoc bd1 on bd1.Nrec = o.KauKs[3]
  left join SoprHoz sh on sh.Nrec = o.cSoprHoz
  left join StepDoc sd on sd.Nrec = sh.cStepDoc
  left join BaseDoc bd2 on bd2.Nrec = sd.cBaseDoc
  left join BaseDoc bd on bd.Nrec = coalesce(bd1.Nrec, bd2.Nrec)
  where
      o.SchetK = '860'
  and o.DatOb between 1 and :dEnd
  and o.KauKs[4] in (select TmpKatStroy.Nrec from TmpKatStroy)

  union all

  select
    bd.Nrec, o.Nrec, o.TiDkGal, o.DatOb, o.SumOb, 0, o.KauOs[3],
    case when o.SchetK = '851' and o.TblKs[4] = 40 then o.KauKs[4] else #comp(0) end
  from Oborot o
  left join SoprHoz sh on sh.Nrec = o.cSoprHoz
  left join StepDoc sd on sd.Nrec = sh.cStepDoc
  left join BaseDoc bd1 on bd1.Nrec = sd.cBaseDoc
  left join BaseDoc bd2 on bd2.Nrec = o.KauOs[5] and o.TblOs[5] = 6
  left join BaseDoc bd on bd.Nrec = coalescen(bd2.Nrec, bd1.Nrec, #comp(0))
  where
      o.SchetO = '876'
  and o.SubOsSch in ('19', '23', '2301')
  and o.SchetK <> '876'
  and o.DatOb between 1 and :dEnd
  and o.KauOs[3] in (select TmpKatStroy.Nrec from TmpKatStroy)

  union all

  select bd.Nrec, o.Nrec, o.TiDkGal, o.DatOb,
         case when o.TiDkGal = 2 then -o.SumOb else 0 end, //возврат платежа от поставщика
         case when o.TiDkGal = 2 then 0 else o.SumOb end,
         o.KauKs[3], #comp(0)
  from Oborot o
  left join SoprHoz sh on sh.Nrec = o.cSoprHoz
  left join StepDoc sd on sd.Nrec = sh.cStepDoc
  left join BaseDoc bd1 on bd1.Nrec = sd.cBaseDoc
  left join BaseDoc bd2 on bd2.Nrec = o.KauKs[5] and o.TblKs[5] = 6
  left join BaseDoc bd on bd.Nrec = coalescen(bd2.Nrec, bd1.Nrec, #comp(0))
  where
      o.SchetK = '876'
  and o.SubSchK in ('19', '23', '2301')
  and o.SchetO <> '876'
  and o.DatOb between 1 and :dEnd
  and o.KauKs[3] in (select TmpKatStroy.Nrec from TmpKatStroy)
) t
join Oborot o
  on o.Nrec = t.cOborot
order by t.cBaseDoc, t.cKatStroy, t.dOper, t.Payment
;

function prepareData: boolean;
{
  result := true ;

  //Создаем sql-таблицу TmpKatStroy с нреками заказов по которым будем считать взаиморасчеты
  var rslt: integer = sqlCreateTmpTable('table TmpKatStroy (Nrec: comp) with index (i01 = Nrec);', ctmNormal);
  if rslt != 0
  {
    myLogErrLine('Settlements.prepareData -> sqlCreateTmpTable error: ' + rslt);
    result := false;
    exit;
  }

  do {
    //Заполняем TmpKatStroy нреками заказов из маркера _mKatStroy;
    if not MarkerToSqlTmpTable(_mKatStroy, 'TmpKatStroy', 'Nrec') break;

    //Готовим запрос для заполнения TmpSettl данными по платежам и отгрузкам
    var q: IQuery = queryManager.createQuery(qData);
    q.setParam('dEnd', _dDate);
    if q.execute.errorCode != tsOk
    {
      myLogErrLine('Settlements.prepareData -> q.execute error: ' + q.errorCode);
      result := false;
      break;
    }

    //Очищаем TmpSettl перед заполнением
    MtClear(#TmpSettl, mfNormal);

    //Заполняем TmpSettl данными по платежам и отгрузкам
    rslt := sqlCopyInto(q, #TmpSettl, true);
    if rslt != tsOk
    {
      myLogErrLine('Settlements.prepareData -> sqlCopyInto error: ' + rslt);
      result := false;
      break;
    }

    //Для каждого заказа из маркера _mKatStroy рассчитаем в TmpSettl поля аванс,
    //зачет аванса, постоплата, схлопнем сторнирующие записи
    var c: comp = 0;
    var i: longint = 0;
    for(i := 0; GetMarker(_mKatStroy, i, c); i++)
      CalcTmpSettlForKatStroy(c);

  } while false;

  sqlDropTmpTable('TmpKatStroy');
}

function refresh: boolean;
{
  result := prepareData;
}

constructor Create(mKatStroy: TPtr; dDate: date; aProtocol: IAtlProtocol = NullRef);
{
  if aProtocol != NullRef
    _protocol := aProtocol;
  _mKatStroy := mKatStroy;
  _dDate := dDate;
  result := _mKatStroy != 0;
  if result result := prepareData;
}

property Nrec      : comp   absolute TmpSettl.Nrec     ;
property cOborot   : comp   absolute TmpSettl.cOborot  ;
property TiDkGal   : word   absolute TmpSettl.TiDkGal  ;
property cBaseDoc  : comp   absolute TmpSettl.cBaseDoc ;
property cKatStroy : comp   absolute TmpSettl.cKatStroy;
property cPaymentKS: comp   absolute TmpSettl.cPaymentKS;
property wGroup    : word   absolute TmpSettl.wGroup   ;
property dOper     : date   absolute TmpSettl.dOper    ;
property Shipment  : double absolute TmpSettl.Shipment ;
property ShipSetOff: double absolute TmpSettl.ShipSetOff;
property Payment   : double absolute TmpSettl.Payment  ;
property Advance   : double absolute TmpSettl.Advance  ;
property PostPay   : double absolute TmpSettl.PostPay  ;
property AdvSetOff : double absolute TmpSettl.AdvSetOff;

property mKatStroy : TPtr   absolute _mKatStroy;
property dDate     : date   absolute _dDate;
property Protocol  : IAtlProtocol absolute _protocol;

index indByNrec auto;
index indByBasedoc auto;

end.
