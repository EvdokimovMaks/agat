#include WorkPeriods.vih
#include CalcAndCreateCompens.vih
#include Query.vih
#include VacationSaldo.vih
//#include StaffStruct.vih
//#include AppFuncs.vih
#include FactVacation.vih

#component "UTILS"

interface iVacationSaldo;

/*
//Убираю ручной расчет. Галактисты предоставили стандартный функционал.
//
sql query qSaldo =
select wp.dperbeg,
       wp.dperend,
       pv.wtypevac,
       sum(pv.wdaycount) as wdaycount,
       sum(coalesce(v.duration,0)) as duration
from persons p
join workperiod wp on p.nrec = wp.cperson and wp.dperbeg <= :SaldoDate
join putvacation pv on wp.nrec = (case when pv.cwpremain = #comp(0) then pv.cworkperiod else pv.cwpremain end)
left join (select cputvac, sum(duration) as duration
           from vacations
           where factyearbeg <= :SaldoDate
           group by cputvac
          ) v on pv.nrec = v.cputvac
where p.nrec = :PersonsNrec
group by wp.dperbeg, wp.dperend, pv.wtypevac
order by wp.dperbeg
;

sql query qVacations =
select sum(v.duration) as duration
from persons p
join workperiod wp on p.nrec = wp.cperson
join putvacation pv on wp.nrec = (case when pv.cwpremain = #comp(0) then pv.cworkperiod else pv.cwpremain end)
join vacations v on pv.nrec = v.cputvac and v.factyearbeg between :dbeg and :dend
where p.nrec = :PersonsNrec;

create view
var
  _personsNrec: comp;
as select *
from persons, lschet, factotpusk, appointments
where ((
  _personsNrec == persons.nrec and
  _personsNrec == factotpusk.person and
  2            == factotpusk.vactype
));

var
  _qGetPersVacKolDn: IQuery;
  _qSaldo: IQuery;
  _af: AppointmentsFunctions;
  _ss: StaffStruct;

function PeriodMonths(dBeg: date; dEnd: date): word;
{
  //один месяц прибавляем когда дата начала <= 15 ( Months_Between(01.01.2015, 31.12.2015) = 11 а не 12 )
  //один месяц вычитаем, когда дата окончания <= 15
  result := Months_Between(dBeg, dEnd) + if(day(dBeg) <= 15, 1, 0) + if(day(dEnd) <= 15, -1, 0); // + if( last_day(dEnd) = day(dEnd), 1, 0)
}

function GetDekretMonths(dBeg: date; dEnd: date): word;
{
  var d1, d2: date;
  var cnt: word; cnt := 0;
  _loop factotpusk
  {
    if (factotpusk.factyearbeg <= dEnd and factotpusk.factyearend >= dBeg)   //если декретный отпуск пересекается с периодом
    {                                                                       //считаем кол-во месяцев декрета, попадающих в период
      d1 := if(dBeg > factotpusk.factyearbeg, dBeg, factotpusk.factyearbeg);
      d2 := if(dEnd < factotpusk.factyearend, dEnd, factotpusk.factyearend);
      cnt += PeriodMonths(d1,d2);
    }
  }
  result := cnt;
}


sql query qGetPersVacKolDn =
  select sum(persvacation.wcountday) wcountday
  from persvacation
  where persvacation.cpersons = :personsNrec and
        persvacation.typeotp = 1 and
        (persvacation.dbegexist = 0 or persvacation.dbegexist <= :date ) and
        (persvacation.dendexist = 0 or persvacation.dendexist >= :date )
;

function GetDaysPerMonthByPerson(aPersonsNrec: comp; aDate: date): double;
{

  var appNrec: comp;
  appNrec := _af.GetAppNrec_OnDate(aPersonsNrec, aDate);

  var staffstrVacKolDn: double;

  if getfirst appointments where ((appNrec == appointments.nrec)) = tsOk
    staffstrVacKolDn := _ss.GetVacKolDn(appointments.staffstr, aDate);
  else
    staffstrVacKolDn := 0;

  if staffstrVacKolDn = 0
    staffstrVacKolDn := 28;

  var persVacKolDn: double;

  if _qGetPersVacKolDn = nullref
    _qGetPersVacKolDn := queryManager.createQuery(qGetPersVacKolDn);

  persVacKolDn := _qGetPersVacKolDn.setParam('personsNrec', aPersonsNrec)
                                   .setParam('date', aDate)
                                   .getResultValue;

  result := (staffstrVacKolDn + persVacKolDn) / 12;

}

function GetByPersonOnDate(aPersonsNrec: comp; aDate: date): double;
{
  result := 0;

  _personsNrec := aPersonsNrec;
  if getfirst fastfirstrow persons  != tsOk
  {
    message('iVacationSaldo: Сотрудник не найден. Nrec = ' + aPersonsNrec, error);
    exit;
  }

  if persons.disdate != 0 and (year(persons.disdate) * 12 + month(persons.disdate)) < (year(aDate) * 12 + month(aDate)) then
    exit;

  if _qSaldo = nullref
    _qSaldo := queryManager.CreateQuery(qSaldo);

  var rs: IResultSet;
  rs := nullref;
  rs := _qSaldo.setParam('SaldoDate', aDate)
               .setParam('PersonsNrec', aPersonsNrec)
               .getResultSet;

  if (rs = nullRef)
  {
    message('iVacationSaldo: Ошибка выполнения запроса расчета сальдо: ' + _qSaldo.errorCode +
            ''#13'Сотрудник: ' + if(getanykau(1,3,aPersonsNrec),givenanname(1),aPersonsNrec) + ', Дата:' + aDate, error);
    exit;
  }

  var cnt: double; cnt := 0;
  var typeVac: word;              //тип полагающегося отпуска: 0 - отпуск, 1 - остаток
  var dayCount: double;           //количество дней полагающегося отпуска

  if (rs.getFirst = tsOk)
    do
    {

      //тип полагающегося отпуска
      typeVac := rs.row.val('wtypevac');

      //количество дней полагающегося отпуска
      dayCount := rs.row.val('wdaycount');

      //если тип полагающегося отпуска = "остаток"
      if (typeVac = 1)
      {
        //добавляем к расчетному сальдо полагающееся количество полностью
        cnt += dayCount;
      }
      else //если тип полагающегося отпуска = "отпуск"
      {
        //рабочий период - дата начала
        var wpDbeg: date;
        wpDbeg := rs.row.val('dperbeg');

        //рабочий период - дата окончания
        var wpDend: date;
        wpDend := rs.row.val('dperend');

        //количество полагающихся дней отпуска на месяц рабочего периода
        var daysPerMonth: double;
        daysPerMonth := 0;

        if wpDend = persons.disdate
        {
          //Если период - период увольнения сотрудника, то вычисляем колво дней на месяц из ШР и привязки отпусков сотрудника
          //по дням периода отпуска определять нельзя, т.к. сам период короткий, а кол-во полагающихся дней
          //отпуска - на весь год.
          daysPerMonth := GetDaysPerMonthByPerson(persons.nrec, wpDend);
        }
        else
        {
          //если период - не период увольнения сотрудника и не длиннее 366 дней, то вычисляем колво дней на месяц
          //по кол-ву полагающихся отпусков в периоде на кол-во месяцев в периоде
          var monthsInCurrentPeriod: double;
          monthsInCurrentPeriod := PeriodMonths(wpDbeg, wpDend);

          var dekretMonthsInCurrentPeriod: double;
          dekretMonthsInCurrentPeriod := GetDekretMonths(wpDbeg, wpDend);

          if monthsInCurrentPeriod > dekretMonthsInCurrentPeriod
            daysPerMonth := dayCount / (monthsInCurrentPeriod - dekretMonthsInCurrentPeriod);

          if daysPerMonth = 0
            daysPerMonth := GetDaysPerMonthByPerson(persons.nrec, wpDend);

        }

        //даты начала и окончания расчетного периода
        var d1, d2: date;
        //дата начала расчетного периода равна дате начала рабочего периода
        d1 := wpDbeg;
        //дата окончания расчетного периода равна дате окончания расчетного периода или дате расчета сальдо,
        //если дата окончания расчетного периода больше даты расчета сальдо
        d2 := if(wpDend <= aDate, wpDend, aDate);

        //количество месяцев в расчетном периоде
        var monthsCount: word;
        monthsCount := PeriodMonths(d1, d2);

        //количество декретных месяцев в расчетном периоде
        var dekretMonths: word;
        dekretMonths := GetDekretMonths(d1, d2);

        //добавляем к расчетному сальдо количество дней за недекретные месяцы
        cnt += (monthsCount - dekretMonths) * daysPerMonth;
      }

      cnt -= double(rs.row.val('duration'));

    } while (rs.getNext = tsOk);

  rs := nullref;

  result := cnt;

}
*/

sql query qSaldo =
select pv.nrec
from persons p
join workperiod wp on p.nrec = wp.cperson and wp.dperbeg <= :SaldoDate
join putvacation pv on wp.nrec = (case when pv.cwpremain = #comp(0) then pv.cworkperiod else pv.cwpremain end)
where p.nrec = :PersonsNrec
;

sql query qVacations =
select sum(v.duration) as duration
from persons p
join workperiod wp on p.nrec = wp.cperson
join putvacation pv on wp.nrec = (case when pv.cwpremain = #comp(0) then pv.cworkperiod else pv.cwpremain end)
join vacations v on pv.nrec = v.cputvac and v.factyearbeg between :dbeg and :dend
where p.nrec = :PersonsNrec;

sql query qFactOtpusk =
select sum(fo.duration)
from klotpusk
join factotpusk fo on fo.person      = :PersonsNrec and
                      fo.vactype     = klotpusk.kotpus and
                      fo.year_vac    = :Year and
                      fo.factyearbeg between :dbeg and :dend
where klotpusk.typeotp in (0, 1, 3) //основной, дополнительный, компенсация
;

var
  _qVacDaysBetweenDates: IQuery = nullref;
  _qFactOtpDaysBetweenDates: IQuery = nullref;
  _factVacation: iFactVacation;
  _calcAndCreateCompens: CalcAndCreateCompens;

create view
var
  _personsNrec: comp;
  _date: date;
as select *
from workperiod wp, putvacation pv, lschet
where ((
  _personsNrec      == wp.cPerson      and
  cnWP_Work         == wp.wTypePeriod  and
  (_date            >= wp.dPerBeg      and
   _date            <= wp.dPerEnd )    and

  wp.nrec           == pv.cWorkPeriod
));

function GetByPersonOnDate(aPersonsNrec: comp; aDate: date): double;
{

//  if _qGetFactVacationKolDn = nullref
//    _qGetFactVacationKolDn := queryManager.createQuery(qSaldo);
//
//  var rs: IResultSet;
//  rs := _qGetFactVacationKolDn.setParam('PersonsNrec', aPersonsNrec).setParam('SaldoDate', aDate).getResultSet;
//
//  var cnt: double;
//  cnt := 0;
//
//  if rs.getFirst = tsOk do
//  {
//    cnt += _factVacation.funGetBalanceVac(comp(rs.row.valat(1)), 0, aDate);
//  } while rs.getNext = tsOk;
//
//  result := cnt;
  result := 0;

  _personsNrec := aPersonsNrec;
  _date := aDate;

  if getfirst wp = tsOk
    if getfirst pv = tsOk
    {
      var doProportion: double;
      doProportion := _calcAndCreateCompens.CaclVacProportion(wp.NRec, aDate);
      //message(wp.dPerBeg + ' - ' + wp.dPerEnd + ' ' + doProportion);
      var liVacMarker: TPtr;
      liVacMarker := InitMarker('',8,200,10);
      _loop pv
      {
        result += _calcAndCreateCompens.CalcCountDaysLikeCompensWithFactDate(pv.NRec, aDate, aDate, doProportion, liVacMarker, 0);
      }
      DoneMarker(liVacMarker, '');
    }
}

function GetByLschetOnDate(aLschetNrec: comp; aDate: date): double;
{
  result := 0;
  if getfirst lschet where (( aLschetNrec == lschet.nrec )) = tsOk
    result := GetByPersonOnDate(lschet.tperson, aDate);
}

function GetVacationDaysBetweenDates(aPersonsNrec: comp; aStartDate: date; aEndDate: date): double;
{
  var cnt: double; cnt := 0;

  if _qVacDaysBetweenDates = nullref
    _qVacDaysBetweenDates := queryManager.CreateQuery(qVacations);

  _qVacDaysBetweenDates.setParam('dbeg', aStartDate);
  _qVacDaysBetweenDates.setParam('dend', aEndDate);
  _qVacDaysBetweenDates.setParam('PersonsNrec', aPersonsNrec);
  cnt := _qVacDaysBetweenDates.getResultValue;

  result := cnt;
}

function GetFactOtpuskDaysBetweenDates(aPersonsNrec: comp; aStartDate: date; aEndDate: date): double;
{
  if _qFactOtpDaysBetweenDates = nullref
    _qFactOtpDaysBetweenDates := queryManager.CreateQuery(qFactOtpusk);

  result := _qFactOtpDaysBetweenDates.setParam('PersonsNrec', aPersonsNrec)
                                     .setParam('dbeg', aStartDate)
                                     .setParam('dend', aEndDate)
                                     .setParam('Year', year(aStartDate))
                                     .getResultValue;
}

end.
