#include Query.vih
#include VacationSaldo.vih
#include StaffStruct.vih
#include AppFuncs.vih

#component "UTILS"

interface iVacationSaldo;

sql query qSaldo =
select wp.dperbeg,
       wp.dperend,
       pv.wtypevac,
       sum(pv.wdaycount) as wdaycount,
       sum(coalesce(v.duration,0)) as duration
from persons p
join workperiod wp on p.nrec = wp.cperson and wp.dperbeg <= :SaldoDate
join putvacation pv on wp.nrec = (case when pv.cwpremain = #comp(0) then pv.cworkperiod else pv.cwpremain end)
left join (select cputvac, sum(duration) as duration
           from vacations
           where factyearbeg <= :SaldoDate
           group by cputvac
          ) v on pv.nrec = v.cputvac
where p.nrec = :PersonsNrec
group by wp.dperbeg, wp.dperend, pv.wtypevac
order by wp.dperbeg
;

sql query qVacations =
select sum(v.duration) as duration
from persons p
join workperiod wp on p.nrec = wp.cperson
join putvacation pv on wp.nrec = (case when pv.cwpremain = #comp(0) then pv.cworkperiod else pv.cwpremain end)
join vacations v on pv.nrec = v.cputvac and v.factyearbeg between :dbeg and :dend
where p.nrec = :PersonsNrec;

create view
var
  _personsNrec: comp;
as select *
from persons, lschet, factotpusk, appointments
where ((
  _personsNrec == persons.nrec and
  _personsNrec == factotpusk.person and
  2            == factotpusk.vactype
));

var
  _qGetPersVacKolDn: IQuery;
  _qSaldo: IQuery;
  _af: AppointmentsFunctions;
  _ss: StaffStruct;

function PeriodMonths(dBeg: date; dEnd: date): word;
{
  //один месяц прибавляем когда дата начала <= 15 ( Months_Between(01.01.2015, 31.12.2015) = 11 а не 12 )
  //один месяц вычитаем, когда дата окончания <= 15
  result := Months_Between(dBeg, dEnd) + if(day(dBeg) <= 15, 1, 0) + if(day(dEnd) <= 15, -1, 0); // + if( last_day(dEnd) = day(dEnd), 1, 0)
}

function GetDekretMonths(dBeg: date; dEnd: date): word;
{
  var d1, d2: date;
  var cnt: word; cnt := 0;
  _loop factotpusk
  {
    if (factotpusk.factyearbeg <= dEnd and factotpusk.factyearend >= dBeg)   //если декретный отпуск пересекается с периодом
    {                                                                       //считаем кол-во месяцев декрета, попадающих в период
      d1 := if(dBeg > factotpusk.factyearbeg, dBeg, factotpusk.factyearbeg);
      d2 := if(dEnd < factotpusk.factyearend, dEnd, factotpusk.factyearend);
      cnt += PeriodMonths(d1,d2);
    }
  }
  result := cnt;
}


sql query qGetPersVacKolDn =
  select sum(persvacation.wcountday) wcountday
  from persvacation
  where persvacation.cpersons = :personsNrec and
        persvacation.typeotp = 1 and
        (persvacation.dbegexist = 0 or persvacation.dbegexist <= :date ) and
        (persvacation.dendexist = 0 or persvacation.dendexist >= :date )
;

function GetDaysPerMonthByPerson(aPersonsNrec: double; aDate: date): double;
{

  var appNrec: comp;
  appNrec := _af.GetAppNrec_OnDate(aPersonsNrec, aDate);

  var staffstrVacKolDn: double;

  if getfirst appointments where ((appNrec == appointments.nrec)) = tsOk
    staffstrVacKolDn := _ss.GetVacKolDn(appointments.staffstr, aDate);
  else
    staffstrVacKolDn := 0;

  var persVacKolDn: double;

  if _qGetPersVacKolDn = nullref
    _qGetPersVacKolDn := queryManager.createQuery(qGetPersVacKolDn);

  persVacKolDn := _qGetPersVacKolDn.setParam('personsNrec', aPersonsNrec)
                                   .setParam('date', aDate)
                                   .getResultValue;

  result := (staffstrVacKolDn + persVacKolDn) / 12;

}

function GetByPersonOnDate(aPersonsNrec: comp; aDate: date): double;
{
  result := 0;

  _personsNrec := aPersonsNrec;
  if getfirst fastfirstrow persons  != tsOk
  {
    message('iVacationSaldo: Сотрудник не найден. Nrec = ' + aPersonsNrec, error);
    exit;
  }

  if persons.disdate != 0 and (year(persons.disdate) * 12 + month(persons.disdate)) < (year(aDate) * 12 + month(aDate)) then
    exit;

  if _qSaldo = nullref
    _qSaldo := queryManager.CreateQuery(qSaldo);

  var rs: IResultSet;
  rs := _qSaldo.setParam('SaldoDate', aDate)
               .setParam('PersonsNrec', aPersonsNrec)
               .getResultSet;

  if (rs = nullRef)
  {
    message('iVacationSaldo: Ошибка выполнения запроса расчета сальдо: ' + _qSaldo.errorCode +
            ''#13'Сотрудник: ' + if(getanykau(1,3,aPersonsNrec),givenanname(1),aPersonsNrec) + ', Дата:' + aDate, error);
    exit;
  }

  var cnt: double; cnt := 0;
  var typeVac: word;              //тип полагающегося отпуска: 0 - отпуск, 1 - остаток
  var dayCount: double;           //количество дней полагающегося отпуска

  if (rs.getFirst = tsOk)
    do
    {

      //тип полагающегося отпуска
      typeVac := rs.row.val('wtypevac');

      //количество дней полагающегося отпуска
      dayCount := rs.row.val('wdaycount');

      //если тип полагающегося отпуска = "остаток"
      if (typeVac = 1)
      {
        //добавляем к расчетному сальдо полагающееся количество полностью
        cnt += dayCount;
      }
      else //если тип полагающегося отпуска = "отпуск"
      {
        //рабочий период - дата начала
        var wpDbeg: date;
        wpDbeg := rs.row.val('dperbeg');

        //рабочий период - дата окончания
        var wpDend: date;
        wpDend := rs.row.val('dperend');

        //количество полагающихся дней отпуска на месяц рабочего периода
        var daysPerMonth: double;
        if wpDend = persons.disdate or (aDate >= wpDbeg and aDate <= wpDend)
        {
          //Если период - период увольнения сотрудника, то вычисляем колво дней на месяц из ШР и привязки отпусков сотрудника
          //по дням периода отпуска определять нельзя, т.к. сам период короткий, а кол-во полагающихся дней
          //отпуска - на весь год.
          //Если период текущий, то алгоритм определения количества дней по
          //количеству полагающихся отпусков часто глючит. Например, в следующем месяце у сотрудника декретный отпуск,
          //в текущем месяце кадровики скорректировали рабочий период - он стал равен двум годам:
          //28 полагающихся дней / 24 месяца = 1.17, а должно быть 2.33
          daysPerMonth := GetDaysPerMonthByPerson(persons.nrec, wpDend);
        }
        else
        {
          //если период - не период увольнения сотрудника и не длиннее 366 дней, то вычисляем колво дней на месяц
          //по кол-ву полагающихся отпусков в периоде на кол-во месяцев в периоде
          daysPerMonth := dayCount / PeriodMonths(wpDbeg, wpDend);
        }

        //даты начала и окончания расчетного периода
        var d1, d2: date;
        //дата начала расчетного периода равна дате начала рабочего периода
        d1 := wpDbeg;
        //дата окончания расчетного периода равна дате окончания расчетного периода или дате расчета сальдо,
        //если дата окончания расчетного периода больше даты расчета сальдо
        d2 := if(wpDend <= aDate, wpDend, aDate);

        //количество месяцев в расчетном периоде
        var monthsCount: word;
        monthsCount := PeriodMonths(d1, d2);

        //количество декретных месяцев в расчетном периоде
        var dekretMonths: word;
        dekretMonths := GetDekretMonths(d1, d2);

        //добавляем к расчетному сальдо количество дней за недекретные месяцы
        cnt += (monthsCount - dekretMonths) * daysPerMonth;
      }

      cnt -= double(rs.row.val('duration'));

    } while (rs.getNext = tsOk)

  result := cnt;

}

function GetByLschetOnDate(aLschetNrec: comp; aDate: date): double;
{
  result := 0;
  if getfirst lschet where (( aLschetNrec == lschet.nrec )) = tsOk
    result := GetByPersonOnDate(lschet.tperson, aDate);
}

function GetVacationDaysBetweenDates(aPersonsNrec: comp; aStartDate: date; aEndDate: date): double;
{
  var cnt: double; cnt := 0;

  var q: iQuery;
  q := queryManager.CreateQuery(qVacations);
  q.setParam('dbeg', aStartDate);
  q.setParam('dend', aEndDate);
  q.setParam('PersonsNrec', aPersonsNrec);
  cnt := q.getResultValue;

  result := cnt;
}

end.
