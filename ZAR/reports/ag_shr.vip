//Отчет по штатному расписанию
#include Query.vih
#include CatFunc.vih
#include UserReport.vih
#include DeptIer.vih

#component "AGAT"

interface ag_shr 'АГАТ. Штатное расписание' escclose;
show(,,26,7);

table struct tCatDep (
  Nrec   : comp,
  cParent: comp,
  Code   : string[100],
  Name   : string
) with index (
  i00 = Nrec,
  i01 = cParent + Code
);

table struct tSS (
  cCatDep  : comp,
  cSS      : comp,
  cPost    : comp,
  cCateg   : comp,
  cPodgr   : comp,
  Qty      : double,
  Salary   : double,
  BonusVred: double,
  BonusPrem: double,
  BonusSekr: double
) with index (
  i01 = cCatDep
);

table struct tTotals (
  cCatDep: comp,
  wType  : word, //0 - по подразделению, 1 - по подразделению/подгруппе, 2 - по подразделению/подгруппе/категории
  cPodgr : comp,
  cCateg : comp,
  Qty    : double,
  Sum    : double
) with index (
  i01 = wType + cCatDep,
  i02 = wType + cCatDep + cPodgr,
  i03 = wType + cCatDep + cPodgr + cCateg
);


var
  _departIer: DepartIer;
  _catFunc: CatalogsFunctions;
  pXL: XLSRepBuilder;
  _date: date;
  _flags: comp;

create view
as select
  tCatDep.Nrec
from
  tCatDep,
  tSS,
  tTotals
;

create view vRep
var
  _cCatDep: comp;
  _cCatDepTop: comp;
as select
  tSS.cCatDep
from
  tCatDep tCatDepTop,
  tCatDep tCatDepChild,
  tCatDep tCatDep,
  tSS,
  Catalogs CatPost,
  SpKau SpkPodgr,
  SpKau SpkCateg,
  Appointments App,
  Persons,
  tTotals tTotals0,
  tTotals tTotals1,
  tTotals tTotals2
where ((
  _cCatDepTop     == tCatDepTop.cParent   and
  _cCatDep        == tCatDepChild.cParent and
  _cCatDep        == tCatDep.Nrec         and
  _cCatDep        == tSS.cCatDep          and
  tSS.cPost       == CatPost.Nrec         and
  tSS.cPodgr      == spkPodgr.Nrec        and
  tSS.cCateg      == spkCateg.Nrec        and
  tSS.cSS         == App.StaffStr         and
  (App.AppointDate <= _date and (App.DismissDate = 0 or App.DismissDate >= _date)) and
  App.Person      == Persons.Nrec         and
  0               == tTotals0.wType       and
  _cCatDep        == tTotals0.cCatDep     and
  1               == tTotals1.wType       and
  _cCatDep        == tTotals1.cCatDep     and
  2               == tTotals2.wType       and
  _cCatDep        == tTotals2.cCatDep     and
  tTotals1.cPodgr == tTotals2.cPodgr
));


create view vTotals
var
  _cCatDep: comp;
as select
  tCatDepChild.Nrec
from
  tCatDep tCatDepChild,
  tTotals tTotalsChild,
  tTotals tTotalsCur,
  tTotals tTotals2,
  tTotals tTotals1,
  tTotals tTotals0
where ((
  vTotals._cCatDep    == tCatDepChild.cParent and

  2                   == tTotalsChild.wType   and
  tCatDepChild.Nrec   == tTotalsChild.cCatDep and

  2                   == tTotalsCur.wType     and
  vTotals._cCatDep    == tTotalsCur.cCatDep   and
  tTotalsChild.cPodgr == tTotalsCur.cPodgr    and
  tTotalsChild.cCateg == tTotalsCur.cCateg    and

  2                   == tTotals2.wType       and
  vTotals._cCatDep    == tTotals2.cCatDep     and

  1                   == tTotals1.wType       and
  vTotals._cCatDep    == tTotals1.cCatDep     and
  tTotals2.cPodgr     == tTotals1.cPodgr      and

  0                   == tTotals0.wType       and
  vTotals._cCatDep    == tTotals0.cCatDep
));


screen sc1;
  fields
    _date: noprotect;
    _flags: noprotect;
  buttons
    cmOk, default;
    cmCancel;
<<

`Дата отчета`.@@@@@@@@@@

  [.] Отображать сотрудников`

<.Продолжить.> <.Отмена.>
>>
end;


//#region sql query qCatDep
sql query qCatDep =
  insert tCatDep (Nrec, cParent, Name, Code)
  select
    CatHist.cCat    as Nrec,
    CatHist.cParent as cParent,
    CatHist.Name    as Name,
    Catalogs.Code   as Code
  from
    Catalogs
    inner join (
      select CatHist.cCat, max(CatHist.Dat1) MaxDate: date
      from CatHist
      where :dateSts >= CatHist.Dat1 and (CatHist.wFld1 <> 2 or #Date(0,0,0) = CatHist.Dat2 or :dateSts <= CatHist.Dat2)
      group by CatHist.cCat
    ) CatH1 on (Catalogs.NRec = CatH1.cCat)
    inner join (
      select CatHist.cCat, CatHist.Dat1, max(cast(CatHist.lastuser as integer)) MaxNpp
      from CatHist
      where :dateSts >= CatHist.Dat1 and (CatHist.wFld1 <> 2 or #Date(0,0,0) = CatHist.Dat2 or :dateSts <= CatHist.Dat2)
      group by CatHist.cCat, CatHist.Dat1
    ) CatH2 on (Catalogs.NRec = CatH2.cCat and CatH1.MaxDate = CatH2.Dat1)
    inner join CatHist on (Catalogs.NRec = CatHist.cCat and CatH1.MaxDate = CatHist.Dat1 and CatH2.MaxNpp = cast(CatHist.lastuser as integer))
  where
    Catalogs.lPr = 0 and Catalogs.MainLink = (select NRec from Catalogs where :topEntry = SysCode) and
    case :topEntry when -11 then 1 else 0 end <> CatHist.bMulti and
    Catalogs.DatN <= :dateSts and (Catalogs.DatOk = 0 or Catalogs.DatOk >= :dateSts)
;
//#endregion sql query qCatDep

//#region sql query qSS
sql query qSS =
  Insert tSS (cCatDep, cSS, cPost, cCateg, cPodgr, Qty, Salary, BonusVred, BonusPrem, BonusSekr)
  Select
    tCatDep.Nrec                      as cCatDep,
    ss.Nrec                           as cSS,
    ss.Post                           as cPost,
    coalesce(avCateg.vComp, #comp(0)) as cCateg,
    coalesce(avPodgr.vComp, #comp(0)) as cPodgr,
    ssHist.hWorkStations              as Qty,
    ssHist.hTaxRate                   as Salary,
    coalesce(tRaise.BonusVred, 0)     as BonusVred,
    coalesce(tRaise.BonusPrem, 0)     as BonusPrem,
    coalesce(tRaise.BonusSekr, 0)     as BonusSekr
  from
    tCatDep
  join StaffStruct ss
    on ss.Department = tCatDep.Nrec and
       ss.dInput <= :dateSts and
       (ss.dClose = 0 or ss.dClose >= :dateSts )
  join (Select StaffStr, max(wFld) as wFld
        from HistoryStr
        where dHist <= :dateSts
        group by StaffStr) ssHistLast on ssHistLast.StaffStr = ss.Nrec
  join HistoryStr ssHist
    on ssHist.StaffStr = ss.Nrec and ssHist.wFld = ssHistLast.wFld and ssHist.hWorkStations > 0
  left join KlKatego
    on KlKatego.Nrec = ssHist.cSpr2
  left join AttrVal avCateg
    on avCateg.wTable = 16005 and        //coKlKatego
       avCateg.cRec = KlKatego.Nrec and
       avCateg.cAttrNam = :cAttrNamCateg //ATTRNAM_NREC_KLKATEGO_CATEG
  left join AttrVal avPodgr
    on avPodgr.wTable = 16005 and        //coKlKatego
       avPodgr.cRec = KlKatego.Nrec and
       avPodgr.cAttrNam = :cAttrNamPodgr //ATTRNAM_NREC_KLKATEGO_PODGR
  left join ( select
                Str_RHist.cStaffStr,
                sum(case when CatRaise.Name like '%вредность%'
                           then (case when Str_RHist.wHAttr = 2 then ssHist.hTaxRate * Str_RHist.RHSum / 100 else Str_RHist.RHSum end)
                         else 0
                    end) as BonusVred,
                sum(case when CatRaise.Name like 'премия'
                           then (case when Str_RHist.wHAttr = 2 then ssHist.hTaxRate * Str_RHist.RHSum / 100 else Str_RHist.RHSum end)
                         else 0
                    end) as BonusPrem,
                sum(case when CatRaise.Name like '%секретность%'
                           then (case when Str_RHist.wHAttr = 2 then ssHist.hTaxRate * Str_RHist.RHSum / 100 else Str_RHist.RHSum end)
                         else 0
                    end) as BonusSekr
              from
                Str_RHist
              join RaiseStS
                on RaiseStS.Nrec = Str_RHist.cRaiseStS
              join Catalogs CatRaise
                on CatRaise.Nrec = RaiseStS.RaiseType
              join (Select StaffStr, max(wFld) as wFld
                    from HistoryStr
                    where dHist <= :dateSts
                    group by StaffStr) ssHistLast on ssHistLast.StaffStr = Str_RHist.cStaffStr
              join HistoryStr ssHist
                on ssHist.StaffStr = Str_RHist.cStaffStr and ssHist.wFld = ssHistLast.wFld
              where
                Str_RHist.dRec <= :dateSts and (Str_RHist.dEnd = 0 or Str_RHist.dEnd >= :dateSts)
              group by Str_RHist.cStaffStr
            ) tRaise
    on tRaise.cStaffStr = ss.Nrec
;
//#endregion sql query qSS

//#region sql queries Totals
sql query qTotals2 =
  Select
    tSS.cCatDep,
    2 as wType,
    tSS.cPodgr,
    tSS.cCateg,
    sum(tSS.Qty) as Qty,
    sum(tSS.Salary + tSS.BonusVred + tSS.BonusPrem + tSS.BonusSekr) as Sum
  from
    tSS
  group by
    tSS.cCatDep,
    tSS.cPodgr,
    tSS.cCateg
;
//#endregion sql queries Totals

function CreateSqlTmpTables: integer;
{
  //Готовим sql таблицу tCatDep со структурными единицами ШР, действующими на дату _date
  var s: longint = 0;
  sqlFreeStr(s);
  sqlAddStr(s, 'table tCatDep (Nrec: comp, cParent: comp, Name: string, Code: string[100]);');
  result := sqlCreateTmpTable(s, ctmNormal);
  if result != tsOk exit;

  //Готовим sql таблицу tSS с вакансиями ШР
  sqlFreeStr(s);
  sqlAddStr(s, 'table tSS (');
  sqlAddStr(s, '  cCatDep  : comp,  ');
  sqlAddStr(s, '  cSS      : comp,  ');
  sqlAddStr(s, '  cPost    : comp,  ');
  sqlAddStr(s, '  cCateg   : comp,  ');
  sqlAddStr(s, '  cPodgr   : comp,  ');
  sqlAddStr(s, '  Qty      : double,');
  sqlAddStr(s, '  Salary   : double,');
  sqlAddStr(s, '  BonusVred: double,');
  sqlAddStr(s, '  BonusPrem: double,');
  sqlAddStr(s, '  BonusSekr: double ');
  sqlAddStr(s, ');');
  result := sqlCreateTmpTable(s, ctmNormal);
  if result != tsOk exit;

  //Готовим таблицу с итогами по структурным единицам ШР, подгруппами и категориями
  sqlFreeStr(s)
  sqlAddStr(s, 'table tTotals (');
  sqlAddStr(s, '  cCatDep: comp,');
  sqlAddStr(s, '  wType  : word,');
  sqlAddStr(s, '  cPodgr : comp,');
  sqlAddStr(s, '  cCateg : comp,');
  sqlAddStr(s, '  Qty    : double,');
  sqlAddStr(s, '  Sum    : double');
  sqlAddStr(s, ') with index (');
  sqlAddStr(s, '  i01 = wType + cCatDep,');
  sqlAddStr(s, '  i02 = wType + cCatDep + cPodgr,');
  sqlAddStr(s, '  i03 = wType + cCatDep + cPodgr + cCateg');
  sqlAddStr(s, ');');
  result := sqlCreateTmpTable(s, ctmNormal);
}

procedure DropSqlTmpTables;
{
  //Дропаем созданные sql таблицы
  sqlDropTmpTable('tCatDep');
  sqlDropTmpTable('tSS');
  sqlDropTmpTable('tTotals');
}

procedure CalcHierTotals(__cCatDep: comp);
{
  //Записываем в маркер нреки подчиненных подразделений
  var m: TPtr = InitMarker('', 8, 50, 10, false);
  vTotals._cCatDep := __cCatDep;
  vTotals._loop tCatDepChild
    InsertMarker(m, vTotals.tCatDepChild.Nrec);

  //Подсчитываем итоги по подчиненным подразделениям
  var i: longint = 0;
  var c: comp = 0;
  for(i := 0; GetMarker(m, i, c); i++)
    CalcHierTotals(c);
  DoneMarker(m, '');

  //Подсчитываем итоги по текущему подразделению
  vTotals._cCatDep := __cCatDep;
  vTotals._loop tCatDepChild
    vTotals._loop tTotalsChild
      if vTotals.getFirst tTotalsCur != tsOk
      {
        vTotals.tTotalsCur.wType   := 2;
        vTotals.tTotalsCur.cCatDep := __cCatDep;
        vTotals.tTotalsCur.cPodgr  := vTotals.tTotalsChild.cPodgr;
        vTotals.tTotalsCur.cCateg  := vTotals.tTotalsChild.cCateg;
        vTotals.tTotalsCur.Qty     := vTotals.tTotalsChild.Qty;
        vTotals.tTotalsCur.Sum     := vTotals.tTotalsChild.Sum;
        vTotals.Insert current tTotalsCur;
      }
      else
      {
        vTotals.tTotalsCur.Qty += vTotals.tTotalsChild.Qty;
        vTotals.tTotalsCur.Sum += vTotals.tTotalsChild.Sum;
        vTotals.Update current tTotalsCur;
      }

  //Подсчитываем итоги по текущему подразделению в разрезах "подразделение/подгруппа", "подразделение в целом"
  vTotals._loop tTotals2
  {
    if vTotals.getFirst tTotals1 != tsOk
    {
      vTotals.ClearBuffer(vTotals.tntTotals1);
      vTotals.tTotals1.wType   := 1;
      vTotals.tTotals1.cCatDep := vTotals.tTotals2.cCatDep;
      vTotals.tTotals1.cPodgr  := vTotals.tTotals2.cPodgr;
      vTotals.tTotals1.Qty     := vTotals.tTotals2.Qty;
      vTotals.tTotals1.Sum     := vTotals.tTotals2.Sum;
      vTotals.Insert current tTotals1;
    }
    else
    {
      vTotals.tTotals1.Qty     += vTotals.tTotals2.Qty;
      vTotals.tTotals1.Sum     += vTotals.tTotals2.Sum;
      vTotals.Update current tTotals1;
    }
    if vTotals.getFirst tTotals0 != tsOk
    {
      vTotals.ClearBuffer(vTotals.tntTotals0);
      vTotals.tTotals0.wType   := 0;
      vTotals.tTotals0.cCatDep := vTotals.tTotals2.cCatDep;
      vTotals.tTotals0.Qty     := vTotals.tTotals2.Qty;
      vTotals.tTotals0.Sum     := vTotals.tTotals2.Sum;
      vTotals.Insert current tTotals0;
    }
    else
    {
      vTotals.tTotals0.Qty     += vTotals.tTotals2.Qty;
      vTotals.tTotals0.Sum     += vTotals.tTotals2.Sum;
      vTotals.Update current tTotals0;
    }
  }
}

procedure PrepareData;
{
  //Заполняем sql таблицу tCatDep действующими на дату _date структурными единицами ШР
  var rslt: integer = queryManager.createQuery(qCatDep)
                                  .setParam('dateSts', _date)
                                  .setParam('topEntry', -11)
                                  .execute
                                  .errorCode;
  if rslt != tsOk { Message('Ошибка выборки структурных единиц ШР: ' + rslt, error); exit; }

  //Заполняем sql таблицу tSS вакансиями ШР
  rslt := queryManager.createQuery(qSS)
                      .setParam('dateSts', _date)
                      .setParam('cAttrNamCateg', ATTRNAM_NREC_KLKATEGO_CATEG)
                      .setParam('cAttrNamPodgr', ATTRNAM_NREC_KLKATEGO_PODGR)
                      .execute
                      .errorCode;
  if rslt != tsOk { Message('Ошибка выборки вакансий ШР: ' + rslt, error); exit; }

  //Заполняем временные таблицы интерфейса
  mtClear(tntCatDep, mfNormal);
  var q1: IQuery = queryManager.createQuery('select * from tCatDep').execute;
  sqlCopyInto(q1, tntCatDep, true);

  mtClear(tntSS, mfNormal);
  var q2: IQuery = queryManager.createQuery('select * from tSS').execute;
  sqlCopyInto(q2, tntSS, true);

  //Заполняем таблицу tTotals итогами без учета иерархии
  mtClear(tntTotals, mfNormal);
  var q: IQuery = queryManager.createQuery(qTotals2);
  rslt := q.execute.errorCode;
  if rslt = tsOk
    sqlCopyInto(q, tntTotals, true);
  else
    Message('Ошибка расчета итогов по категориям:' + rslt, error);
  //Дополняем таблицу tTotals итогами с учетом иерархии
  vRep._cCatDepTop := _catFunc.GetCatalogsNRec(-11);
    vRep._loop tCatDepTop
      CalcHierTotals(vRep.tCatDepTop.Nrec);
}

procedure PrintXlsNode(cCatStaffStruct: comp; wLevel: word = 0);
{
  //Вакансии по текущему узлу структурных единиц ШР
  set vRep._cCatDep := cCatStaffStruct;
  if vRep.getfirst tCatDep = tsOk
  {
    var npp: longint = 1;

    if vRep.getfirst tSS != tsOk
    {
      if vRep.getfirst tTotals0 = tsOk
        if vRep.tTotals0.Qty > 0
        {
          pXL.ClearTblBuffer;
          pXL.SetTblNumberFldValue('Level'    , wLevel);
          pXL.SetTblStringFldValue('SSName'   , vRep.tCatDep.Name);
          pXL.SetTblNumberFldValue('NPP'      , npp++);
          pXL.InsTblRow;
        }
    }
    else
    {
      vRep._loop tSS
      {
        pXL.ClearTblBuffer;
        pXL.SetTblNumberFldValue('Level'    , wLevel);
        pXL.SetTblStringFldValue('SSName'   , if(npp = 1, vRep.tCatDep.Name, ''));
        pXL.SetTblStringFldValue('SSCode'   , if(npp = 1, vRep.tCatDep.Code, ''));
        pXL.SetTblStringFldValue('PostName' , if(vRep.getfirst CatPost  = tsOk, vRep.CatPost.Name, ''));
        pXL.SetTblStringFldValue('Categ'    , if(vRep.getfirst SpkCateg = tsOk, vRep.SpkCateg.Name, ''));
        pXL.SetTblStringFldValue('Podgr'    , if(vRep.getfirst SpkPodgr = tsOk, vRep.SpkPodgr.Name, ''));
        pXL.SetTblNumberFldValue('Qty'      , vRep.tSS.Qty);
        pXL.SetTblNumberFldValue('Salary'   , vRep.tSS.Salary);
        pXL.SetTblNumberFldValue('BonusVred', vRep.tSS.BonusVred);
        pXL.SetTblNumberFldValue('BonusPrem', vRep.tSS.BonusPrem);
        pXL.SetTblNumberFldValue('BonusSekr', vRep.tSS.BonusSekr);
        pXL.SetTblNumberFldValue('Total'    , vRep.tSS.Salary + vRep.tSS.BonusVred + vRep.tSS.BonusPrem + vRep.tSS.BonusSekr);
        if (_flags and 1) = 1
        {
          var isFirstCommentStr: boolean = true;
          vRep._loop App
            if vRep.getfirst Persons = tsOk
            {
              pXL.AddTblStringFldValue('Comments', if(isFirstCommentStr, '', ''#13#10'') + GetSurnameWithInitials(vRep.Persons.FIO));
              isFirstCommentStr := false;
            }
        }
        pXL.SetTblNumberFldValue('NPP'      , npp++);
        pXL.InsTblRow;
      }
    }

    //Записываем в маркер подчиненные узлы структурных единиц ШР
    var m: TPtr = InitMarker('', 8, 50, 10, false);
    vRep._loop tCatDepChild
      InsertMarker(m, vRep.tCatDepChild.Nrec);
    //Выводим данные по подчиненным структурным единицам ШР
    var i: longint = 0;
    var c: comp = 0;
    for(i := 0; GetMarker(m, i, c); i++)
      PrintXlsNode(c, wLevel + 1);
    //Убиваем маркер
    DoneMarker(m, '');
  }

  //Итоги по текущему узлу структурных единиц ШР
  set vRep._cCatDep := cCatStaffStruct;
  if vRep.getfirst tCatDep = tsOk
  {
    if vRep.getfirst tTotals0 = tsOk
    {
      pXL.ClearTblBuffer;
      pXL.SetTblNumberFldValue('Level'    , wLevel);
      pXL.SetTblNumberFldValue('NPP'      , -1);
      pXL.SetTblStringFldValue('PostName' , 'Итого по ' + vRep.tCatDep.Name);
      pXL.SetTblNumberFldValue('Qty'      , vRep.tTotals0.Qty);
      pXL.SetTblNumberFldValue('Total'    , vRep.tTotals0.Sum);
      pXL.InsTblRow;
    }

    vRep._loop tTotals1
    {
      pXL.ClearTblBuffer;
      pXL.SetTblNumberFldValue('Level'    , wLevel);
      pXL.SetTblNumberFldValue('NPP'      , -2);
      pXL.SetTblStringFldValue('PostName' , 'В том числе ' + ShowKau(KODGRKAU_PODGR, vRep.tTotals1.cPodgr));
      pXL.SetTblNumberFldValue('Qty'      , vRep.tTotals1.Qty);
      pXL.SetTblNumberFldValue('Total'    , vRep.tTotals1.Sum);
      pXL.InsTblRow;

      vRep._loop tTotals2
      {
        pXL.ClearTblBuffer;
        pXL.SetTblNumberFldValue('Level'    , wLevel);
        pXL.SetTblNumberFldValue('NPP'      , -3);
        pXL.SetTblStringFldValue('PostName' , 'В т.ч. ' + ShowKau(KODGRKAU_CATEG, vRep.tTotals2.cCateg) +
                                              ' ' + ShowKau(KODGRKAU_PODGR, vRep.tTotals2.cPodgr));
        pXL.SetTblNumberFldValue('Qty'      , vRep.tTotals2.Qty);
        pXL.SetTblNumberFldValue('Total'    , vRep.tTotals2.Sum);
        pXL.InsTblRow;
      }

    }

  }

}


procedure PrintXlsReport(isCreateXLT: boolean; sXLTFileName: string);
{
  var sXLSFileName: string = if(isCreateXLT,
                                pXL.CreateXLT(sXLTFileName, True),
                                pXL.CreateReport(sXLTFileName, True));

  pXL.CreateTbls(sXLSFileName);
  pXL.CreateTbl('Main');
  pXL.CreateTblFld('Level');
  pXL.CreateTblFld('Npp');
  pXL.CreateTblFld('SSName');
  pXL.CreateTblFld('SSCode');
  pXL.CreateTblFld('PostName');
  pXL.CreateTblFld('Categ');
  pXL.CreateTblFld('Podgr');
  pXL.CreateTblFld('Qty');
  pXL.CreateTblFld('Salary');
  pXL.CreateTblFld('BonusVred');
  pXL.CreateTblFld('BonusPrem');
  pXL.CreateTblFld('BonusSekr');
  pXL.CreateTblFld('Total');
  pXL.CreateTblFld('Comments');

  if not isCreateXLT
  {
    vRep._cCatDepTop := _catFunc.GetCatalogsNRec(-11);
    vRep._loop tCatDepTop
      PrintXlsNode(vRep.tCatDepTop.Nrec);
  }

  pXL.PublishTbl('Main');

  //рассчитываем итоги по ШР в целом
  var totalQty: double = 0;
  var totalSum: double = 0;
  vRep._cCatDepTop := _catFunc.GetCatalogsNRec(-11);
  vRep._loop tCatDepTop
  {
    vRep._cCatDep := vRep.tCatDepTop.Nrec;
    if vRep.getfirst tTotals0 = tsOk
    {
      totalQty += vRep.tTotals0.Qty;
      totalSum += vRep.tTotals0.Sum;
    }
  }

  pXL.CreateVar(sXLSFileName);
  pXL.SetStringVar('dRep', _date);
  pXL.SetNumberVar('TotalQty', totalQty);
  pXL.SetNumberVar('TotalSum', totalSum);
  pXL.PublishVar;

  pXL.LoadReport(sXLSFileName);
  pXL.DisConnectExcel;
}

handleevent

cmOk:
{
  StartNewVisual(vtRotateVisual, vfTimer, 'Формирование отчета', 0);
  var rslt: integer = CreateSqlTmpTables;
  if rslt = tsOk
  {
    PrepareData;
    PrintXlsReport(false, TranslatePath('%StartPath%xls\AG_SHR.xltm'));
  }
  else
    Message('Ошибка создания временных таблиц: ' + rslt);
  DropSqlTmpTables;
  StopVisual('', 0);
}

cmInit:
{
  if not ReadMyDsk(_date, 'ag_shr_date', false) _date := cur_date;
  if not ReadMyDsk(_flags, 'ag_shr_flags', false) _flags := 0;
}

cmDone:
{
  SaveMyDsk(_date, 'ag_shr_date');
  SaveMyDsk(_flags, 'ag_shr_flags');
}

end;

end.



VipInterface UserReport_ag_shr Implements IUserReport licensed(free);
Interface UserReport_ag_shr;
  create view dummy;
  procedure Run;
  begin
    runinterfacenomodal(AGAT::ag_shr);
  end;

  function GetReportName: String;
  begin
    GetReportName := 'Агат. Штатное расписание';
  end;

  function GetGroupName (Level : Word) : String;
  begin
    GetGroupName := '';
  end;

  function GetPriority : Integer;
  begin
    GetPriority := 0;
  end;

  function VisibleInModule(Ind : Byte) : String;
  begin
    VisibleInModule := '';
    case Ind of
      1 : VisibleInModule := 'STAFFMAINMENU';
    end;
  end;
end.
