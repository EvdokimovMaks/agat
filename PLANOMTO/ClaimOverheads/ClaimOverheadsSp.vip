#include ClaimOverheads.vih
#include Query.vih
#include IModify.vih

#component "AGAT"

interface ClaimOverheadsSp;

sql Query qLoadSp =
select spm.nrec      as Nrec,
       spm.cspmnplan as ParentNrec,
       spm.nrec      as SpmnplanNrec,
       spm.condrec   as ConditionNrec,
       spm.number    as Number,
       spm.canval1   as CostitemNrec,
       spm.typeizd   as ItemType,
       spm.cizd      as ItemNrec,
       spm.cotped    as OtpedNrec,
       coalesce(vsp.kol, 0)    as Qty,
       coalesce(vsp.price, 0)  as Price,
       coalesce(vsp.vprice, 0) as Sum
from spmnplan spm
left join spmnpl spl on spl.cspmnplan = spm.nrec and spl.wkolan = 25
left join valspmnp vsp on vsp.cspmnpl = spl.nrec and spl.nrec is not null
where spm.cMnplan = :MnplanNrec
;

sql query qLoadSpMonth =
select spm.nrec as SpmnplanNrec,
       month(datetime(per.dbeg,0)) as MonthIndex,
       vsp.kol as Qty,
       vsp.price as Price,
       vsp.vPrice as Sum
from spmnplan spm
join spmnpl spl on spl.cspmnplan = spm.nrec and spl.wkolan = 1
join fpperiod per on spl.canval4 = per.nrec
join valspmnp vsp on vsp.cspmnpl = spl.nrec
where spm.cmnplan = :MnplanNrec
;

create view
as select *
from tClaimOverheadsSp tSp, tClaimOverheadsSp tSpChildren
where ((
  tSp.nrec == tSpChildren.parentNrec
));

create view vSp
var
  _spNrec: comp
as select *
from tClaimOverheadsSp tSp, tClaimOverheadsSp tSpChildren
where ((
  _spNrec == tSp.nrec and
  _spNrec == tSpChildren.parentNrec
));

create view vDelete
as select *
from tClaimOverheadsSp tSp;

create view vCheck
var
  _parentSpNrec: comp;
  _number: string[20];
  _costitemNrec: comp;
as select *
from tClaimOverheadsSp tSp
where ((
  _parentSpNrec    == tSp.parentNrec and
  (tSp.costitemNrec = _costitemNrec and
   tSp.number       = _number and
   tSp.ItemNrec     = 0)
));

create view v
as select *
from tClaimOverheadsSp tSp;

var
  _claim: IClaimOverheads;

//#region Вспомогательные функции

function  isValidMonthIndex(monthIndex: byte): boolean;
{
  result := monthIndex > 0 and monthIndex <= 12;
}

function getIsLeaf: boolean;
{
  result := getfirst fastfirstrow tSpChildren != tsOk;
}

procedure RecalcCurrent;
{
  var i: byte;
  tSp.qty := 0;
  tSp.sum := 0;
  for(i := 1; i <= 12; i++)
  {
    tSp.monthSum[i] := tSp.monthQty[i] * tSp.price;
    tSp.qty += tSp.monthQty[i];
    tSp.sum += tSp.monthSum[i];
  }
}

procedure RecalcSpAgregate(aSpNrec: comp);
{
  vSp._spNrec := aSpNrec;

  if vSp.getfirst fastfirstrow tSp = tsOk
  {

    vSp.tSp.sum    := 0;
    vSp.tSp.price  := 0;
    vSp.tSp.qty    := 0;

    var i: byte;
    for(i := 1; i <= 12; i++)
    {
      vSp.tSp.monthSum[i] := 0;
      vSp.tSp.monthQty[i] := 0;
    }

    vSp._loop tSpChildren
    {
      for(i := 1; i <= 12; i++)
      {
        vSp.tSp.monthSum[i] += vSp.tSpChildren.monthSum[i];
        vSp.tSp.monthQty[i] += vSp.tSpChildren.monthQty[i];
        vSp.tSp.qty         += vSp.tSpChildren.qty;
        vSp.tSp.sum         += vSp.tSpChildren.sum;
      }
    }

    vSp.update current  tSp;

    if vSp.tSp.parentNrec != 0
      RecalcSpAgregate(vSp.tSp.parentNrec);
  }
}

procedure DeleteSpChildren(aSpNrec: comp);
{
  var l: longint;
  l := initmarker('', 8, 10, 20, false);

  insertmarker(l, aSpNrec);

  var i: longint;
  var c: comp;
  for(i := 0; getmarker(l, i, c); i++)
  {
    vSp._spNrec := c;
    vSp._loop tSpChildren
      insertmarker(l, vSp.tSpChildren.nrec);
  }

  AtDeleteMarker(l, 0);

  vDelete.delete all tSp where foundmarker(l, vDelete.tSp.nrec);

  donemarker(l, '');
}

function CheckSpCostitem(aParentSpNrec: comp;
                         aCostitemNrec: comp;
                         aNumber: string;
                         aAllowAddChildren: boolean = true;
                         aItemType: word = 1): comp;
{
  vCheck._parentSpNrec := aParentSpNrec;
  vCheck._costitemNrec := aCostitemNrec;
  vCheck._number       := aNumber;

  if vCheck.getfirst tSp != tsOk
  {
    clearbuffer(#vCheck.tSp);
    vCheck.tSp.parentNrec := aParentSpNrec;
    vCheck.tSp.costitemNrec := aCostitemNrec;
    vCheck.tSp.number := aNumber;
    vCheck.insert current tSp;
  }

  vCheck.tSp.isCostitem    := true;
  vCheck.tSp.allowAddChild := aAllowAddChildren;
  vCheck.tSp.itemType      := aItemType;
  vCheck.update current tSp;

  result := vCheck.tSp.nrec;
}

//#endregion

//#region IModify

Function IModify.doInsert : Word;
{
  result := insert current tSp;
  RecalcSpAgregate(tSp.parentNrec);
}

Function IModify.doUpdate : Word;
{
  result := update current tSp;
  RecalcSpAgregate(tSp.parentNrec);
}

Function IModify.doDelete : Word;
{
  var aParentSpNrec: comp;
  aParentSpNrec := tSp.parentNrec;

  DeleteSpChildren(tSp.nrec);

  result := delete current tSp;

  RecalcSpAgregate(aParentSpNrec);
}

implementation IModify.doFlush  abstract;

//#endregion

//#region IClaimOverheadsSp

function  IClaimOverheadsSp.Load(aMnplanNrec: comp): boolean;
{
  delete all tSp;

  sqlCopyInto(
    queryManager.createQuery(qLoadSp).setParam('MnplanNrec',aMnplanNrec),
    #tSp,
    true
  );

  var rs: IResultSet;
  rs := queryManager.createQuery(qLoadSpMonth).setParam('MnplanNrec', aMnplanNrec).getResultSet;

  if rs != nullref
    if rs.getfirst = tsOk do
    {
      vSp._spNrec := rs.row.Val('SpmnplanNrec');
      if vSp.getfirst tSp = tsOk
      {
        var monthIndex: byte;
        monthIndex := rs.row.Val('MonthIndex');

        if isValidMonthIndex(monthIndex)
        {
          vSp.tSp.monthQty[monthIndex] := rs.row.Val('Qty');
          vSp.tSp.monthSum[monthIndex] := rs.row.Val('Sum');
          vSp.update current tSp;
        }
      }
    } while rs.getNext = tsOk;

  CheckCostitems;

  result := true;
}

procedure IClaimOverheadsSp.CheckCostitems;
{
  var spNrec1, spNrec2, spNrec3: comp;
  spNrec1 := CheckSpCostitem(0      , 0001000000000471h, '00001', false); //Расходы на материально - техническое обеспечение
  spNrec2 := CheckSpCostitem(spNrec1, 00010000000005E2h, '00002', false); //Некапитализируемые затраты (стоимость единицы < 100 000 тыс. руб.)
  spNrec3 := CheckSpCostitem(spNrec2, 000100000000031Ch, '00003', false); //Мебель, бытовая техника и пр.
             CheckSpCostitem(spNrec3, 00010000000009CCh, '00004', true);  //Мебель
             CheckSpCostitem(spNrec3, 00010000000009CDh, '00005', true);  //Бытовая техника
             CheckSpCostitem(spNrec2, 000100000000047Ch, '00006', true);  //Канцелярские принадлежности
             CheckSpCostitem(spNrec2, 000100000000047Dh, '00007', true);  //Материалы для нужд производства
             CheckSpCostitem(spNrec2, 000100000000047Eh, '00008', true);  //Инструменты, оборудование, приборы и пр.
             CheckSpCostitem(spNrec2, 00010000000009A4h, '00009', true);  //Материалы для копировально-множественной техники типографии
             CheckSpCostitem(spNrec2, 000100000000047Fh, '00010', true);  //Прочие материально-производственные запасы
             CheckSpCostitem(spNrec2, 00010000000005E2h, '00011', true);  //Некапитализируемые затраты (стоимость единицы < 100 000 тыс. руб.)
}

function  IClaimOverheadsSp.Save: boolean;
{
  result := true;
}

function  IClaimOverheadsSp.MonthQty(monthIndex: byte): double;
{
  result := if(isValidMonthIndex(monthIndex), tSp.monthQty[monthIndex], 0);
}

function  IClaimOverheadsSp.MonthSum(monthIndex: byte): double;
{
  result := if(isValidMonthIndex(monthIndex), tSp.monthSum[monthIndex], 0);
}

procedure IClaimOverheadsSp.SetMonthQty(monthIndex: byte; value: double);
{
  if isValidMonthIndex(monthIndex)
    if value != tSp.monthQty[monthIndex]
    {
      set tSp.monthQty[monthIndex] := value;
      RecalcCurrent;
    }
}

function  IClaimOverheadsSp.GetBuffer(aSpNrec: comp): TtClaimOverheadsSp;
{
  var buf: TtClaimOverheadsSp;
  ClearAdvRecord(buf);
  vSp._spNrec := aSpNrec;
  if vSp.getfirst tSp = tsOk
    buf := TtClaimOverheadsSp(vSp.tSp.buffer);
  result := buf;
}

function IClaimOverheadsSp.InsertNewWithBuffer(buf: TtClaimOverheadsSp): TtClaimOverheadsSp;
{
  clearbuffer(#v.tSp);
  v.tSp.buffer := buf;
  v.insert current tSp;
  result := TtClaimOverheadsSp(v.tSp.buffer);
}

property IClaimOverheadsSp.Nrec                : comp            absolute tSp.nrec;
property IClaimOverheadsSp.ParentNrec          : comp            absolute tSp.parentNrec;
property IClaimOverheadsSp.SpmnplanNrec        : comp            absolute tSp.spmnplanNrec;
property IClaimOverheadsSp.ConditionNrec       : comp            absolute tSp.conditionNrec;
property IClaimOverheadsSp.Number              : string[20]      absolute tSp.number;
property IClaimOverheadsSp.CostitemNrec        : comp            absolute tSp.costitemNrec;
property IClaimOverheadsSp.ItemType            : word            absolute tSp.itemType;
property IClaimOverheadsSp.ItemNrec            : comp            absolute tSp.itemNrec;
property IClaimOverheadsSp.OtpedNrec           : comp            absolute tSp.otpedNrec;
property IClaimOverheadsSp.Price               : double          absolute tSp.price;
property IClaimOverheadsSp.Qty                 : double          absolute tSp.qty;
property IClaimOverheadsSp.Sum                 : double          absolute tSp.sum;
property IClaimOverheadsSp.IsCostitem          : boolean         absolute tSp.isCostitem;
property IClaimOverheadsSp.AllowAddChildren    : boolean         absolute tSp.allowAddChild;
property IClaimOverheadsSp.Claim               : IClaimOverheads absolute _claim;

index IClaimOverheadsSp.iByNrec auto;
index IClaimOverheadsSp.iByParentNrec auto;

//#endregion

end.
