#include ioc.vih
#include utest.vih
#include utestmanagerlogservice.vih
#include marker.vih

#component "UTILS"

interface UTestManager 'Юнит-тесты';

const
  testresult_noresult = 0;
  testresult_success  = 1;
  testresult_fail     = 2;
end;

table struct tutests (
  nrec: comp,
  description: string,
  ifcname: string,
  testresult: byte
) with index (
  i01 = nrec (unique, surrogate)
);

table struct tlogs (
  nrec: comp,
  utestNrec: comp,
  logstr: string
) with index (
  i01 = nrec (unique, surrogate),
  i02 = utestNrec
);

var
  _marker: imarker(marker) new;
  _container: iIocContainer;
  _dependencyResolverManager: iDependencyResolverManager;
  _logService: UTestManagerLogService;

create view
as select * from tutests, tlogs, tutests brt, tlogs brl
where ((
  brt.nrec == brl.utestNrec
));

screen sc1;
  show(,,,3) fixed_y;
  buttons
    cmExecuteTests;
<<

 <. Выполнить.>
>>
end;

function getTestResultColor(aTestResult: byte): word;
{
  case aTestResult of
    testresult_noresult: result := 0;
    testresult_success: result := 11;
    testresult_fail: result := 12;
  end;
}

function getTestResultName(aTestResult: byte): string;
{
  case aTestResult of
    testresult_noresult: result := 'Не выполнялся';
    testresult_success: result := 'Успех';
    testresult_fail: result := 'Ошибка';
  end;
}

browse br1;
show(,4,,19);
table brt;
recmarker = _marker { brt.nrec };
fields
  {font={backcolor=getTestResultColor(brt.testresult);}};
  brt.description 'Описание':[50], protect;
  getTestResultName(brt.testresult) 'Результат':[15], protect;
end;

browse br2;
show(,20,,) fixed_y;
table brl;
fields
  brl.logstr 'Лог': [50], protect;
end;

procedure LoadTests;
{
  if LoadImplementationList('TEST::oUTest', 'TEST::TEST_')
  {
    var t: oUTest;
    var i, cnt: integer;
    cnt := GetImplementationCount;
    for( i := 0; i < cnt; i := i + 1 )
    {
      clearbuffer(#tUTests);
      tUTests.ifcName := GetImplementationName(i);
      tUTests.testresult := testresult_noresult;
      if loadvipref(t, tUTests.ifcName)
      {
        tUTests.description := t.GetDescription;
        insert current tUTests;
      }
    }
    UnLoadImplementationList;
  }
}

procedure AddLog(s: string);
{
  insert tLogs set tLogs.utestNrec := brt.Nrec, tLogs.logstr := s;
}

procedure Initialize;
{
  _container.Register('oLogService', 'UTILS::UTestManagerLogService');
  BindEvent(AddLog, _logService.OnLog);
}

procedure ExecuteTests;
{
  var allTests: boolean;
  allTests := _marker.count = 0;
  var lMarker: longint;
  lMarker := initmarker('', 8, 10, 10, false);
  _marker.ExportTo(lMarker);
  pushpos(#brt);
  _loop brt where ( allTests or foundmarker(lMarker, brt.Nrec) )
  {
    var utest: oUTest;
    if (getvipref(utest, brt.ifcname))
    {
      _dependencyResolverManager.ResolveDependencies(utest, oIocContainer(_container));
      if utest.Test
        brt.testresult := testresult_success
      else
        brt.testresult := testresult_fail;
      update current brt;
    }
  }
  poppos(#brt);
  donemarker(lMarker, '');
}

handleevent
cmExecuteTests:
{
  ExecuteTests;
  rereadrecord(#brt);
}
cminit:
{
  Initialize;
  LoadTests;
  rereadrecord(#brt);
}
end;

end.
