#include PD_RowSchema.vih
#include PD_ICellSchema.vih
#include PD_CellSchemaBase.vih

#component "PD_AGAT"

interface PD_RowSchema;

const
  CELL_SCHEMA_CNT: byte = 20;
end;

var
  _name: string;
  _cellSchema: array[1..CELL_SCHEMA_CNT] of PD_ICellSchema;

create view
var
  _cFormPl: comp;
  _cFormPl1: comp;
as select
  FormPl.Nrec
from
  FormPl
 ,FormPl FormPl1
where ((
      _cFormPl  == FormPl.Nrec
  and _cFormPl1 == FormPl1.Nrec
));

function initCellSchemaByFormPl(schema: PD_ICellSchema; cFormPl: comp): boolean;
{
  result := false;
  if schema = nullRef exit;
  _try
  {
    var ifc: PD_InitByFormPl = PD_InitByFormPl(schema);
    result := ifc.initByFormPl(cFormPl);
  }
  _except
    on ExObjIfcNoImpl: {}
}

procedure initCellSchemas;
{
  var i: byte = 0;
  for(i := 1; i <= CELL_SCHEMA_CNT; i++)
  {
    var schema: PD_ICellSchema = nullRef;
    _cFormPl1 := FormPl.ResComp[i];
    if getfirst FormPl1 = tsOk
      if FormPl1.ResName[20] != ''
        if loadVipRef(schema, FormPl1.ResName[20])
        {
          PD_CellSchemaBase(schema).setRepository(repository);
          initCellSchemaByFormPl(schema, FormPl1.Nrec);
          _cellSchema[i] := schema;
        }
  }
}

constructor _PD_RowSchema(repo: PD_IObjectRepository; cFormPl: comp);
{
  result := false;
  _cFormPl := cFormPl;
  if getfirst FormPl != tsOk exit;
  if not _PD_Object(repo) exit;
  _name := FormPl.Name;
  initCellSchemas;
  result := true;
}

procedure PD_IObject.free;
{
  inherited::free;
  var i: byte = 0;
  for(i := 1; i <= CELL_SCHEMA_CNT; i++)
    freeDependency(_cellSchema[i]);
}

function cellSchema(ind: byte): PD_ICellSchema;
{
  result := _cellSchema[ind];
}

property name: string read _name;

end.
