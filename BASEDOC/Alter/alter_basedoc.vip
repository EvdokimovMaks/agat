#include ContractId.vih
#include SpstepHelper.vih
#include BasedocHelper.vih
#include BusinessTripLinks.vih
#include AG_LinkMtrToSpec.vih
#include AG_TriggerUtils.vih
#include PD_ChangeStatusTxo.vih

#component "L_BASEDOC"

alter interface VSCHET;

  var
    _cidHelper: AGAT::ContractIDHelper;

  create view
  as select _cidHelper.GetContractID(GetContractIDKey_ByKatstroy, specmtr.cobj) (fieldname=ContractID)
  ;
end.

alter interface VSCHETB;

  overload
    function CopyDO(nRecDO : Comp; naltype : Word; NRecDog : Comp; WithOutRes : Boolean; ChargeParam : Word; NeedNomMes : Word): comp;
    Function DoBaseDocDelete(DelSoprDoc : boolean; bPack: boolean = FALSE): word;
    Procedure PickFromKat;
    Procedure DoLinkMtr2Spec(awAction: word); //Добавлен функционал пакетной установки ЦУ по помеченным позициям
    Procedure MakeDOonDogDoc; //При формировании ДО по договору отключаем проверку на наличие накладных/платежей к ДО
    Procedure SwitchFields; // При формировании ДО по договору позволяем пользователю заполнить ДО по исходному количеству, а не только по остаткам
  end;

  extendformats scspstep, brvschet;

  var
    _cidHelper   : AGAT::ContractIDHelper;
    _spstepHelper: AGAT::SpstepHelper;
    _basedocHelper: AGAT::BasedocHelper;
    _businessTripLinks: AGAT::BusinessTripLinkManager;
    _changeStatusTXO: PD_ChangeStatusTxo;
    _cOldDogovor: comp;
    _cOldAppDog : comp;
    _cOldCalPlan: comp;

  #declare JoinBasedocAttrval(cattrnam, avAlias)
    1102            == #avAlias.wtable and
    basedoc.nrec    == #avAlias.crec and
    #cattrnam       == #avAlias.cattrnam
  #end

  create view
  var
    rzdTax  : double;
    rzdTax18: double;
    rzdTax10: double;
  as select
    //_cidHelper.GetContractID(GetContractIDKey_ByKatstroy, specmtr.cobj) (fieldname=ContractID),
    //_basedocHelper.GetDeferredDaysCount(basedoc.nrec) (fieldname=DaysDeferredPay),
    //_businessTripLinks.GetLinkedRashdocPresentation(spstep.nrec) (fieldname=LinkedRashdoc)
    '' (fieldname=ContractID),
    '' (fieldname=DaysDeferredPay),
    '' (fieldname=LinkedRashdoc)
  from attrval avNaznpl,
       attrval avIspoln,
       attrval avDDS,
       attrval avSogl,
       attrval avKazn,
       attrval avBuh,
       attrval avPeu,
       attrval avDir,
       attrval avSMP,
       attrval avISK
  where ((
    #JoinBasedocAttrval(ATTRNAM_NAZNPL, avNaznpl) and
    #JoinBasedocAttrval(ATTRNAM_ISPOLN, avIspoln) and
    #JoinBasedocAttrval(ATTRNAM_DDS   , avDDS   ) and
    #JoinBasedocAttrval(ATTRNAM_SOGL  , avSogl  ) and
    #JoinBasedocAttrval(ATTRNAM_KAZN  , avKazn  ) and
    #JoinBasedocAttrval(ATTRNAM_BUH   , avBuh   ) and
    #JoinBasedocAttrval(ATTRNAM_PEU   , avPeu   ) and
    #JoinBasedocAttrval(ATTRNAM_DIR   , avDir   ) and
    #JoinBasedocAttrval(ATTRNAM_SMP   , avSmp   ) and
    #JoinBasedocAttrval(ATTRNAM_ISK   , avIsk   )
  ))
  condition KatSoprNrec0 = KatSopr.Nrec = comp(0)
  condition BaseFinNrec0 = BaseFin.Nrec = comp(0)
  ;

  create view mw_v
  as select bd.nrec
  from attrval av, basedoc bd;

  browse brvschet (,hcZAKUPWSPISOKDO, sci1478EnIns);
    table basedoc;
    fields
      basedoc.name     'Примечание'          : [10], protect;
      avIspoln.vString 'Исполнитель договора': [10], protect;
      avDDS.vString    'Статья ДДС'          : [10], protect;
      avSogl.vString   'НА СОГЛ'             : [10], protect;
      avKazn.vString   'Казн'                : [10], protect;
      avBuh.vString    'Бухг'                : [10], protect;
      avPeu.vString    'ПЭУ'                 : [10], protect;
      avDir.vString    'Комм.'               : [10], protect;
      avSmp.vString    'ИСК'                 : [10], protect;
      avIsk.vString    'СМП'                 : [10], protect;
  end;

  Procedure PickFromKat;
  {
    inherited::PickFromKat;
    _spstepHelper.SetSpstepStZatrByBasedoc(basedoc.nrec);
  }

  Function PermitDelete: boolean;
  {
    var _s: string;
    var _c: comp;
    _c := basedoc.nrec;
    _s := '';
    if (mw_v.getfirst av where ((1102 == av.wtable and _c == av.crec and ATTRNAM_SOGL == av.cattrnam)) = tsOk)
      _s := trim(mw_v.av.vstring);
    result := not(_s <> '' and basedoc.desgr <> sgettune('USER.DESCR'));
  }

  Function DoBaseDocDelete(DelSoprDoc : boolean; bPack: boolean = FALSE): word;
  {
    result := 0;
    if not PermitDelete
    {
      message('Запрещено удалять счета, созданные другим пользователем, переданные на согласование');
      result := 0;
    }
    else
    {
      result := inherited::DoBaseDocDelete(DelSoprDoc,bPack);
    }
  }

  function CopyDO(nRecDO : Comp; naltype : Word; NRecDog : Comp; WithOutRes : Boolean; ChargeParam : Word; NeedNomMes : Word): comp; {
    var _c: comp;
    AG_TriggersState::PushAllTriggersState;
    AG_TriggersState::SetAllTriggersState(false);
    _c := inherited::CopyDO(nRecDO,naltype,NRecDog,WithOutRes,ChargeParam,NeedNomMes);
    if _c <> 0 {
      mw_v.delete all av where ((1102 == av.wtable and _c == av.crec and ATTRNAM_SOGL   == av.cattrnam));
      mw_v.delete all av where ((1102 == av.wtable and _c == av.crec and ATTRNAM_BUH    == av.cattrnam));
      mw_v.delete all av where ((1102 == av.wtable and _c == av.crec and ATTRNAM_DIR    == av.cattrnam));
      mw_v.delete all av where ((1102 == av.wtable and _c == av.crec and ATTRNAM_KAZN   == av.cattrnam));
      mw_v.delete all av where ((1102 == av.wtable and _c == av.crec and ATTRNAM_PEU    == av.cattrnam));
      mw_v.delete all av where ((1102 == av.wtable and _c == av.crec and ATTRNAM_REZERV == av.cattrnam));

      mw_v.delete all av where ((1102 == av.wtable and _c == av.crec and ATTRNAM_PRBUH  == av.cattrnam));
      mw_v.delete all av where ((1102 == av.wtable and _c == av.crec and ATTRNAM_PRKAZ  == av.cattrnam));
      mw_v.delete all av where ((1102 == av.wtable and _c == av.crec and ATTRNAM_PRDIR  == av.cattrnam));
      mw_v.delete all av where ((1102 == av.wtable and _c == av.crec and ATTRNAM_PRPEU  == av.cattrnam));

      mw_v.delete all av where ((1102 == av.wtable and _c == av.crec and ATTRNAM_BUHSCH == av.cattrnam));
      mw_v.delete all av where ((1102 == av.wtable and _c == av.crec and ATTRNAM_BDR    == av.cattrnam));

      mw_v.update bd where ((_c == bd.nrec)) set bd.dform := cur_date;
    }
    AG_TriggersState::PopAllTriggersState;
    result := _c;
  }

  //Добавлен функционал пакетной установки ЦУ по помеченным позициям
  Procedure DoLinkMtr2Spec(awAction: word);
  {
    if pSpMarker.Count > 0 and CurTable = #SpStep
    {
      var m: TPtr = InitMarker('', 8, 10, 10, true);
      pSpMarker.ExportTo(m);
      var linkMtrToSpec: AG_ILinkMtrToSpec = AG_ILinkMtrToSpec(new(
        AG_LinkMtrToSpec, _AG_LinkMtrToSpec(coSpStep, m, coGetTune('CELUCHFORMODUL.BUY'))));
      if linkMtrToSpec.showUI = cmDefault
        linkMtrToSpec.linkMtr;
      DoneMarker(m, '');
      rereadrecord(#SpStep);
    }
    else
      inherited::DoLinkMtr2Spec(awAction);
  }

  //При формировании ДО по договору отключаем проверку на наличие накладных/платежей к ДО
  Procedure MakeDOonDogDoc;
  {
    PushConditionForLeave(tcKatSoprNrec0, #KatSopr);
    PushConditionForLeave(tcBaseFinNrec0, #BaseFin);
    inherited::MakeDOonDogDoc;
    PopConditionForLeave(tcKatSoprNrec0, #KatSopr);
    PopConditionForLeave(tcBaseFinNrec0, #BaseFin);
  }

  // При формировании ДО по договору позволяем пользователю заполнить ДО по исходному количеству, а не только по остаткам
  Procedure SwitchFields;
  {
    inherited::SwitchFields;
    //если формирование не по финансовому ПКП
    if wMDP_SpecType != 404
      //если присутствует спецификация
      if bMDP_SpecExist[wMDP_SpecType]
        //разрешаем редактирование поля с типом заполнения ДО - по остаткам / по исходному количеству
        ToggleFieldSelectable(#wMDP_Ostatok, True);
  }

//#region Расчет налогов по билетам РЖД

  procedure RZDRecalc;
  {
    if (BaseDoc.dDoc < To_Date(1,1,2019))
      set rzdTax18 := round( (spstep.summa-11*rzdTax)/(118/18-11) , 6);
    else
      set rzdTax18 := round( (spstep.summa-11*rzdTax)/(120/20-11) , 6);
    set rzdTax10 := rzdTax - rzdTax18;
  }

  procedure RZDRefresh;
  {
    RZDRecalc;
    rescanpanel(#spstep);
  }

  procedure RZDAddTax(grnalNrec: comp; percent: double; sum: double);
  {
    clearbuffer (#spdocnal);
    spdocnal.cspdoc    := spstep.nrec;
    spdocnal.cdoc      := basedoc.nrec;
    spdocnal.tipdoc    := 1101;
    spdocnal.cgrnal    := grnalNrec;
    spdocnal.cnalog    := 2;
    spdocnal.nalog     := percent;
    spdocnal.sumnal    := sum;
    spdocnal.cval      := 0;
    spdocnal.sumval    := sum;
    spdocnal.summa     := sum;
    spdocnal.corg      := basedoc.corg;
    spdocnal.valcurse  := 1;
    spdocnal.croscurse := 1;
    spdocnal.iscustom  := 6;
    insert current spdocnal;
  }

  procedure RZDSetTaxes;
  {
    var grnalNrec: comp;
    if rzdTax10 = 0 and rzdTax18 != 0
      grnalNrec := 4001A6F2CE900165h //НДС 18% / 20%
    else if rzdTax10 != 0 and rzdTax18 = 0
      grnalNrec := 4001A573A6E5F4D3h //НДС 10%
    else
      grnalNrec := 0001000000000006h; //НДС10,18

    spstep.nds       := rzdTax;
    spstep.cgrnal    := grnalNrec;
    spstep.manualtax := 1;
    update current spstep;

    delete all spdocnal where ((spstep.nrec == spdocnal.cspdoc));

    if rzdTax10 != 0 RZDAddTax(grnalNrec, 10, rzdTax10);
    if rzdTax18 != 0 RZDAddTax(grnalNrec, if(BaseDoc.dDoc < To_Date(1,1,2019), 18, 20), rzdTax18);

  }

  window wGetRZDTaxSum 'Введите сумму налогов по билету', doAccept, escClose;
  show (,,45,8);
  screen scRZDTaxCalc;
  fields
    spstep.summa: ['[|-]3666`666`666`666.88\2p'], left, skip;
    rzdTax      : ['[|-]3666`666`666`666.88\2p'], noprotect;
    rzdTax10    : ['[|-]3666`666`666`666.88\2p'], left, skip;
    rzdTax18    : ['[|-]3666`666`666`666.88\2p'], left, skip;
  buttons
    cmRZDRecalc;
    cmRZDSetTaxes, default;
    cmCancel;
<<

  `Сумма по позиции`.@@@@@@@@@@@@@@@@@@@@
  `Сумма налогов`   .@@@@@@@@@@@@@@@@@@@@
  `Налог 10%:`      .@@@@@@@@@@@@@@@@@@@@
  `Налог 18%:`      .@@@@@@@@@@@@@@@@@@@@

<. Пересчет .> <.Установить .> <. Отмена .>
>>
  end;
  handleevent
    cmInit: { rzdTax := spstep.nds; RZDRefresh;  }
    cmCheckField: { RZDRefresh }
    cmRZDRecalc: { RZDRefresh }
    cmRZDSetTaxes: { RZDRefresh; putcommand(cmDefault); }
  end;
  end; //window wGetRZDTaxSum

  window wspstep;
    Panel p1;
    Table SpStep;

    screen scspstep;
    buttons
      cmCalcTaxesRZD;
<<







                                                                               <. Расчет налогов по билетам .>
>>
    end; //screen

    end; //panel

    handleevent
      cmCalcTaxesRZD:  {
        if (runwindowmodal(wGetRZDTaxSum) = cmDefault and rzdTax10 >=0 and rzdTax18 >= 0) RZDSetTaxes;
        rescanpanel(#spstep);
        rereadrecord(#spdocnal);
      }
    end;
  end;

//#endregion

  procedure OnBeforeEditDogAppPKP;
  {
    _cOldDogovor := BaseDoc.cDogovor;
    _cOldAppDog  := BaseDoc.cAppDogovor;
    _cOldCalPlan := BaseDoc.cCalPlan;
  }

  procedure OnAfterEditDogAppPKP;
  {
    if BaseDoc.Status != 2 exit;
    if BaseDoc.cDogovor    = _cOldDogovor and
       BaseDoc.cAppDogovor = _cOldAppDog and
       BaseDoc.cCalPlan    = _cOldCalPlan
      exit;

    RereadRecord(#BaseDoc);

    var wOldStatus: word = BaseDoc.Status;
    var cOldNote: comp = BaseDoc.cNote;

    set BaseDoc.Status := 1;
    set BaseDoc.cNote  := KATNOTES_NREC_BASEDOC_OFORML;
    update current BaseDoc;

    oStatLog.StatLog_InsNewStat(40, BaseDoc.Nrec, wOldStatus, cOldNote,
                                BaseDoc.Status, BaseDoc.cNote, 'Изменен договор/ДС/ПКП');

    _changeStatusTXO.process(40, BaseDoc.Nrec, cOldNote, BaseDoc.cNote);

    message('Счет переведен в статус "Оформляемый"');
  }

  #declare InheritedHandleevent(Command)
  case inherited::handleevent(#Command) of
    heAbort: Abort;
    heStop: Stop;
  end;
  #end

  tableevent table BaseDoc;
    cmPick:
    {
      case curfield of
        #DogNoDoc
       ,#DogDDoc
       ,#Dogovor.dDoc
       ,#AppDogNoDoc
       ,#AppDogDDoc
       ,#AppDogovor.dDoc
       ,#CalPlan.NoDoc
       ,#CalPlan.dInput:
        {
          OnBeforeEditDogAppPKP;
          #InheritedHandleevent(cmPick)
          OnAfterEditDogAppPKP;
        }
        else
          #InheritedHandleevent(cmPick)
      end;
    }
    cmDelOnProtect:
    {
      case curfield of
        #DogNoDoc
       ,#DogDDoc
       ,#Dogovor.dDoc
       ,#AppDogNoDoc
       ,#AppDogDDoc
       ,#AppDogovor.dDoc
       ,#CalPlan.NoDoc
       ,#CalPlan.dInput:
        {
          OnBeforeEditDogAppPKP;
          #InheritedHandleevent(cmDelOnProtect)
          OnAfterEditDogAppPKP;
        }
        else
          #InheritedHandleevent(cmDelOnProtect)
      end;
    }
  end;  //tableevent table BaseDoc

  handleevent
    cmCheckField:
    {
      case curfield of
        #avNaznpl.vstring:
        {
          if isvalidall(#avNaznpl)
          {
            update current avNaznpl;
          }
          else
          {
            var s: string;
            s := avNaznpl.vstring;
            clearbuffer(#avNaznpl);
            avNaznpl.vstring := s;
            insert current avNaznpl;
          }
        }
      end;
    }
    cmpick:
    {
      case curfield of
        #avNaznpl.vstring:
        {
          UpdateTable;
          _basedocHelper.SetNaznPl(BaseDoc.Nrec);
          RescanPanel(#basedoc);
          RereadRecord(#avNaznpl);
        }
      end;
    }
  end; //handleevent interface
end.
